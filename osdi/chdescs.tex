\subsection {Change Descriptors}
\label{sec:design:chdescs}

\subsubsection {Overview}
% The first use of "change descriptor" is written out. All others, if not the
% same, should be defined in parentheses here.
Each in-memory modification to a cached disk block in \Kudos\ has an associated
change descriptor. Different change types correspond to different forms of
\chdescs; the \chdesc\ for a flipped bit -- such as in a free-block bitmap --
contains an offset and mask, while larger changes contain an offset, a length,
and the new data. The \chdesc's dependencies point to other \chdescs\ that must
precede it to stable storage. A \chdesc\ can be applied or reverted to switch
the cached block's state between old and new as necessary. Each \chdesc\ applies
to exactly one block.

Figure~\ref{fig:chdesc} gives a simplified version of the structure. The ability
to revert and re-apply \chdescs\ is inspired by the soft updates system in BSD's
FFS~\cite{ganger00soft} (discussed in \S\ref{sec:consistency:softupdate}), but
generalized so that it is not specific to any particular file system. Just as
with soft updates~\cite{ganger00soft}, the dependencies among \chdescs\ (or just
``updates to the block'' in soft updates) can create cyclic dependencies among
blocks, even though the \chdescs\ themselves do not form a cycle. To handle this
case, some \chdescs\ may need to be ``held back'' in order to write the others,
allowing such cycles to be broken.

\begin{figure}
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct chdesc {
    BD_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct chdesc_queue *dependencies;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}

When a \Kudos\ \module\ first generates \chdescs\ to write to the disk, it
specifies write ordering requirements similar to those of soft updates. For
example, Figure~\ref{fig:softupdate} depicts \chdescs\ that allocate and add a
new block to an inode. The \module\ passes these \chdescs\ to another \module\
closer to the disk. This second \module\ can inspect, delay, and even modify
them before passing them on further. For instance, the write-back cache \module\
(\S\ref{sec:modules:wbcache}) holds on to blocks and their \chdescs\ instead of
forwarding them immediately. When evicting a block and associated \chdescs, the
write-back cache enforces an order consistent with the \chdesc\ dependency
information.

\subsubsection{Block Revisioning}
Since many \modules\ may be stacked on top of one another in \Kudos, and since
many of them may want to refer to the same block at the same time, only one copy
of the data for each block is kept in memory at a time. However, different
\modules\ may ``know about'' different sets of \chdescs. For example, in the
cycle breaking situation outlined in \S\ref{sec:modules:wbcache}, the \module\
below the write-back cache will know about some of the \chdescs\ on a block but
not others (the ones which are not ``ready'' to be sent to it yet). If this
\module\ is the disk, it will need to be able to write a version of the block's
data that does not include the \chdescs\ it does't know about yet. \Kudos\
provides a revisioning system for blocks which can automatically ``roll back''
the \chdescs\ which have not yet reached a particular \module, and then roll
them forward again after that \module\ is done using the previous version of the
block's data (e.g. to write it to disk).

\subsubsection {Optimizations}
% FIXME: should this section be in the discussion section?
Many of the operations that \modules\ like the write-back cache need to do
involve quickly discovering the set of \chdescs\ that satisfy some property,
and often even some ordering of those \chdescs. In early prototypes, these sets
were often calculated by doing graph traversals of the dependency graph of
\chdescs. However, these traversals are in practice extremely expensive, and
many optimizations were necessary in order to improve the performance of
\Kudos.

For instance, consider the structure of a \chdesc\ itself. The list of
dependencies is often changing as a \chdesc\ moves through the system. Even
when no \modules\ are explicitly ``rewiring'' the \chdescs, dependencies on a
\chdesc\ must be removed when that \chdesc\ is destroyed as a result of having
been written to disk. Simple singly linked lists originally stored the lists of
dependencies, and it turned out that a lot of time was being spent traversing
those lists in order to destroy each \chdesc. It turned out that almost always,
the element being removed from the list was at the end of the list -- because
it had been added longest ago, and often changes were being written to disk in
an order similar to the order in which they had been made. The solution was to
convert the linked list into a queue, so that elements would be added to one
end of the list and removed from the other. This converted a linear time search
into one which would usually execute in constant time.

Another example is that when examining a block and deciding which \chdescs\ must
be rolled back in order for the block's data to be safe to write to the disk,
the dependency graph between the various changes on that block must be taken
into account so that changes which depend on one another are rolled back in
proper dependency order. Originally, a traversal of the \chdesc\ graph rooted at
the block's \noop\ \chdesc\ (which depends on all the changes on that block) was
used to calculate the correct ordering. This was very computationally intensive
when more than a small number of \chdescs\ were involved. The algorithm was
changed to examine only those \chdescs\ actually on the block, and still it was
not as good as we had hoped. Finally, we discovered that we were examining the
\chdescs\ in almost exactly the opposite order as the order they should be
rolled back in -- for the same reason as the previous example. By simply
changing the direction of the loop, we were able to improve the loop from
quadratic time to linear time.

We believe that there are still many places \chdesc\ operations can be
optimized to improve the performance of \Kudos. Many of these places likely
will have the same flavor as the two examples here: information we already have
can be used in order to determine the answers we need, without needing to
directly calculate those answers. Even as it is, however, \Kudos\ does not run
dramatically slower than a standard Linux 2.6 kernel.

\subsubsection {Manipulations and Transformations}
\Chdescs play a central role in \Kudos, and therefore many parts of the system
need to generate, consume, forward, and manipulate them. Obviously there are
many operations which will need to be done frequently -- for instance, many
simple block devices like partitioners will need to simply forward \chdescs\ on
to the next block device after adjusting the block number being written. The
write-back cache (\S\ref{sec:modules:wbcache}) and elevator scheduler
(\S\ref{sec:modules:elevator}) both need to determine whether \chdescs\ are
ready to send to the next block device or not. In implementing the \modules\ we
have so far, we have identified many of these common operations and made them
into \chdesc\ library functions.

Additionally, there are some more complex transformations which are useful for
devices like the mirroring block device (\S\ref{sec:modules:raid}), or the
journaling \module (\S\ref{sec:consistency:journal}). The mirroring block device
must duplicate the \chdescs\ passing through it, so that each of the mirrors has
its own copy. The journal must copy entire blocks into a journal area, and
overwrite that journal area efficiently when the blocks are changed again during
the same transaction. Both of these \chdesc\ transformations are handled by
library functions, so that if other \modules\ need to do similar things, the
functionality will already be available.

\subsubsection {Applications}
% FIXME: should this section be moved to the consistency section?
Soft updates, journaling, and many application-specific consistency models all
correspond to different \chdesc\ arrangements, so these features can be added to
the system as \modules\ which appropriately connect or reconnect the \chdescs.
For example, the \chdescs\ in Figure~\ref{fig:softupdate} can be transformed to
provide journaling semantics. The original four \chdescs\ are modified to depend
on a journal commit record, which depends on blocks journaling the changes. Once
the actual changes commit, the journal record is marked as completed.
Figure~\ref{fig:journal} shows these transformed \chdescs. Our journaling
\module\ (see \S\ref{sec:consistency:journal}) can attach to any file system
\module; it performs transformations incrementally as \chdescs\ arrive.

Further, by changing our journal \module\ to journal only \chdescs\ that modify
file system metadata -- and by adding additional dependencies to prevent
premature reuse of blocks -- we could even obtain metadata-only journaling.
(These extra \chdesc\ dependencies would serve the same purpose as the extra
hooks corner cases surrounding reuse of blocks discussed in
\cite{tweedie00ext3}.) The journal \module\ can distinguish metadata \chdescs\
because of the LFS interface described in \S\ref{sec:design:interfaces}. Other
block device layering systems, like GEOM~\cite{geom} or JBD in Linux, would or
do need special hooks into file system code to determine what disk changes
represent metadata in order to do metadata-only journaling. \Chdescs\ and the
LFS interface allow us to do this automatically.
