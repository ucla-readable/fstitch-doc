\subsection {Change Descriptors}
\label{sec:design:chdescs}

\subsubsection {Overview}
% The first use of "change descriptor" is written out. All others, if not the
% same, should be defined in parentheses here.
Each in-memory modification to a cached disk block in \Kudos\ has an associated
change descriptor. Different change types correspond to different forms of
\chdescs; the \chdesc\ for a flipped bit -- such as in a free-block bitmap --
contains an offset and mask, while larger changes contain an offset, a length,
and the new data. The \chdesc's dependencies point to other \chdescs\ that must
precede it to stable storage. A \chdesc\ can be applied or reverted to switch
the cached block's state between old and new as necessary. Each \chdesc\ applies
to exactly one block.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows most of the API for working with them. The ability
to revert and re-apply \chdescs\ is inspired by the soft updates system in BSD's
FFS~\cite{ganger00soft} (discussed in \S\ref{sec:consistency:softupdate}), but
generalized so that it is not specific to any particular file system. Just as
with soft updates~\cite{ganger00soft}, the dependencies among \chdescs\ (or just
``updates to the block'' in soft updates) can create cyclic dependencies among
blocks, even though the \chdescs\ themselves do not form a cycle. To handle this
case, some \chdescs\ may need to be ``rolled back'' in order to write the
others, allowing such cycles to be broken.

\begin{figure}
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct chdesc {
    BD_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct chdesc_queue *dependencies;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
chdesc_t chdesc_create_noop(
    bdesc_t *block, BD_t *owner);

chdesc_t chdesc_create_bit(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint32_t xor);

int chdesc_create_byte(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, chdesc_t **head);

int chdesc_create_diff(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *newdata, chdesc_t **head);

int chdesc_add_depend(
    chdesc_t *depender, chdesc_t *dependee);

void chdesc_remove_depend(
    chdesc_t *depender, chdesc_t *dependee);

int chdesc_apply(chdesc_t *chdesc);

int chdesc_rollback(chdesc_t *chdesc);

int chdesc_satisfy(chdesc_t *chdesc);

int chdesc_noop_reassign(
    chdesc_t *noop, bdesc_t *block);

int chdesc_push_down(
    BD_t *current_bd, bdesc_t *current_block,
    BD_t *target_bd, bdesc_t *target_block);

int chdesc_move(
    chdesc_t *chdesc, bdesc_t *destination,
    BD_t *target_bd, uint16_t source_offset);
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}

When a \Kudos\ \module\ first generates \chdescs\ to write to the disk, it
specifies write ordering requirements similar to those of soft updates. For
example, Figure~\ref{fig:softupdate} depicts \chdescs\ that allocate and add a
new block to an inode. The \module\ passes these \chdescs\ to another \module\
closer to the disk. This second \module\ can inspect, delay, and even modify
them before passing them on further. For instance, the write-back cache \module\
(\S\ref{sec:modules:wbcache}) holds on to blocks and their \chdescs\ instead of
forwarding them immediately. When evicting a block and associated \chdescs, the
write-back cache enforces an order consistent with the \chdesc\ dependency
information.

\subsubsection{\Noop\ Change Descriptors}
Add section about \noop\ \chdescs\ here.

\subsubsection{Block Revisioning}
% FIXME maybe make an analogy to packets flowing through a network? -LZ
Since many \modules\ may be stacked on top of one another in \Kudos, and since
many of them may want to refer to the same block at the same time, only one copy
of the data for each block is kept in memory at a time. However, each \chdesc\
on the block may or may not have reached a given \module\ -- for example, a
write-back cache may choose to write some \chdescs\ on a block, while holding on
to others because they have unsatisfied dependencies. In this case, the \module\
below the write-back cache will know about some of the \chdescs\ on that block
but not others (the ones with unsatisfied dependencies). If this \module\ is the
disk, it will need to be able to write a version of the block's data that does
not include the \chdescs\ that have not yet been sent to it. \Kudos\ provides a
revisioning system for blocks which can automatically roll back the \chdescs\
which have not yet reached a particular \module, and then roll them forward
again after that \module\ is done using the previous version of the block's data
(e.g. to write it to disk).

\subsubsection {Optimizations}
% FIXME: should this section be in the discussion section?
% FIXME: don't beat ourselves up so much
Many of the operations that \modules\ like the write-back cache need to do
involve quickly discovering the set of \chdescs\ that satisfy some property,
and often even some ordering of those \chdescs. In early prototypes, these sets
were often calculated by doing graph traversals of the dependency graph of
\chdescs. However, these traversals are in practice extremely expensive, and
many optimizations were necessary in order to improve the performance of
\Kudos.

For instance, consider the structure of a \chdesc\ itself. The list of
dependencies is often changing as a \chdesc\ moves through the system. Even
when no \modules\ are explicitly ``rewiring'' the \chdescs, dependencies on a
\chdesc\ must be removed when that \chdesc\ is destroyed as a result of having
been written to disk. Simple singly linked lists originally stored the lists of
dependencies, and it turned out that a lot of time was being spent traversing
those lists in order to destroy each \chdesc. It turned out that almost always,
the element being removed from the list was at the end of the list -- because
it had been added longest ago, and often changes were being written to disk in
an order similar to the order in which they had been made. The solution was to
convert the linked list into a queue, so that elements would be added to one
end of the list and removed from the other. This converted a linear time search
into one which would usually execute in constant time.

Another example is that when examining a block and deciding which \chdescs\ must
be rolled back in order for the block's data to be safe to write to the disk,
the dependency graph between the various changes on that block must be taken
into account so that changes which depend on one another are rolled back in
proper dependency order. Originally, a traversal of the \chdesc\ graph rooted at
the block's \noop\ \chdesc\ (which depends on all the changes on that block) was
used to calculate the correct ordering. This was very computationally intensive
when more than a small number of \chdescs\ were involved. The algorithm was
changed to examine only those \chdescs\ actually on the block, and still it was
not as good as we had hoped. Finally, we discovered that we were examining the
\chdescs\ in almost exactly the opposite order as the order they should be
rolled back in -- for the same reason as the previous example. By simply
changing the direction of the loop, we were able to improve the loop from
quadratic time to linear time.

We believe that there are still many places \chdesc\ operations can be
optimized to improve the performance of \Kudos. Many of these places likely
will have the same flavor as the two examples here: information we already have
can be used in order to determine the answers we need, without needing to
directly calculate those answers. Even as it is, however, \Kudos\ does not run
dramatically slower than a standard Linux 2.6 kernel.

\subsubsection {Manipulations and Transformations}
% FIXME: add concrete details here
\Chdescs\ play a central role in \Kudos, and therefore many parts of the system
need to generate, consume, forward, and manipulate them. Obviously there are
many operations which will need to be done frequently -- for instance, many
simple block devices like partitioners will need to simply forward \chdescs\ on
to the next block device after adjusting the block number being written. The
write-back cache (\S\ref{sec:modules:wbcache}) and elevator scheduler
(\S\ref{sec:modules:elevator}) both need to determine whether \chdescs\ are
ready to send to the next block device or not. In implementing the \modules\ we
have so far, we have identified many of these common operations and made them
into \chdesc\ library functions.

Additionally, there are some more complex transformations which are useful for
devices like the mirroring block device (\S\ref{sec:modules:raid}), or the
journaling \module (\S\ref{sec:consistency:journal}). The mirroring block device
must duplicate the \chdescs\ passing through it, so that each of the mirrors has
its own copy. The journal must copy entire blocks into a journal area, and
overwrite that journal area efficiently when the blocks are changed again during
the same transaction. Both of these \chdesc\ transformations are handled by
library functions, so that if other \modules\ need to do similar things, the
functionality will already be available.

\subsubsection {...}
% Should end with an example -- a little diagram, perhaps
% borrowed from soft updates -- and then perhaps discussion, with things like
% the last paragraph of optimizations above
