\subsection {Change Descriptors}
\label{sec:design:chdescs}

\subsubsection {Overview}
% The first use of "change descriptor" is written out. All others, if not the
% same, should be defined in parentheses here.
Each in-memory modification to a cached disk block in \Kudos\ has an associated
change descriptor. Different change types correspond to different forms of
\chdescs; the \chdesc\ for a flipped bit -- such as in a free-block bitmap --
contains an offset and mask, while larger changes contain an offset, a length,
and the new data. The \chdesc's dependencies point to other \chdescs\ that must
precede it to stable storage. A \chdesc\ can be applied or reverted to switch
the cached block's state between old and new as necessary. Each \chdesc\ applies
to exactly one block.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows most of the API for working with them. The ability
to revert and re-apply \chdescs\ is inspired by the soft updates system in BSD's
FFS~\cite{ganger00soft} (discussed in \S\ref{sec:consistency:softupdate}), but
generalized so that it is not specific to any particular file system. Just as
with soft updates~\cite{ganger00soft}, the dependencies among \chdescs\ (or just
``updates to the block'' in soft updates) can create cyclic dependencies among
blocks, even though the \chdescs\ themselves do not form a cycle. To handle this
case, some \chdescs\ may need to be ``rolled back'' in order to write the
others, allowing such cycles to be broken.

\begin{figure}
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct chdesc {
    BD_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct chdesc_queue *dependencies;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
chdesc_t *\textbf{chdesc_create_noop}(
    bdesc_t *block, BD_t *owner);
chdesc_t *\textbf{chdesc_create_bit}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint32_t xor);
int \textbf{chdesc_create_byte}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, chdesc_t **head);
int \textbf{chdesc_create_diff}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *newdata, chdesc_t **head);
int \textbf{chdesc_add_depend}(
    chdesc_t *depender, chdesc_t *dependee);
void \textbf{chdesc_remove_depend}(
    chdesc_t *depender, chdesc_t *dependee);
int \textbf{chdesc_apply}(chdesc_t *chdesc);
int \textbf{chdesc_rollback}(chdesc_t *chdesc);
int \textbf{chdesc_satisfy}(chdesc_t *chdesc);
int \textbf{chdesc_noop_reassign}(
    chdesc_t *noop, bdesc_t *block);
int \textbf{chdesc_push_down}(
    BD_t *current_bd, bdesc_t *current_block,
    BD_t *target_bd, bdesc_t *target_block);
int \textbf{chdesc_move}(
    chdesc_t *chdesc, bdesc_t *destination,
    BD_t *target_bd, uint16_t source_offset);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}

When a \Kudos\ \module\ first generates \chdescs\ to write to the disk, it
specifies write ordering requirements similar to those of soft updates (see
\S\ref{sec:consistency:softupdates}). The \module\ passes these \chdescs\ to
another \module\ closer to the disk. This second \module\ can inspect, delay,
and even modify them before passing them on further. For instance, the
write-back cache \module\ (\S\ref{sec:modules:wbcache}) holds on to blocks and
their \chdescs\ instead of forwarding them immediately. When evicting a block
and associated \chdescs, the write-back cache enforces an order consistent with
the \chdesc\ dependency information.

\subsubsection{\Noop\ Change Descriptors}
\label{sec:design:chdescs:noop}
An important type of \chdesc\ is actually one that doesn't change the disk at
all: the \noop\ \chdesc. \Noop\ \chdescs\ can have dependencies, like any other
\chdesc, but they are trivially satisfied when all of their dependencies are
satisfied. Thus, they can be used to ``stand for'' entire sets of other changes.
This capability is extremely useful, and is used by most operations on disk
structures so that a single \chdesc\ can be returned that depends on the whole
change. Likewise, a \noop\ \chdesc\ can be passed in as a parameter to that
operation, to make the whole operation depend on something else. \Noop\
\chdescs\ are the ``glue'' that makes this possible without a quadratic number
of dependency edges in the \chdesc\ graph, and without having to pass around
arrays of \chdescs\ that together implement some change to a file system.

\Noop\ \chdescs\ can also be used in a special way to prevent other \chdescs\
from being written until some \module\ decides it is allowable. By making a
\chdesc\ depend on a \noop\ \chdesc\ which itself has no dependencies (called a
``managed'' \noop\ \chdesc), that \chdesc\ will always have an unsatisfied
dependency until the \module\ that created the managed \noop\ \chdesc\
explicitly satisfies it. This is used, for instance, by the journal \module\
(\S\ref{sec:consistency:journal}) in order to prevent \chdescs\ in a transaction
from being written before the commit record.

\subsubsection{Block Revisioning}
% FIXME maybe make an analogy to packets flowing through a network? -LZ
Since many \modules\ may be stacked on top of one another in \Kudos, and since
many of them may want to refer to the same block at the same time, only one copy
of the data for each block is kept in memory at a time. However, each \chdesc\
on the block may or may not have reached a given \module\ -- for example, a
write-back cache may choose to write some \chdescs\ on a block, while holding on
to others because they have unsatisfied dependencies. In this case, the \module\
below the write-back cache will know about some of the \chdescs\ on that block
but not others (the ones with unsatisfied dependencies). If this \module\ is the
disk, it will need to be able to write a version of the block's data that does
not include the \chdescs\ that have not yet been sent to it. \Kudos\ provides a
revisioning system for blocks which can automatically roll back the \chdescs\
which have not yet reached a particular \module, and then roll them forward
again after that \module\ is done using the previous version of the block's data
(e.g. to write it to disk).

\subsubsection {Manipulations and Transformations}
% FIXME: add concrete details here
\Chdescs\ play a central role in \Kudos, and therefore many parts of the system
need to generate, consume, forward, and manipulate them. Obviously there are
many operations which will need to be done frequently -- for instance, many
simple block devices like partitioners will need to simply forward \chdescs\ on
to the next block device after adjusting the block number being written. The
write-back cache (\S\ref{sec:modules:wbcache}) and elevator scheduler
(\S\ref{sec:modules:elevator}) both need to determine whether \chdescs\ are
ready to send to the next block device or not. In implementing the \modules\ we
have so far, we have identified many of these common operations and made them
into \chdesc\ library functions.

Additionally, there are some more complex transformations which are useful for
devices like the mirroring block device (\S\ref{sec:modules:raid}), or the
journaling \module (\S\ref{sec:consistency:journal}). The mirroring block device
must duplicate the \chdescs\ passing through it, so that each of the mirrors has
its own copy. The journal must copy entire blocks into a journal area, and
overwrite that journal area efficiently when the blocks are changed again during
the same transaction. Both of these \chdesc\ transformations are handled by
library functions, so that if other \modules\ need to do similar things, the
functionality will already be available.

\subsubsection {...}
% Should end with an example -- a little diagram, perhaps
% borrowed from soft updates -- and then perhaps discussion, with things like
% the last paragraph of optimizations above
