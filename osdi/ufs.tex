\section{UFS implementation}
\label{sec:ufs}

UFS is the modern incarnation of the classic Berkeley Fast File System
~\cite{mckusick84fast} used in 4.2 BSD. The general concepts for UFS, such as
inodes, cylinder groups, and indirect blocks, are well understood. UFS
implementations exist for many popular UNIX-derived operating systems,
including FreeBSD, Solaris, and Mac OS X. Many vendors have added extentions
to UFS. Examples include UFS with journaling on Solaris and UFS with soft
updates on FreeBSD. Linux's Ext2 file system has much in common with UFS,
since it borrowed many ideas from FFS. For \Kudos, we implemented the UFS1
file system as a LFS \module. We chose UFS because it has been extended in
many ways. In particular, it is the only file system that has been extended
with both soft updates and journaling. We chose UFS1 over UFS2, as UFS1 is
well establish and more widely supported.

Soft updates for UFS is one of the biggest innovations in file systems in
terms of lowering the overhead required to provide file system consistency.
By carefully ordering writes to disk, soft updates avoid the need for
synchronous writes to disk or duplicate writes to a journal. Soft updates also
guarantees consistency after a crash, so the system can avoid time-consuming
file system consistency checks. \S\ref{sec:softupdate} explains soft updates
in greater detail.
Another approach to protecting the integrity of the file system is to write
upcoming operations to a journal first. The content and the layout of the
journal varies per implementation, but in all cases, the system can use the
journal to play out or rollback the operations that did not complete as a
result of a crash. Thereby \emph{fsck} can be avoided. \S\ref{sec:journal}
explains journaling with \chdescs.
For a comparison of journaling versus soft updates for UFS, see
~\cite{seltzer00journaling}.

The LFS interface naturally divides the implementation into a set of simpler
tasks. By breaking down CFS calls into smaller LFS calls, we come up with a
set of problems that are easier to reason about. For example, the CFS write()
call, and similarly the Linux VFS write() call, has the task of writing N
bytes of data to a file at a given offset. Rather than implementing a single
function that will have to calculate which block to write to, when to
allocated and append new blocks, and writing the data, LFS separates the
logic into four calls:
get\_file\_block(), allocate\_block(), append\_block(), and write\_block().
This allows us to systematically add functionality to our UFS \module\ in
an incremental fashion. With some basic knowledge of the UFS data structures,
we implemented read functionality by examining pre-existing UFS disk images.
For write functionality, we did writes to disk and verified correctness using
FreeBSD's \emph{fsck}.

Properties specific to a file system, such as the UFS on-disk format and rules
governing block allocation, are not exposed at the LFS layer. Although file
systems can have uncommon requirements, LFS is flexible enough to accomidate
many of them. One problem we ran into concerns UFS and its use of fragments
and blocks. In UFS, typically a block is divided into 8 equal sized fragments.
For space efficiency, UFS allocates fragments to small files. Once a file gets
big enough to require the use of indirect blocks, then UFS changes its
allocation policy and starts allocating blocks for speed. To implement this
property of UFS, we used fragments as the basic block size. For large files,
our UFS \module\ internally allocates a block, but returns only the first
fragment in that block at the LFS level. The next 7 allocation calls will be
no-ops that simply return the subsequent fragments in the allocated block.

Using \chdescs, the UFS \module\ can control the ordering for writes to disk.
This allows UFS to create sets of \chdescs\ and hooking them up in
configurations that achieve soft updates consistency. Under normal operation,
once the dependencies have been created, UFS no longer needs to concern itself
with the \chdescs\ it created. The BD subsystem will track and enforce the
\chdesc\ orderings. For rare error cases that occur, UFS oftentimes
undo the operation by creating \chdescs\ that reverse the original operation.
We hope future versions of \Kudos\ will be able to automatically detect this
arrangement of \chdescs\ and cancel them.

\begin{figure}[tb]
  \centering
  \includegraphics[width=92pt]{fig/figures_4}
  \caption{\label{fig:ufsmodules} The UFS \module\ is itself composed of
  sub-\modules. The UFS base \module\ holds the core code that does not vary,
  while components that should be flexible, such as those that relate to
  block/inode allocation, cylinder groups, directory entries, and the
  superblock, can be easily exchanged.}
\end{figure}

Previously, \Kudos\ used a minimal file system called JOSFS. Even though JOSFS
is extremely simple, at the time it was the largest \module\ in \Kudos\ in
terms of LOC. With a real file system like UFS, a monolithic version will
easily be 3 to 4 times bigger than JOSFS. In earlier version of the \Kudos UFS
implementation, having one monolithic \module\ made it difficult to change the
algorithms and policies for particular parts of UFS. The code also got more
difficult to manage. The problem of how to generalize the subdivision within
a file system is a difficult one, since not all file systems share the same
characteristics. In light of this fact, we decided to have specialized
interfaces specific to each file system \module. As we implement more file
system \modules, we will discover commonalities to help in the subdivision
problem.

Applying our modularity philosophy to UFS, we refactored the file system
\module\ and separated many logical parts into sub-\modules\ internal to UFS,
as shown in Figure~\ref{fig:ufsmodules}.
Within the UFS \module, the \emph{base} module cotains the core code for the
file system. Using object-orientation techniques, we encapsulated the code
for data structures in the file system, like the superblock and the cylinder
groups. We also recognized two locations where we can apply different
search algorithms. One is with respect to the allocation functions for blocks,
fragments, and inodes. The other is for searching and writing directory
entries. In addition to making the code easier to manage, having a modular
file system means it is easy to try out new algorithms. Currently we have
two allocator modules as a proof of concept for modularity. In the future,
we hope to improve UFS with more sophisticated allocation algorithms.

With regards to optimizations for our UFS implementation, we found several
FIXME BETTER WORD: \emph{ideas} critical to good performance. First, do not
create unnecessary dependencies between \chdescs. Doing so artificially limits
the commit order for \chdescs, which results in bad performance for several
reasons. Not only will unneeded dependencies force the disk do more writes and
seeks, but \Kudos will have to scan through the \chdesc\ graph
multiple times, since the dependencies prevent the \chdescs\ from being
flushed out to disk at once. TODO PUT EXAMPLE HERE WITH ANALYSIS AND FIGURE. 
An instance like this came up because our UFS implementation frequently writes
the \emph{cylinder group summaries} out to disk. By simply changing the
arrangement between three \chdescs\ created in a single function, UFS got a
33\% increase for several common file operations.

A corollary of this observation is to create \chdescs\ of the minimal size
to avoid accidental overlaps, which in turn, creates unnecessary dependencies.
With \chdescs, they can represent changes to regions as small as one byte, and
as large as an entire block. Many times, it can be inefficient for developers
to calculate exactly what parts in a large data structure has been modified and
needs to be written to disk. As such, laziness will result in the creation of
\chdescs\ for the entire data structure. Doing this can be detrimental to
performance, as shown in Figure~\ref{fig:overlap}. This issue came up for
inodes, where we modified several fields within the inode. In principle, the
\chdescs\ created are independent of one another. However, because we did not
take the time to calculate the exact offsets and lengths for the fields that
changes, we just created a \chdesc\ for the entire inode every time we modified
any part of the inode. Thereby all changes to any given inode overlapped,
causing unnecessary dependencies. The solution to this problem is a utility
function called chdesc\_create\_diff(), which compares a modified copy of the
data structure to the original, and creates a minimal set of \chdescs\ 
accordingly. Do to the frequent use of inodes, one simple use of
chdesc\_create\_diff() in the UFS inode functions reduced \chdescs graph
traversal time significantly.

\begin{figure}[htb]
  \centering
  \includegraphics[width=92pt]{fig/figures_5}
  \caption{\label{fig:overlap} For inode 17, \chdesc\ A and \chdesc\ B are
  independent changes to separate fields that do not overlap. Making \chdescs\ 
  for the entire inode data structure will, in turn, make \chdesc\ B depend
  on \chdesc\ A because they overlap.}
\end{figure}

Our UFS code is mostly complete, but some features are missing:
i.e. handling triple indirect blocks and sparse files.

Modularity means there exists places where we are less efficient
than a more integrated implementation. These trouble spots present
an opportunity for improvement.

