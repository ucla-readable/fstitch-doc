\subsection{UFS implementation}
\label{sec:modules:ufs}

\subsubsection {Overview}
UFS is the modern incarnation of the classic Berkeley Fast File System
~\cite{mckusick84fast} used in 4.2 BSD. The general concepts for UFS, such as
inodes, cylinder groups, and indirect blocks, are well understood. UFS
implementations exist for many popular UNIX-derived operating systems, including
FreeBSD, Solaris, and Mac OS X. Many vendors have added extentions to UFS.
Examples include UFS with journaling on Solaris and UFS with soft updates on
FreeBSD. Linux's Ext2 file system has much in common with UFS, since it borrowed
many ideas from FFS. For \Kudos, we implemented the UFS1 file system as a LFS
\module. We chose UFS because it has been extended in many ways. In particular,
it is the only file system that has been extended with both soft updates and
journaling. We chose UFS1 over UFS2, as UFS1 is well establish and more widely
supported.

Soft updates for UFS is one of the biggest innovations in file systems in terms
of lowering the overhead required to provide file system consistency. By
carefully ordering writes to disk, soft updates avoid the need for synchronous
writes to disk or duplicate writes to a journal. Soft updates also guarantees
consistency after a crash, so the system can avoid time-consuming file system
consistency checks using the \emph{fsck} ~\cite{mckusick94fsck} tool.
\S\ref{sec:consistency:softupdate} explains soft updates in greater detail.
Another approach to protecting the integrity of the file system is to write
upcoming operations to a journal first. The content and the layout of the
journal varies per implementation, but in all cases, the system can use the
journal to play out or rollback the operations that did not complete as a result
of a crash. Thereby \emph{fsck} can be avoided. \S\ref{sec:consistency:journal}
explains journaling with \chdescs. For a comparison of journaling versus soft
updates for UFS, see ~\cite{seltzer00journaling}.

\subsubsection {Implementation Design Philosophy}
The LFS interface naturally divides the implementation into a set of simpler
tasks. By breaking down CFS calls into smaller LFS calls, we come up with a
set of problems that are easier to reason about. For example, the CFS write()
call, and similarly the Linux VFS write() call, has the task of writing N
bytes of data to a file at a given offset. Rather than implementing a single
function that will have to calculate which block to write to, when to
allocated and append new blocks, and writing the data, LFS separates the
logic into four calls:
get\_file\_block(), allocate\_block(), append\_block(), and write\_block().
This allows us to systematically add functionality to our UFS \module\ in
an incremental fashion. With some basic knowledge of the UFS data structures,
we implemented read functionality by examining pre-existing UFS disk images.
For write functionality, we did writes to disk and verified correctness using
FreeBSD's \emph{fsck}.

Properties specific to a file system, such as the UFS on-disk format and rules
governing block allocation, are not exposed at the LFS layer. Although file
systems can have uncommon requirements, LFS is flexible enough to accomidate
many of them. One problem we ran into concerns UFS and its use of fragments
and blocks. In UFS, typically a block is divided into 8 equal sized fragments.
For space efficiency, UFS allocates fragments to small files. Once a file gets
big enough to require the use of indirect blocks, then UFS changes its
allocation policy and starts allocating blocks for speed. To implement this
property of UFS, we used fragments as the basic block size. For large files,
our UFS \module\ internally allocates a block, but returns only the first
fragment in that block at the LFS level. The next 7 allocation calls will be
no-ops that simply return the subsequent fragments in the allocated block.

Using \chdescs, the UFS \module\ can control the ordering for writes to disk.
This allows UFS to create sets of \chdescs\ and hooking them up in
configurations that achieve soft updates consistency. Unlike FreeBSD's soft
updates implementation, once the dependencies have been created, UFS no longer
needs to concern itself with the \chdescs\ it created. The BD subsystem will
track and enforce the \chdesc\ orderings.

\begin{figure}[htb]
  \centering
  \includegraphics[width=108pt]{fig/figures_4}
  \caption{\label{fig:ufsmodules} The UFS \module\ is itself composed of
  sub-\modules. The UFS base \module\ holds the core code that does not
  vary, while components that should be flexible, such as those that relate
  to block/inode allocation, cylinder groups, directory entries, and the
  superblock, can be easily exchanged.}
\end{figure}

\subsubsection {Modularity}
Previously, \Kudos\ used a minimal file system called JOSFS. Even though JOSFS
is extremely simple, at the time it was the largest \module\ in \Kudos\ in
terms of LOC. This is from the fact that much of the actual work occurs in the
file system \modules. For instance, most \chdescs\ in the system are created
when the file system \modules\ needs to write to disk. With a real file system
like UFS, a monolithic version will easily be 3 to 4 times bigger than JOSFS.
In earlier version of the \Kudos\ UFS implementation, having one monolithic
\module\ made it difficult to change the algorithms and policies for
particular parts of UFS. In addition, the large amount of code for one
\module\ got more difficult to manage.

From our experiences with JOSFS, we realized UFS will become harder to maintain
as it grows in size. We failed several times trying to come up with a way to
further divide the file system module. The problem of how to generalize the
subdivision within a file system is a difficult one, since not all file systems
share the same characteristics. In light of this fact, we decided to have
specialized interfaces specific to each file system \module. As we implement
more file system \modules, we will discover commonalities to help in the
subdivision problem.

Applying our modularity philosophy to UFS, we refactored the file system
\module\ and separated many logical parts into sub-\modules\ internal to UFS,
as shown in Figure~\ref{fig:ufsmodules}.
Within the UFS \module, the \emph{base} module cotains the core code for the
file system. Using object-orientation techniques, we encapsulated the code
for data structures in the file system, like the superblock and the cylinder
groups. We also recognized two locations where we can apply different
search algorithms. One is with respect to the allocation functions for blocks,
fragments, and inodes. The other is for searching and writing directory
entries. In addition to making the code easier to manage, having a modular
file system means it is easy to try out new algorithms. Currently we have
two allocator modules as a proof of concept for modularity.

\begin{figure}[htb]
  \centering
  \includegraphics[width=192pt]{fig/figures_6}
  \caption{\label{fig:chdescarrange} Change descriptor dependencies, when
  not strictly needed, restrict the possible choices for write ordering.
  This results in suboptimal write ordering and more scans through the
  \chdescs\ for \Kudos. On the left, \chdescs\ C1, C2, and C3 can be written
  in any order. Only one ordering is possible on the right.}
\end{figure}

\subsubsection {Change Descriptor Arrangements}
With regards to optimizations for our UFS implementation, we found a couple
practices critical to good performance. First, do not create unnecessary
dependencies between \chdescs. Doing so artificially limits the commit order
for \chdescs, which results in bad performance for several reasons. Not only
will unneeded dependencies force the disk to do more writes and seeks, but
\Kudos\ will have to scan through the \chdesc\ graph multiple times, since the
dependencies prevent the \chdescs\ from being flushed out to disk at once.

In Figure~\ref{fig:chdescarrange}, we have two possible arrangements for three
byte \chdescs. The noop \chdesc\ represents a root node that can reach all
other \chdescs. In the parallel arrangement on the left, \Kudos\ has the
freedom to write \chdescs\ $C_1$, $C_2$, and $C_3$ to disk in any order. All
three \chdescs\ can be marked writable with one graph traversal. In the serial
arrangement on the right, there exists only one valid write ordering. For
\Kudos\ to write this arrangement out to disk, it will have to scan through
the graph three times, since \chdesc\ $C_n$ cannot be marked as writable until
$C_{n-1}$ has been written.
An instance like this came up because our UFS implementation frequently writes
the \emph{cylinder group summaries} out to disk. By simply changing the
arrangement between three \chdescs\ created in a single function, UFS got a
33\% speed increase for several common file operations.

A corollary of this observation is to create \chdescs\ of the minimal size
to avoid accidental overlaps, which in turn, creates unnecessary dependencies.
With \chdescs, they can represent changes to regions as small as one byte, and
as large as an entire block. Many times, it can be tedious for developers
to calculate exactly what parts in a large data structure has been modified and
needs to be written to disk. As such, laziness will result in the creation of
\chdescs\ for the entire data structure. Doing this can be detrimental to
performance, as shown in Figure~\ref{fig:overlap}.

This issue came up for inodes, where we modified several fields within the
inode. In principle, the \chdescs\ created are independent of one another.
However, because we did not take the time to calculate the exact offsets and
lengths for the fields that changes, we just created a \chdesc\ for the entire
inode every time we modified any part of the inode. Thereby all changes to any
given inode overlapped, causing unnecessary dependencies. The solution to this
problem is a utility function called chdesc\_create\_diff(), which compares a
modified copy of the data structure to the original, and creates a minimal set
of \chdescs\ accordingly. Do to the frequent use of inodes, one simple use of
chdesc\_create\_diff() in the UFS inode functions reduced \chdescs\ graph
traversal time significantly.

\begin{figure}[htb]
  \centering
  \includegraphics[width=64pt]{fig/figures_5}
  \caption{\label{fig:overlap} On inode 17, the gray regions represent
  modified fields that do not overlap. If \chdesc\ A and \chdesc\ B are
  exactly the size of the gray regions, then there is no implicit dependency.
  Making \chdescs\ for the entire inode data structure will, in turn, make
  one \chdesc\ depend on the other because they overlap.}
\end{figure}

\subsubsection {Future Improvements}
Our UFS implementation is usable for everyday purposes. However, there are
some features we do not have. For example, we do not support symbolic links,
triple indirect blocks, and sparse files. The first two can easily be
implemented given time. Sparse file support will require the LFS interface
to be aware of files with holes. This also means the layer immediately above
the LFS interface may need to discard some assumptions it currently makes
about files and block allocation.

There are also auxillary on disk data structures that assist the resource
allocation algorithms. We currently ignore many of them, partially because
our basic algorithms do not use them, and partially because there lacks
documentation to explain what those data structures represent. Over time,
we hope to improve our UFS \module\ with more sophisticated allocation
algorithms, as the infrastructure for this already exists.

Having a modular system also means there are places where we are less
efficient than a more integrated solution. Although we have removed some
of the redundency, some still exist. One example is having to read directory
entries multiple times during lookup operations. Coupled with our naive
directory search implementation, we can see why \Kudos\ has not reached
optimal performance.

For rare cases when errors occur, UFS oftentimes undo the operation by
creating \chdescs\ that reverse the original operation. We hope future
versions of \Kudos\  will be able to automatically detect arrangement of
\chdescs\ and coalesce them into a no-op. Another idea is to have some
mechanism for voiding \chdescs\ the file system has already sent down to the
BD layer.
