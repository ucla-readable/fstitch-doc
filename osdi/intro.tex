\section {Introduction}
\label{sec:intro}

Once upon a time, our research began as an attempt to decompose file system
software into small \modules, which would make the system as a whole more
configurable, extensible, and easier to understand -- as has been done in other
domains, like packet forwarding~\cite{kohler00click}. Upon examining existing
systems that accomplish similar tasks, and after some initial design for the new
system, it became clear that a key part of modern file system design is not
addressed by \modules\ alone: consistency. For robustness, stability, and
recovery speed, modern file system implementations must ensure that the file
system's stored image is kept consistent or easy to return to consistency.
Advanced consistency mechanisms such as soft updates~\cite{ganger00soft} and
journaling make this possible; unfortunately, they are generally tied to a
particular file system, and can't be ported or adapted without significant
engineering effort. Furthermore, existing module systems did not provide a way
to actually \emph{implement} (or even just \emph{change}) such consistency
mechanisms; the stacking is done either above or below where that part of the
system would need to be implemented.

These consistency mechanisms all hinge on one critical ability in the file
system software: the ability to place specific ordering requirements on writes
to the disk. What was needed, then, was a way to formalize these ordering
requirements in a file system independent way, so that all the \modules\ in our
system would be able to work with them. In this way, the loosely-coupled
\modules\ that make up the complete file system implementation would be able to
cooperate to implement strong and often complex consistency guarantees, even
though each individual \module\ does only a small and simple part of the work.

% We use "change descriptor" here on purpose. An abberviated form, if necessary,
% will only be introduced in the change descriptor section.

We propose a new file system implementation architecture, called \emph{\Kudos},
where \emph{change descriptor} structures represent any and all changes to
stable storage. File systems generate change descriptors for all writes, then
send them to block devices for eventual commit. Explicit dependencies between
change descriptors let \Kudos\ \modules\ preserve necessary file system
invariants without understanding the file system itself. Change descriptors can
implement many consistency mechanisms, including soft updates and journaling.
They can also be extended, in a carefully controlled way, into userspace --
enabling applications with custom consistency and performance requirements to
specify explicit write ordering restrictions to be honored by the file system.
We will show that this can give such applications several benefits over existing
interfaces like \texttt{fsync()} which provide only coarse control over
consistency, or which either impose high overhead (data journaling) or don't
guarantee data consistency (soft updates, for example, ensures metadata
consistency only).

\Kudos\ is decomposed into fine-grained \modules\ which generate, consume,
forward, and manipulate change descriptors. A particular innovation of the
\module\ design is the separation of the low-level specification of on-disk
layout from higher-level file system-independent code, which operates on
abstract disk structures. Our journaling \module\ can automatically add
journaling to any file system, and combinations of simple \modules\ can support,
for example, correct consistency on RAID over loop-back devices.
