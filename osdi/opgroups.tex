\section{User-level Change Descriptors}
\label{sec:opgroup}

% FIXME: A bit harder to follow than earlier sections, but on the plus
% side, there's an actual INTERFACE DESCRIPTION!!!

\newcommand{\opgroupCreate}{\texttt{opgroup\_create()}}
\newcommand{\opgroupSync}{\texttt{opgroup\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{opgroup\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{opgroup\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{opgroup\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{opgroup\_release()}}
\newcommand{\opgroupAbandon}{\texttt{opgroup\_abandon()}}

\begin{comment}
opgroup
changegroup
user-level change descriptor
chap (CHAnge grouP)
uchad (User-level CHAnge Descriptor)
sher (uSer-level cHange dEscriptor gRoup)
\end{comment}

\Kudos\ \modules\ use \chdescs\ to express internal file system
consistency protocols, such as soft updates and journaling
(\S\ref{sec:consistency}).
%
Applications also implement consistency protocols, for example CVS
clients for synchronizing local files with the server and IMAP servers
for committing mailbox changes to disk. In this section we discuss the
extension of \chdescs\ from \Kudos\ to user applications to support
custom application-level consistency protocols. We discuss the
\opgroup\ interface and implementation and a case study of \opgroups\
in the UW IMAP server.

\begin{comment}
Old:
Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW IMAP server.
\end{comment}

\subsection{Interface}
\label{sec:opgroup:interface}
We believe applications will find \chdesc\ functionality most useful
for specifying orderings among file system operations.  \Anopgroup\
corresponds to the group of \chdescs\ generated by a file system
operation; applications can specify ordering requirements among these
groups. Figure~\ref{fig:opgroup-interface} shows the \opgroup\
interface functions.

\newcommand{\opgroupid}{opgroup\_id\_t}

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.0in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int opgroup_id_t;
opgroup_id_t \textbf{opgroup_create}(int type);
int \textbf{opgroup_sync}(opgroup_id_t opgroup);
int \textbf{opgroup_add_depend}(
    opgroup_id_t depender, opgroup_id_t dependee);
int \textbf{opgroup_engage}(opgroup_id_t opgroup);
int \textbf{opgroup_disengage}(opgroup_id_t opgroup);
int \textbf{opgroup_release}(opgroup_id_t opgroup);
int \textbf{opgroup_abandon}(opgroup_id_t opgroup);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} User-level Change Descriptor Interface}
\end{figure}

New \opgroups\ are created using \opgroupCreate. Ordering constraints
are the most fundamental type of \opgroups, but we plan to later
support other types\todo{Mention transactional?}; type specification
is the purpose of the \texttt{type} argument.
%
\opgroupAddDepend\ makes one \opgroup\ depend on another.
%
Until \opgroupRelease\ is called, \anopgroup{}'s \chdescs\ will not go
to disk.
%
\opgroupSync\ synchronizes \anopgroup, preserving its dependencies.
%
Each file system operation's \chdescs\ are added to the
\textit{engaged set} of \opgroups. \opgroupEngage\ and
\opgroupDisengage\ add and remove \anopgroup\ from this set.
%
Lastly, \opgroupAbandon\ invalidates \anopgroup\ for the calling process.

The \opgroup\ interface uses a per-process engaged \opgroup\ rather
than \anopgroup\ parameter in file system syscalls to match common
\opgroup\ usage, an application operation composed of multiple file
system operations, and to preserve existing file system syscalls.
Each process is assocated with a set of \opgroups\ to support modular
order specifiction composition.

To allow \opgroup\ interactions among processes, a \verb+fork()+ed
child is given a copy of its parent's \opgroup\ state, its
non-abandoned \opgroups\ and engaged set. This behavior also allows a
process to express ordering requirements with respect to updates a
non-\opgroup-aware child process's disk changes. For example, suppose
a user wants to run the command sequence:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+sort < src > sorted && rm src+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}
%
and ensure that the file \verb+src+is not removed before the file
\verb+sorted+ is committed to disk, so that a crash should result in
no lost data. A program \texttt{depend} can evaluate each argument as
a shell command and make each evaluation dependent on the previous
evaluation:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < src > sorted" "rm src"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}


Both \opgroups\ and \chdescs\ express storage update ordering
dependencies. However, applications and file system \modules\ differ
in bestowed trust and stable storage interface. These are the core
reasons for \opgroup{}'s and \chdesc{}'s differences.

Production file system \modules\ are trusted to not ``harm the
system;'' however, user processes could cause harm given the
opportunity to create cyclic dependencies, exhaust system resources
through non-satisfiable requirements, prevent other users' data from
going to disk, or modify other users' data. For these reasons the
\opgroup\ interface limits affected updates to those generated by the
calling process.

Just as important as not changing existing file system syscall
parameters is not adding error conditions. Existing software is not
prepared to recover from a \texttt{write()} error due to a cyclic
dependency. We also want to prevent \opgroups\ from complicating the
standard file system sycalls. For these reasons the \opgroup\
interface is designed to catch all \opgroup{}-related errors in the
\opgroup\ functions, through allowed state transitions and
\opgroupAddDepend\ cycle detection. The allowed transitions are shown
in Figure~\ref{fig:opgroup-transitions}. TODO: pick either (both?) of
the state table or graph and describe.

\begin{figure}[htb]
\centering{
\begin{tabular}{l l}
State Requirement & State Change\\ \hline
none & released\\
none & abandoned (end)\\
no dependents and released & engaged\\
engaged & disengaged\\
not released & has dependencies\\
disengaged & has dependents
\end{tabular}
% TODO: decide which approach to use (table vs diagram)
\includegraphics[width=\hsize]{opgroup_transitions}
}
\caption{\label{fig:opgroup-transitions} User-level Change Descriptor State Transitions}
\end{figure}

\begin{itemize}
\item Mention simplicity using opgroups vs fsync?
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits to make write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/transactional opgroups.)
\end{itemize}


\begin{figure}[htb]
\vspace{-10pt}
\centering{
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
int fda = open(...);
int fdb = open(...);
opgroup_id_t ida = opgroup_create(0);
opgroup_id_t idb = opgroup_create(0);

opgroup_release(ida);
opgroup_engage(ida);
write(fda, texta, texta_len);
opgroup_disengage(ida);

opgroup_add_depend(idb, ida);
opgroup_abandon(ida);
opgroup_release(idb);

opgroup_engage(idb);
write(fdb, textb, textb_len);
opgroup_disengage(idb);
opgroup_abandon(idb);
\end{verbatim}
\end{scriptsize}
\end{tabular}
}
\vspace{-10pt}
\caption{\label{fig:opgroup-example} User-level Change Descriptor Usage Example}
\end{figure}
\todo{Is a usage example helpful?}

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other dependencies be satisfied (for instance, by
being written to disk). An LFS \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the depender's tail to the dependee's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item \chdesc\ structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\centering{
\includegraphics[width=0.5\hsize]{fig/figures_7}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs. H and T are the head
and tail of the \opgroup; HK and TK are the head keep and tail keep. The three
\chdescs\ labeled 1 occurred during one file system operation, and the \chdesc\
labeled 2 occurred during a second operation that depended on the first.}
\end{figure}

\subsection{UW IMAP Case Study}
\label{sec:opgroup:uwimap}
\todo{Name this section ``IMAP Server Case Study'' or ``UW IMAP Case Study''?}

% FIXME: Should definitely mention the CHECK command. The other commands,
% select store copy etc etc, are probably less important to mention.

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's ``imapd'' mailserver to take
advantage of \opgroups\ to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, selected
mailbox, and logged out. States define the set of valid commands a
client may issue. For example, not authenticated clients may only
authenticate, authenticated clients may create or open a mailbox, and
clients in the selected state may retrieve messages from the selected
mailbox. In our case study we are interested mailbox manipulation. The
authenticated and selected states allow mailbox manipulation. The
modification commands include select (select a mailbox), store (add
flags to a message, such as flagged or deleted), copy (copy a message
from the selected mailbox to another mailbox), expunge (remove
messages marked for deletion), check (ensure all previous commands
updates are on disk), and close (check and leave the selected
mailbox). We have updated the UW IMAP~\cite{uwimap} imapd mail server
and mbox mail storage driver, authored by Mark Crispin of the IMAP RFC.
\todo{Be more explicitly about which commands sync}

The goal of the updated IMAP server is to ensure all changes occur in
a safe ordering while performing a minimal number of disk writes.  The
original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each copy into it or check. With
\opgroups, each command is given an \opgroup\ and its changes made to
depend on the previous command's. The check command uses \opgroupSync
to sync all preceding disk changes. Because the check command is now
able to ensure that preceding copies are on disk the copy command no
longer requires a file sync.

These \opgroup\ changes result in two benefits: simpler change
ordering correctness and simpler disk efficiency. As each command's
changes depend on the preceding commands' changes, code called from
the server's runloop no longer need to ensure changes for a command
are committed to disk before any following, dependent commands'
changes. The simple \opgroup\ dependency links for each command ensure
ordering correctness. In the original server, modules like the mbox
driver forced a conservative disk sync protocol, because ensuring
safety more efficiently requires additional state information, which adds
further complexity. The Dovecot IMAP server notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}

\vspace{-0.5\baselineskip}
\noindent \Opgroups\ allow for both simpler and more efficient ordering correctness.

The performance of the \opgroup{}-enabled UW IMAP imapd server is
evaluated in \S\ref{sec:evaluation:uwimap}.
