\section{User-level Change Descriptors}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{opgroup\_create()}}
\newcommand{\opgroupSync}{\texttt{opgroup\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{opgroup\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{opgroup\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{opgroup\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{opgroup\_release()}}
\newcommand{\opgroupAbandon}{\texttt{opgroup\_abandon()}}

Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW-IMAP server.

\subsection{Interface}
\label{sec:opgroup:interface}
Just as file systems use consistency protocols to ensure internal
consistency, some (but not many!) applications define consistency
protocols to balance data loss avoidance and their desired level of
performance. Here we describe the \opgroup\ interface and the basis
behind its design decisions.

Both \opgroups\ and \chdescs\ express storage update ordering
dependencies. However, applications and file system \modules\ differ
in bestowed trust and stable storage interface. These are the core
reasons for \opgroup{}'s and \chdesc{}'s differences.

Production file system \modules\ are trusted to not ``harm the
system;'' however, user processes could cause harm given the
opportunity to create cyclic dependencies, exhaust system resources
through non-satisfiable requirements, or prevent other users' data
from going to disk or modify other users' data.

In contrast to \Kudos{}'s low-level file system and block device
interfaces which manipulate file and disk blocks, user programs
manipulate stable storage data using an interface concerned with files
and file positions.
%
Related, while significant intra-file system interface changes affect
only a small group contained software, user file system interface
changes affect applications everywhere. The \opgroup\ interface allows
existing applications to implement new user consistency protocols
with no changes to existing file interface functions and even allows
updated applications to affect existing applications.

Whereas \chdescs\ are referenced explicitly when manipulating block
data inside \Kudos\, user programs implicitly reference \opgroups\
when manipulating file data and metadata. \Opgroups\ are referenced
implicitly using a per-process engaged \opgroup\ set,
%
(1) so that existing file manipulation calls, such as \verb+write()+
and \verb+unlink()+ remain unmodified, and,
%
(2) because we believe applications will find \opgroups\ most useful
at a coarser grain than \Kudos\ \modules\ do for \chdescs. For
example, a set of deletes may depend on creating the final output's
creation. In this case \Kudos\ \modules\ are concerned with each
block's dependencies. With \Kudos\ \modules\ already ensuring internal
file system consistency, user programs are only concerned that the
deletes do not occur before the output is created. This level of
granulatity also allows updated applications to affect
non-\opgroup{}-aware applications. For example,
\texttt{depend ''summarize < source > sum \&\& rm source''}. In this case
\texttt{depend} creates an opgroup for each of the commands and makes
\texttt{rm}'s \opgroup\ depend on \texttt{summarize}'s.

Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface functions.
\opgroupCreate\ returns a fresh \opgroup\ identifier. While
\opgroups\ that express ordering constraints are the most fundamental,
we plan to other types, such as transactional \opgroups; the
\texttt{flags} argument specified the \opgroup\ type.
\opgroupAddDepend\ makes the depender depend on the dependee \opgroup.
\opgroupEngage\ and \opgroupDisengage\ add/remove the \opgroup\ to/from
the set of engaged \opgroups\. \opgroupRelease\ allows an \opgroup\ to go
to disk. \opgroupSync\ sends \anopgroup\ to disk, preserving
the \opgroup{}'s ordering contraints. \opgroupAbandon\ informs \Kudos\
that this process is done referencing the \opgroup.

\begin{figure}[htb]
\centering{
\begin{tabular}{l l}
States & Transition\\ \hline
all & add dependents\\
all & release\\
all & abandon (ends)\\
no dependents & engage\\
engaged & disengage\\
not released & add dependencies
\end{tabular}
}
\caption{\label{fig:opgroup-transitions} User-level Change Descriptor State Transitions}
\end{figure}

\begin{itemize}
\item Mention simplicity using opgroups vs fsync?
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits tomake write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item We want to prevent cycles from complicating the standard fs
  calls; eg we don't want to apps to have to worry about write()
  causing a cycle and thus canceling the write (how would the app
  recover). Cycles from user data would are bad to have to worry
  about, cycles from internal-fs changes are horrible to have to
  worry about. Explain how we prevent cycles through cycle detection
  and allowed state transitions.
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/trancactional opgroups.) Give transitions for opgroups and
  atomic opgroups, or perhaps just a sampling, and the reasoning
  behind these.
\end{itemize}

\begin{figure}[htb]
\begin{scriptsize}
\texttt{opgroup\_id\_t opgroup\_create(int flags);}\\
\texttt{int opgroup\_sync(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_add\_depend(opgroup\_id\_t depender, opgroup\_id\_t dependee);}\\
\texttt{int opgroup\_engage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_disengage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_release(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_abandon(opgroup\_id\_t opgroup);}
\end{scriptsize}
\caption{\label{fig:opgroup-interface} User-level Change Descriptor Interface}
\end{figure}

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other dependencies be satisfied (for instance, by
being written to disk). An LFS \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the depender's tail to the dependee's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item \chdesc\ structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \Chdescs}
\end{figure}

\subsection{UW-IMAP Case Study}
\label{sec:opgroup:uwimap}
\begin{itemize}
\item changes
\item benefits: simplicity and efficency
\end{itemize}
