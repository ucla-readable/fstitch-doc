\section{User-level Change Descriptors}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{opgroup\_create()}}
\newcommand{\opgroupSync}{\texttt{opgroup\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{opgroup\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{opgroup\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{opgroup\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{opgroup\_release()}}
\newcommand{\opgroupAbandon}{\texttt{opgroup\_abandon()}}

Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW-IMAP server.

\subsection{Interface}
\label{sec:opgroup:interface}
Just as file systems use consistency protocols to ensure internal
consistency, some (but not many!) applications define consistency
protocols to balance data loss avoidance and their desired level of
performance. Here we describe the \opgroup\ interface and the design
decisions behind it.

Both \opgroups\ and \chdescs\ express storage update ordering
dependencies. However, applications and file system \modules\ differ
in bestowed trust and stable storage interface. These are the core
reasons for \opgroup{}'s and \chdesc{}'s differences.

Production file system \modules\ are trusted to not ``harm the
system;'' however, user processes could cause harm given the
opportunity to create cyclic dependencies, exhaust system resources
through non-satisfiable requirements, prevent other users' data from
going to disk, or modify other users' data. For these reasons the
\opgroup\ interface limits affected updates to those generated by the
calling process.

We believe applications will find \opgroups\ most useful at a coarser
grain than \Kudos\ \modules\ do for \chdescs. For example, a set of
deletes may depend on creating the final output's creation
(\texttt{summarize < source > out \&\& rm source}). \Kudos\ \modules\
are concerned with each block's dependencies. With \Kudos\ \modules\
already ensuring internal file system consistency, user programs are
only concerned that the deletes do not occur before the summary is
created.
%
Furthermore, this level of granulatity even allows updated
applications to affect non-\opgroup{}-aware applications (or updated
portions of an applications to affect other portions). For example, a
\texttt{"depend"} program that runs each argument as a shell command
can ensure the source file is not removed before the output file is on
disk: \texttt{depend "summarize < source > sum" "rm source"}.

For these reasons of trust, continued simplicity of file system
syscalls, and existing file system syscall compatibility \opgroups\
affect process file system operations implicitly, through a
per-process ``active'' (engaged) \opgroup\ set.  Applications add and
remove \opgroups\ to and from the engaged set. An \verb+unlink()+
syscall's storage changes are part of each engaged \opgroup\; the
changes depend on the \opgroup{}'s dependencies and the \opgroup{}'s
dependents depend on the syscall's changes. This contrasts with
\chdescs\ which are referenced explicitly, as parameters to LFS and BD
methods.

Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface functions.
\opgroupCreate\ returns a fresh \opgroup\ identifier. While
\opgroups\ that express ordering constraints are the most fundamental,
we plan other types, such as transactional \opgroups; the
\texttt{flags} argument specifies the \opgroup\ type.
\opgroupAddDepend\ makes the depender depend on the dependee \opgroup.
\opgroupEngage\ and \opgroupDisengage\ add/remove the \opgroup\ to/from
the set of engaged \opgroups. \opgroupRelease\ allows an \opgroup\ to go
to disk. \opgroupSync\ sends \anopgroup\ to disk, preserving
the \opgroup{}'s ordering contraints. \opgroupAbandon\ informs \Kudos\
that this process is done referencing the \opgroup.

To allow processes to express updates with respect to other processes'
updates \verb+fork()+ copies the parent's \opgroup\ table and engaged
\opgroup\ set. This allows explicit process coordination and
non-\opgroup{}-aware processes to be manipulated, as in the above
\texttt{depend} example.

\begin{figure}[htb]
\begin{scriptsize}
\texttt{typedef int opgroup\_id\_t;}\\
\texttt{opgroup\_id\_t opgroup\_create(int flags);}\\
\texttt{int opgroup\_sync(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_add\_depend(opgroup\_id\_t depender, opgroup\_id\_t dependee);}\\
\texttt{int opgroup\_engage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_disengage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_release(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_abandon(opgroup\_id\_t opgroup);}
\end{scriptsize}
\caption{\label{fig:opgroup-interface} User-level Change Descriptor Interface}
\end{figure}

Just as important as not changing existing file system syscall
parameters is not adding error conditions. Existing software is not
prepared to recover from a \texttt{write()} error due to a cyclic
dependency. We also want to prevent \opgroups\ from complicating the
standard file system sycalls. For these reasons the \opgroup\
interface is designed to catch all \opgroup{}-related errors in the
\opgroup\ functions, through allowed state transitions and
\opgroupAddDepend\ cycle detection. The allowed transitions are shown
in Figure~\ref{fig:opgroup-transitions}. TODO: pick either (both?) of
the state table or graph and describe.

\begin{figure}[htb]
\centering{
\begin{tabular}{l l}
State Requirement & State Change\\ \hline
none & released\\
none & abandoned (end)\\
no dependents and released & engaged\\
engaged & disengaged\\
not released & has dependencies\\
disengaged & has dependents
\end{tabular}
% TODO: decide which approach to use (table vs diagram)
\includegraphics[width=\columnwidth]{opgroup_transitions}
}
\caption{\label{fig:opgroup-transitions} User-level Change Descriptor State Transitions}
\end{figure}

\begin{itemize}
\item Mention simplicity using opgroups vs fsync?
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits tomake write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/trancactional opgroups.)
\end{itemize}

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other dependencies be satisfied (for instance, by
being written to disk). An LFS \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the depender's tail to the dependee's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item \chdesc\ structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \Chdescs}
\end{figure}

\subsection{UW-IMAP Case Study}
\label{sec:opgroup:uwimap}
\begin{itemize}
\item RFC-3501
\item changes
\item benefits: simplicity and efficency
\end{itemize}
