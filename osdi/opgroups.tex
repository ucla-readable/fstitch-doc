\section{User-level Change Descriptors}
\label{sec:opgroup}
Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering.  \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can implement custom consistency semantics and make
custom performance requirement tradeoffs. In this section we present
the \opgroup\ interface and implementation and a case study of
\opgroups\ in the UW-IMAP server.

\subsection{Interface}
\label{sec:opgroup:interface}
Just as file systems use consistency protocols to ensure internal
consistency, some (but not many!) applications define consistency
protocols to balance data loss avoidance and their desired level of
performance. Here we describe the \opgroup\ interface and the basis
behind its design decisions.

Both \opgroups\ and \chdescs\ express storage update ordering
dependencies. However, applications and file system \modules\ differ
in bestowed trust and stable storage interface. These are the two core
reasons for \opgroup{}'s and \chdesc{}'s differences.

Production file system \modules\ are trusted to not ``harm the
system;'' however, user processes could cause harm given the
opportunity to create cyclic dependencies, exhaust system resources
through non-satisfiable requirements, or prevent user data from going
to disk or modify other user's data.

In contrast to \Kudos{}'s low-level file system and block device
interfaces which manipulate file and disk blocks, user programs
manipulate stable storage data using an interface concerned with files
and file positions.
%
Related, while significant intra-file system interface changes affect
only a small group contained software, user file system interface
changes affect applications everywhere. The \opgroup\ interface allows
existing applications to implement new, user consistency protocols
with no changes to existing file interface functions and even allows
updated applications to effect existing applications.


Q: Why use an engaged set rather than passing an opgroup with syscalls?\\
A: Effect non-\opgroup{}-aware software. Other code in the same program
and across exec.

\begin{itemize}
\item Mention simplicity using opgroups vs fsync? Mention minimal changes?
\item File systems operate at the block level whereas user-level
  programs (generally) operate at the file and file-offset level.
  So expose a higher level of \chdescs. Also expose a
  higher level so that apps do not deal with file system
  implementation specifics; allows opgroups to better fit in with
  existing file system interactions (eg still use write(), don't
  create chdescs, create byte/bit differences, add deps). These are
  the reasons why why we chose to deal with groups of changes
  instead of individual changes. LFS's head argument similar to
  opgroups.
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits tomake write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item We want to prevent cycles from complicating the standard fs
  calls; eg we don't want to apps to have to worry about write()
  causing a cycle and thus canceling the write (how would the app
  recover). Cycles from user data would are bad to have to worry
  about, cycles from internal-fs changes are horrible to have to
  worry about. Explain how we prevent cycles through cycle detection
  and allowed state transitions.

\item Opgroups are designed to support different consistency
  requirements. ordering ``most fundamental'' (?). Also support
  atomic; more in the works.
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/trancactional opgroups.) Give transitions for opgroups and
  atomic opgroups, or perhaps just a sampling, and the reasoning
  behind these.
\end{itemize}

\begin{figure}[htb]
\begin{small}
\texttt{opgroup\_id\_t opgroup\_create(int flags);}\\
\texttt{int opgroup\_sync(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_add\_depend(opgroup\_id\_t depender, opgroup\_id\_t dependee);}\\
\texttt{int opgroup\_engage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_disengage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_release(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_abandon(opgroup\_id\_t opgroup);}
\end{small}
\caption{\label{fig:opgroup-interface} \Opgroup\ Interface}
\end{figure}

\subsection{Implementation}
\label{sec:opgroup:implementation}
\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item \chdesc\ structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \Chdescs}
\end{figure}
\subsection{UW-IMAP Case Study}
\label{sec:opgroup:uwimap}
\begin{itemize}
\item changes
\item benefits: simplicity and efficency
\end{itemize}

Simple example, ``\texttt{compute < in > out \&\& rm in}''.
