\section{Changegroups}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{changegroup\_create()}}
\newcommand{\opgroupSync}{\texttt{changegroup\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{changegroup\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{changegroup\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{changegroup\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{changegroup\_release()}}
\newcommand{\opgroupAbandon}{\texttt{changegroup\_abandon()}}

\Kudos\ \modules\ use \chdescs\ to express internal file system
consistency protocols, such as soft updates and journaling
(\S\ref{sec:consistency}).
%
Applications also implement consistency protocols, for example CVS
clients for synchronizing local files with the server and IMAP servers
for committing mailbox changes to disk. In this section we discuss the
extension of \chdescs\ from \Kudos\ to user applications to support
custom application-level consistency protocols. We discuss the
\opgroup\ interface and implementation and a case study of \opgroups\
in the UW IMAP server.

\begin{comment}
Old:
Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW IMAP server.
\end{comment}

\subsection{Interface}
\label{sec:opgroup:interface}
We believe applications will find \chdesc\ functionality most useful
for specifying orderings among file system operations.  \Anopgroup\
corresponds to the group of \chdescs\ generated by a file system
operation; applications can specify ordering requirements among these
groups. Figure~\ref{fig:opgroup-interface} shows the \opgroup\
interface functions.

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.22in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int changegroup_id_t;
changegroup_id_t \textbf{changegroup_create}(int type);
int \textbf{changegroup_sync}(changegroup_id_t cg);
int \textbf{changegroup_add_depend}(
    changegroup_id_t depender,
    changegroup_id_t dependee);
int \textbf{changegroup_engage}(changegroup_id_t cg);
int \textbf{changegroup_disengage}(changegroup_id_t cg);
int \textbf{changegroup_release}(changegroup_id_t cg);
int \textbf{changegroup_abandon}(changegroup_id_t cg);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} \Opgroup\ Interface}
\end{figure}

New \opgroups\ are created using \opgroupCreate. Ordering constraints
are the most fundamental type of \opgroups, but we plan to later
support other types\todo{Mention transactional?}; type specification
is the purpose of the \texttt{type} argument.
%
\opgroupAddDepend\ makes one \opgroup\ depend on another.
%
Until \opgroupRelease\ is called, \anopgroup{}'s \chdescs\ will not go
to disk.
%
\opgroupSync\ synchronizes \anopgroup, preserving its dependencies.
%
Each file system operation's \chdescs\ are added to the
\textit{engaged set} of \opgroups. \opgroupEngage\ and
\opgroupDisengage\ add and remove \anopgroup\ from this set.
%
Lastly, \opgroupAbandon\ invalidates \anopgroup\ handle for the
calling process.

The \opgroup\ interface uses a per-process engaged \opgroup\ rather
than \anopgroup\ parameter in file system syscalls to match common
\opgroup\ usage, an application operation composed of multiple file
system operations, and to preserve existing file system syscalls.
Each process is associated with a set of \opgroups\ to support modular
order specification composition.

To allow \opgroup\ interactions among processes, child processes copy
their parent's engaged set and \opgroup\ id table.
%
This behavior also allows a process to run a helper process within
\anopgroup. For example, suppose a user wants to run in their shell:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+sort < src > sorted && rm src+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}
%
However, the user wants to ensure that \verb+src+ is not removed
before \verb+sorted+ is committed to disk, so that a crash part way
through does not lose both files.
%
Using \opgroups, the user could make \verb+rm+'s updates depend on
\verb+sort+'s.
%
A program \texttt{depend}, that creates \anopgroup\ for each argument,
evaluates the argument as a shell command, and makes the \opgroup\
depend on the previous argument, can do just this:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < src > sorted" "rm src"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

With an application's ability to create dependencies among \opgroups,
cyclic dependencies could arise. The \opgroup\ interface ensures that
cycles can only arise in \opgroup\ operations, ensuring file system
operations can not fail due to cycles. The \opgroup\ interface limits
cycle creation opportunity through the allowed \opgroup\ state
transitions, shown in Figures~\ref{fig:opgroup-transitions-states}
and~\ref{fig:opgroup-transitions-intuition}, which ensure that
dependees can not be added when the \opgroup\ contains any \chdescs\
or has any dependers.

\begin{figure}[htb]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{opgroup_transitions}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:opgroup-transitions-states} \Opgroup\ State
  Transitions. Edges represent \opgroup\ operations, \textbf{A}dd
  depende\textbf{E}, \textbf{A}dd depende\textbf{R}, \textbf{R}elease,
  \textbf{E}ngage, and \textbf{D}isengage. Not drawn, every state
  connects to the end node via abandon.}
\end{figure}

\begin{figure}[htb]
\centering{
\begin{small}
\begin{tabular}{l l}
State Requirement & State Change\\ \hline
none & released\\
none & abandoned (end)\\
no dependers and released & engaged\\
engaged & disengaged\\
no dependers and not released & has dependees\\
disengaged & has dependers
\end{tabular}
\end{small}
}
\caption{\label{fig:opgroup-transitions-intuition} \Opgroup\ State
  Transitions --- alternative view of
  Figure~\ref{fig:opgroup-transitions-states}. A fresh \opgroup\ is
  not released, is not abandoned, is disengaged, and has no dependees
  or dependers.}
\end{figure}

\todo{Mention simplicity using opgroups vs fsync?}
\todo{Note that destruction is not an issue (unless a
  transaction) and that apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations?}

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other dependencies be satisfied (for instance, by
being written to disk). An LFS \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the depender's tail to the dependee's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{figure}[htb]
\centering{
\includegraphics[width=0.5\hsize]{fig/figures_7}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \ChDescs. H and T are the head
and tail of the \opgroup; HK and TK are the head keep and tail keep. The three
\chdescs\ labeled 1 occurred during one file system operation, and the \chdesc\
labeled 2 occurred during a second operation that depended on the first.}
\end{figure}

\subsection{UW IMAP Case Study}
\label{sec:opgroup:uwimap}

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's IMAP mailserver to take
advantage of \opgroups, to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, mailbox
selected, and logged out. States define the set of valid commands a
client may issue. For example, clients in the selected state may
retrieve messages from the selected mailbox. In our case study we are
interested mailbox manipulation; the authenticated and selected states
allow mailbox manipulation. The most relevant IMAP commands
synchronize changes to the server's disk (CHECK), copy a message from
the selected mailbox to another mailbox (COPY), and delete messages
marked for deletion (EXPUNGE).

UW IMAP~\cite{uwimap}, authored by Mark Crispin of the IMAP RFC,
includes an IMAP mailserver imapd and mail client library c-client.
We have updated imapd and the mbox mail storage driver to use
\opgroups\ to ensure all disk changes occur in a safe ordering, while
performing a minimal number of disk writes.
%
The original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\opgroups, each command's file system updates are executed under a
distinct \opgroup and, through the \opgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) can not lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \opgroupSync to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox; the client's CHECK request will ensure
changes are committed to disk; the \opgroup\ dependencies will ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify two aspects:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding commands'
changes, it is no longer required that all code be concerned with
ensuring its changes are committed before any later, dependent
commands' changes. Without \opgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \opgroup{}-enabled UW IMAP mail server is
evaluated in \S\ref{sec:evaluation:uwimap}.
