\section{User-level Change Descriptors}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{opgroup\_create()}}
\newcommand{\opgroupSync}{\texttt{opgroup\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{opgroup\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{opgroup\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{opgroup\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{opgroup\_release()}}
\newcommand{\opgroupAbandon}{\texttt{opgroup\_abandon()}}

Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW IMAP server.

\subsection{Interface}
\label{sec:opgroup:interface}
Just as file systems use consistency protocols to ensure internal
consistency, some (but not many!) applications define consistency
protocols to balance data loss avoidance and their desired level of
performance. Here we describe the \opgroup\ interface and the design
decisions behind it.

Both \opgroups\ and \chdescs\ express storage update ordering
dependencies. However, applications and file system \modules\ differ
in bestowed trust and stable storage interface. These are the core
reasons for \opgroup{}'s and \chdesc{}'s differences.

Production file system \modules\ are trusted to not ``harm the
system;'' however, user processes could cause harm given the
opportunity to create cyclic dependencies, exhaust system resources
through non-satisfiable requirements, prevent other users' data from
going to disk, or modify other users' data. For these reasons the
\opgroup\ interface limits affected updates to those generated by the
calling process.

We believe applications will find \opgroups\ most useful at a coarser
grain than \Kudos\ \modules\ do for \chdescs. For example, a set of
deletes may depend on creating the final output's creation
(\texttt{summarize < source > out \&\& rm source}). \Kudos\ \modules\
are concerned with each block's dependencies. With \Kudos\ \modules\
already ensuring internal file system consistency, user programs are
only concerned that the deletes do not occur before the summary is
created.
%
Furthermore, this level of granularity even allows updated
applications to affect non-\opgroup{}-aware applications (or updated
portions of an applications to affect other portions). For example, a
\texttt{"depend"} program that runs each argument as a shell command
can ensure the source file is not removed before the output file is on
disk: \texttt{depend "summarize < source > sum" "rm source"}.

For these reasons of trust, continued simplicity of file system
syscalls, and existing file system syscall compatibility, \opgroups\
affect process file system operations implicitly, through a
per-process ``active'' (engaged) \opgroup\ set.  Applications add and
remove \opgroups\ to and from the engaged set. An \verb+unlink()+
syscall's storage changes are part of each engaged \opgroup\; the
changes depend on the \opgroup{}'s dependencies and the \opgroup{}'s
dependents depend on the syscall's changes. This contrasts with
\chdescs\ which are referenced explicitly, as parameters to LFS and BD
methods.

Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface functions.
\opgroupCreate\ returns a fresh \opgroup\ identifier. While
\opgroups\ that express ordering constraints are the most fundamental,
we plan other types, such as transactional \opgroups; the
\texttt{flags} argument specifies the \opgroup\ type.
\opgroupAddDepend\ makes the depender depend on the dependee \opgroup.
\opgroupEngage\ and \opgroupDisengage\ add/remove the \opgroup\ to/from
the set of engaged \opgroups. \opgroupRelease\ allows an \opgroup\ to go
to disk. \opgroupSync\ sends \anopgroup\ to disk, preserving
the \opgroup{}'s ordering constraints. \opgroupAbandon\ informs \Kudos\
that this process is done referencing the \opgroup.

To allow processes to express updates with respect to other processes'
updates, \verb+fork()+ copies the parent's \opgroup\ table and engaged
\opgroup\ set to the child process. This allows explicit process coordination
and non-\opgroup{}-aware processes to be manipulated, as in the above
\texttt{depend} example.

\begin{figure}[htb]
\begin{scriptsize}
\texttt{typedef int opgroup\_id\_t;}\\
\texttt{opgroup\_id\_t opgroup\_create(int flags);}\\
\texttt{int opgroup\_sync(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_add\_depend(opgroup\_id\_t depender, opgroup\_id\_t dependee);}\\
\texttt{int opgroup\_engage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_disengage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_release(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_abandon(opgroup\_id\_t opgroup);}
\end{scriptsize}
\caption{\label{fig:opgroup-interface} User-level Change Descriptor Interface}
\end{figure}

Just as important as not changing existing file system syscall
parameters is not adding error conditions. Existing software is not
prepared to recover from a \texttt{write()} error due to a cyclic
dependency. We also want to prevent \opgroups\ from complicating the
standard file system sycalls. For these reasons the \opgroup\
interface is designed to catch all \opgroup{}-related errors in the
\opgroup\ functions, through allowed state transitions and
\opgroupAddDepend\ cycle detection. The allowed transitions are shown
in Figure~\ref{fig:opgroup-transitions}. TODO: pick either (both?) of
the state table or graph and describe.

\begin{figure}[htb]
\centering{
\begin{tabular}{l l}
State Requirement & State Change\\ \hline
none & released\\
none & abandoned (end)\\
no dependents and released & engaged\\
engaged & disengaged\\
not released & has dependencies\\
disengaged & has dependents
\end{tabular}
% TODO: decide which approach to use (table vs diagram)
\includegraphics[width=\hsize]{opgroup_transitions}
}
\caption{\label{fig:opgroup-transitions} User-level Change Descriptor State Transitions}
\end{figure}

\begin{itemize}
\item Mention simplicity using opgroups vs fsync?
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits to make write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/transactional opgroups.)
\end{itemize}

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other dependencies be satisfied (for instance, by
being written to disk). An LFS \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the depender's tail to the dependee's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item \chdesc\ structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs}
\end{figure}

\subsection{UW IMAP Case Study}
\label{sec:opgroup:uwimap}
\todo{Name this section ``IMAP Server Case Study'' or ``UW IMAP Case Study''?}

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's ``imapd'' mailserver to take
advantage of \opgroups\ to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, selected
mailbox, and logged out. States define the set of valid commands a
client may issue. For example, not authenticated clients may only
authenticate, authenticated clients may create or open a mailbox, and
clients in the selected state may retrieve messages from the selected
mailbox. In our case study we are interested mailbox manipulation. The
authenticated and selected states allow mailbox manipulation. The
modification commands include select (select a mailbox), store (add
flags to a message, such as flagged or deleted), copy (copy a message
from the selected mailbox to another mailbox), expunge (remove
messages marked for deletion), check (ensure all previous commands
updates are on disk), and close (check and leave the selected
mailbox). We have updated the UW IMAP~\cite{uwimap} imapd mail server
and mbox mail storage driver, authored by Mark Crispin of the IMAP RFC.
\todo{Be more explicitly about which commands sync}

The goal of the updated IMAP server is to ensure all changes occur in
a safe ordering while performing a minimal number of disk writes.  The
original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each copy into it or check. With
\opgroups, each command is given an \opgroup\ and its changes made to
depend on the previous command's. The check command uses \opgroupSync
to sync all preceding disk changes. Because the check command is now
able to ensure that preceding copies are on disk the copy command no
longer requires a file sync.

These \opgroup\ changes result in two benefits: simpler change
ordering correctness and simpler disk efficiency. As each command's
changes depend on the preceding commands' changes, code called from
the server's runloop no longer need to ensure changes for a command
are committed to disk before any following, dependent commands'
changes. The simple \opgroup\ dependency links for each command ensure
ordering correctness. In the original server, modules like the mbox
driver forced a conservative disk sync protocol, because ensuring
safety more efficiently requires additional state information, which adds
further complexity. The Dovecot IMAP server notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}

\vspace{-0.5\baselineskip}
\noindent \Opgroups\ allow for both simpler and more efficient ordering correctness.

The performance of the \opgroup{}-enabled UW IMAP imapd server is
evaluated in \S\ref{sec:evaluation:uwimap}.
