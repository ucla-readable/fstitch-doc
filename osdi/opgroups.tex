\section{User-level Change Descriptors}
\label{sec:opgroup}

% FIXME: use \opgroup, \chdesc, \module, etc.

Many file systems strive to maintain internal file system consistency
across system and hardware failures; change descriptors can express
such write ordering requirements. But file systems are by no means the
sole players to benefit from robustness to system and hardware
failures. User applications often manipulate persistent data in
manners subject to data corruption or loss. Applications often protect
user data using interfaces like Unix's \texttt{sync()} and
\texttt{fsync()} system calls in combination with write ordering.
User-level change descriptors provide finer grained and less
restrictive write ordering control so that applications can implement
custom consistency semantics and make custom performance requirement
tradeoffs. In this section we present the user-level change descriptor
interface and implementation and a case study of user-level change
descriptors in the UW-IMAP server.

Add?: It is desirable for the interface to fit in with existing calls
naturally (eg write()) and the file system must be able to ensure
userspace can not ``harm the system'' (eg non-satisfiable
requirements).

\subsection{Interface}

Just as file systems use consistency protocols to ensure internal
consistency some (but not many!) applications define consistency
protocols to balance data loss avoidance and their desired level of
performance. Here we describe the user-level change descriptor
interface and the basis behind its design decisions.

Both user-level and KFS change descriptors express storage update
ordering dependencies. However, applications and file system modules
differ in bestowed trust and stable storage interface. These are the
two core reasons for user-level's and KFS's change descriptor
differences.

Production file system modules are trusted to not ``harm the system;''
however, user processes could harm the system given the chance to
specify illegal pointer values, create cyclic dependencies, exhaust
system resources, or prevent user data from going to disk.

\begin{itemize}
\item trust: apps untrusted; kernel modules are (cycles, bad pointers, resource usage, manipulate other process' data/prevent going to disk)
\item update interface: VFS vs LFS/BD (and file system internals)
\item simplicity? granularity?
\end{itemize}

\begin{itemize}
\item Explain how we think applications might make use of opgroups
\item We want to prevent apps from being able to screw the system up
  (grab huge amounts of memory that can't be released, stop other
  processes' data from going to disk, etc)
\item Explain the ``core differences'' between chdescs and
  opgroups
\item File systems operate at the block level whereas user-level
  programs (generally) operate at the file and file-offset level.
  So expose a higher level of change descritors. Also expose a
  higher level so that apps do not deal with file system
  implementation specifics; allows opgroups to better fit in with
  existing file system interactions (eg still use write(), don't
  create chdescs, create byte/bit differences, add deps). These are
  the reasons why why we chose to deal with groups of changes
  instead of individual changes. LFS's head argument similar to
  opgroups.
\item Opgroups are simpler than chdescs. Retaining not possible (app
  waits tomake write) and destruction not an issue (unless a
  transaction). Apply/rollback and dependency removal aren't seen as
  helpful since apps are not doing transformations, just specifying
  ordering requirements. (We should improve this reasoning.)
\item We want to prevent cycles from complicating the standard fs
  calls; eg we don't want to apps to have to worry about write()
  causing a cycle and thus canceling the write (how would the app
  recover). Cycles from user data would are bad to have to worry
  about, cycles from internal-fs changes are horrible to have to
  worry about. Explain how we prevent cycles through cycle detection
  and allowed state transitions.

\item Opgroups are designed to support different consistency
  requirements. ordering ``most fundamental'' (?). Also support
  atomic; more in the works.
\item Explain why create and engage are distinct. Why disengage,
  release, and abandon are distinct. (Cycle prevention and for
  atomic/trancactional opgroups.) Give transitions for opgroups and
  atomic opgroups, or perhaps just a sampling, and the reasoning
  behind these.
\end{itemize}

\begin{figure}[htb]
\begin{small}
\texttt{opgroup\_id\_t opgroup\_create(int flags);}\\
\texttt{int opgroup\_sync(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_add\_depend(opgroup\_id\_t depender, opgroup\_id\_t dependee);}\\
\texttt{int opgroup\_engage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_disengage(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_release(opgroup\_id\_t opgroup);}\\
\texttt{int opgroup\_abandon(opgroup\_id\_t opgroup);}
\end{small}
\caption{\label{fig:opgroup-interface} Opgroup Interface}
\end{figure}

\subsection{Implementation}
\begin{itemize}
\item cycle detection
\item chdesc implementation
  \begin{itemize}
  \item chdesc structure; Figure~\ref{fig:opgroup-chdescs}
  \item opgroup\_lfs for head chdesc
  \end{itemize}
\item scopes and opgroups across forks (multithreaded todos?)
\end{itemize}

\begin{figure}[htb]
\caption{\label{fig:opgroup-chdescs} Opgroup Change Descriptors}
\end{figure}
\subsection{UW-IMAP Case Study}
\begin{itemize}
\item changes
\item benefits: simplicity and efficency
\end{itemize}

Simple example, ``\texttt{compute < in > out \&\& rm in}''.
