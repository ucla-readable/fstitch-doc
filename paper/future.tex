\section{Future Work}
\label{sec:future}

\subsection{Increased Efficiency}

We would like to increase both the internal efficiency of the file
server and the efficiency of programs that use the file server.

One efficiency problem we have right now is slow speed. This is likely
due to many factors including: context switches because of IPC,
redundancy in our module implementations, the lack of DMA disk access,
and the long round trip times involved in accessing a network block
device. We have considered ways to speed all of these up

To speed up IPC, we could send messages over a pipe or batch requests.

The problem of redundancy has in our modules has been fixed to a
certain degree. For example, the old implementation of
truncate_block() would have to call read_block() to return a block
descriptor. This meant that deleting a file would have to read the
entire file. Fixing this massively improved the performance of
deleting files. There are probably more opportunities for optimization
in this area.

Adding DMA disk access would probably speed all disk accesses.

We've noticed that a typical read command takes much longer than a
write command to a network block device. This is likely due to the
long round trip time of the network. To help speed this up, we have
considered batching reads to do automatic pre-fetching.

Journaling is also a performance problem for us. Right now, when a
journal is being written out, the file server is blocking and thus
hangs when requests come in. We would like to interleave requests with
writing of the journal.

Also, user programs may be able to be more efficient if we supported
memory mapped files.

\subsection{Increased Flexibility}

One goal of a modular system is to give the module user complete
freedom to arrange modules in any way she pleases. We have taken great
care to allow almost complete freedom with the system, except in some
clear well defined places. For example, mixing of interfaces is not
allowed; one cannot connect a block device directly to a table
classifier. For example, we currently disallow stacking write back
caches. This is explained at the end of
section~\ref{sec:solution:impl:wbcache}. It seems that stacking caches
might be desirable, though. For example, a user may prefer to have a
small write back cache very high in the BD layer (similar to an L1
cache), and another larger one very low in the layer, just before the
disk (similar to an L2 cache). This could give optimal performance,
but currently this is disallowed.

Perhaps the problem is not in the write back cache, but in our model
of change descriptors. Perhaps we should have change descriptors keep
track of their distance from stable storage, or their distance from
the place they were generated.

\subsection{More Features}
journal size limitations, metadata only journalling
