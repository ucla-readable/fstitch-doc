\subsection{Architecture}
\label{subsec:arch}

The KudOS file server is composed of many modules, each of which may use the
services of other modules and provides a service of its own for other modules.
There are three interface types between modules, called BD (block device), LFS
(low level file system), and CFS (common file system).

In addition to the modules, there are also a few server-wide components that are
not modules. They provide management functions for the modules themselves and
the data structures that are used to store disk blocks and other filesystem
data, like change dependency information and client file IDs.

\subsubsection{Interface Layers}

The modules that make up the filesystem server are generally divided into four
major layers in the simple case. At the lowest layer, there are modules that
provide a BD interface. They can be disks, partitions on other block devices,
caches, network block devices, RAM disks, and so on. The BD interface contains
functions for reading and writing blocks, as well as querying the block size and
number of blocks. Although the interface is simple, there is hidden complexity
in some types of block device modules when dealing with change descriptors (to
be explained later).

The next layer starts with modules that uses a BD module, and provide LFS
interfaces. It includes any other modules which are LFS-LFS modules, that is,
modules which use an LFS interface and provide another LFS interface. The LFS
interface provides extremely low-level filesystem operations, sort of like the
``assembly language'' of filesystem operations. There are functions to allocate
and free disk blocks and file names, to append and remove disk blocks from file
names, and to query for metadata associated with files in an extensible way. It
is possible, using the LFS interface, to effect changes to the underlying
filesystem that are not ordinarilly allowed - for instance, assigning the same
disk block to multiple files.

The third layer starts with modules that use an LFS module, and provide CFS
interfaces. It includes any other modules which are CFS-CFS modules, as well as
the IPC mechanism which allows client environments to access the top-level CFS
modules in the file server. The CFS interface is similar to the ``VFS''
interface found in many Unix systems, but a little bit lower-level: instead of
providing a specific set of supported metadata, it provides an extensible
mechanism for using file metadata. In comparison to LFS, which provides only
block-level operations for the filesystem, and which can be used incorrectly
with undesired results, CFS provides safe byte-level operations on files.

The last layer is in the client environment, and provides whatever native
interface the user code expects. In KudOS, which is originally based on a simple
exokernel system called JOS, the original file server provides an interface
which we emulate in the ``KudOS Presentation Layer'' or KPL. The KPL provides
high-level functionality like the stat() call by using the lower-level CFS
metadata query functions, and is nominally 100\% reverse-compatible with the old
file server.

\subsubsection{Structures}

There are three major data structures in the KudOS file server. They are block
descriptors (bdesc), data descriptors (ddesc), and change descriptors (chdesc).
Block descriptors represent a disk block. They store a pointer to the block
device they came from, the block number, a pointer to the block data, and a
reference count. Data descriptors represent the actual data in a disk block,
independent of any particular bdesc. This allows the data to be shared between
several bdescs, which is an optimization to avoid unnecessary copying in many
situations. Finally, change descriptors represent changes to disk data, and
store the old and new data, which block they changed, and lists of other chdescs
which depend upon them or which they depend on.

\subsubsection{Dependency Management}

when a chdesc is created, it's registered w/ depman. he tracks the
life of it until it has been written to disk (actually satisfied). as
it is written through many layers, it is automatically forwarded
among the proper bdescs to reach the lowest level (this usually
happens automatically).

\subsubsection{Online Configuration}

what we want to do: add/remove modules are runtime. for example, the
mount command in unix. so we need to keep track of all modules in the
system and know how they are connected together.

modman stores this info for people and fields requests for updates
(he's the manager).

\subsubsection{Client Tracking}

we want fids to be unique across all modules and time. even after it
has been closed it should not be reused for some time (to avoid bugs),
and each file currently open needs a unique fid. even in very
different modules.

fidman creates fids and you tell it when a fid is no longer in use.

fidfairies pass on the close message when everyone is done with a
fid. handles a client fork()ing or dieing w/o calling close(), and
enforces a certain amount of protection for files that claim to have
files open, but haven't called open.
