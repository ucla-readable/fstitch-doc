\section{Related Work}
\label{sec:related}

\subsection{Linux JFS and ext3}

In Linux, journalling in the ext3 filesystem is implemented as two distinct
modules that cooperate: JFS and ext3. The JFS module does not know anything
about filesystems, and the ext3 module does not know anything about journalling.
What the JFS module does is to provide transaction support for block devices.
That is, it provides the facility to tell the block device what writes will be
part of what transaction, and when transactions are to be committed, and it
makes sure that either the whole transaction is committed, or none of it. It
does this by keeping a journal, but this is not part of the interface
specification.

The ext3 module uses transactions to accomplish its safety properties. It groups
changes to the filesystem into transactions that guarantee the disk will always
be in a consistent state, and lets the JFS module do the hard work. It keeps a
flag in the filesystem superblock that indicates whether it has been cleanly
unmounted, and upon mounting a dirty filesystem, it signals the JFS module to do
any necessary recovery before it proceeds. In this way, the complexity of
journalling is broken into two separate pieces.

Full journalling is actually not very difficult to implement. It is what we have
implemented in the KudOS file server. In full journalling, everything that will
be written to the disk is written to the journal first, as part of some
transaction. Obviously this is much less efficient than we'd like, which is why
there is another technique for doing journalling: metadata-only journalling. In
metadata-only journalling, only changes to the filesystem metadata (like
directory structure, file names, sizes, and link counts) are grouped into
transactions and written to the journal. File data changes are written directly,
since they do not contribute to the validity of the filesystem and do not need
to be made ``safe'' in order to avoid needing fsck. Although it seems simple
initially, metadata-only journalling introduces a large number of special cases
involving resource reuse which greatly increase its complexity and the necessary
implementation time.

\subsection{BSD Soft Updates}

we made softupdates, we did it at a lower level w/ chdescs refering to
data, not with references to higher level primatives. we are the
taking the idea of rolling back block changes. theirs is more closely
tied to FFS and help the rest of the system make certain decisions,
that we would have a tough time discovering.

we are more general -- journaling is part of our system.

\subsection{Stackable File Systems}

we can do similar things at either the cfs or lfs layer. we allow a
lot more flexibility and we have a larger scope than just stacking
stuff.

\subsection{BSD GEOM}

they did the hot-swap that we can do w/ modules. we can't hot-swap
modules w/ state. problem for cfs moduels and some lfs ones. even bd
modules have some state (point to other bd modules). we have what we
think is important (raid thingy).

\subsection{Flux OSkit}

we replaced parts. but smaller, more manageable than they provided. we
did some things lke they did -- wrapped up the original josfs like
flux wrapped up drivers.

they weren't looking to replace or break up the basefs.
