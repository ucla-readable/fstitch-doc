\section{Other Groups}
\label{sec:groups}

\subsection{Influential Ideas}

One group which influenced our design was one of the other component groups, P.
Their first attempt at a configuration file format looked a lot like Yacc, in
that it contained a fair amount of actual source code which would be literally
included as parts of the output file, which would then need to be compiled.

Even without including actual source code in the configuration file, the scheme
they were using for this first attempt required compiling the output after
processing the configuration. This was one of our original thoughts for creating
our initialization function that sets up the file server configuration, but
the limitations were highlighted by the attempt P made with their language.

As a result, we went with a different approach: we expose the module
constructors in the file server to client environments directly, which moves the
responsibility for configuring the file server to clients. Then, we have a set
of clients which construct various sets of modules in the server, and these
clients can be used with various command line arguments to tune how they affect
the running file server's configuration. We call these special clients ``mount''
and ``umount'' because of the similarity of their similarity to the Unix tools
of the same names. Although we have not done it yet, these commands could be
invoked with bootloader or kernel-specified commands to set up an initial
filesystem, and from there a simple configuration file like /etc/fstab in unix
could be used to finish the configuration.

\subsection{Criticisms}

The DoSers group was attempting to make a system that would be ``DDoS free'' in
that it would detect dynamic denial of service attacks and prevent them from
completely disabling the machine. Admittedly this is a difficult task, and they
decided to assume a non-malicious root user (which is probably required in
general anyway), but what they ended up doing was to pick three common kinds of
attacks and create special-purpose mechanisms to prevent them. These mechanisms
were very effective, and certainly the results were preferable to what would
have happened without their changes. On the other hand, they didn't solve the
whole problem - they only solved a portion of it by implementing hand-crafted
workarounds for the three attacks they decided to address. It would have been
much more impressive to have seen a generalized system for preventing any kind
of attack in a broad range of attack types, or a framework for easily creating
new attack prevention code by providing small hooks for (or some sort of hint
to) a resource-insensitive tracking module that would actually do most of the
difficult work.
