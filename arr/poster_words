Goals:
- modularize file system components
- create a more flexible file system architecture

Motivations:
- file systems are being expected to do more (encrypt, extensible metadata, and more)
- correctness increasingly becoming a research focus (stackable must impose using fsync or break deps)
- robust apps either accept perf penalty of fsync or rely on raw-disk interfaces

Benefits:
- easier to write crash-recoverable applications
- disk images are as safe to use as disks
- smaller file system pieces easier to understand, get correct
- new functionality through new modules or combinations of existing modules
- ?


Change Descriptor
- represents an in-memory change to the disk
- deps between change descriptors enforce write orderings
- for example, we must mark a disk block as allocated before using it
  (figure? use->alloc)
  (figure? ~20 chdesc figure)

Modules
- existing file systems have standard interfaces for file systems and block devices
- an intermediate interface provides the opportunity for finer grained modules
- modules with different "in" and "out" interfaces creates interesting configurations (insert loopback picture here)

Changegroup
