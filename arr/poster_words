Goals:
- modularize file system components
- create a more flexible file system architecture

Motivations:
- file systems are being expected to do more (encrypt, extensible metadata, and more)
- correctness increasingly becoming a research focus (stackable must impose using fsync or break deps)
- robust apps either accept perf penalty of fsync or rely on raw-disk interfaces

Benefits:
- easier to write crash-recoverable applications
- disk images are as safe to use as disks
- smaller file system pieces easier to understand, get correct
- new functionality through new modules or combinations of existing modules
- ?


Change Descriptor
- represents an in-memory change to the disk
- deps between change descriptors enforce write orderings
- for example, we must mark a disk block as allocated before using it
  (figure? use->alloc)
  (figure? ~20 chdesc figure)

Modules
- existing file systems have standard interfaces for file systems and block devices
- an intermediate interface provides the opportunity for finer grained modules
- modules with different "in" and "out" interfaces creates interesting configurations (insert loopback picture here)

- example modules
  - UFS
  - WB Cache
  - more?

Changegroups
- "change descriptors for applications"
- a changegroup corresponds to a group of change descriptors generated by file system operations; applications can specify ordering requirements among these groups
- operations:
  create a changegroup
  sync a changegroup to disk
  add one changegroup as a dependency to another
  start/stop using a changegroup for file system operations
- implementation (figure) ?

- UW IMAP case study
  - each imap command performed within a changegroup, dependent on preceeding changegroup. a result: COPY longer needs to fsync() to ensure ordering correctness.
  - benefits: correctness is easier, fewer syncs for correctness
