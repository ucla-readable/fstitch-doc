% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section {Introduction}
\label{sec:intro}


Ongoing massive growth in both disk capacities and user and application
 storage requirements, combined with the increasing
 disparity between disk and processor speeds, has led to ongoing
 innovation in file system design.
%
File systems are expected to do more things: they can automatically encrypt
 stored data~\cite{wright03ncryptfs}, support extensible metadata, such as
 content indexes~\cite{gifford91semantic}, automatically
 version~\cite{soules03metadata,fast04versionfs,quinlan02venti,cornell04wayback},
 and even detect viruses~\cite{miretskiy04avfs}.
%
Improved disk interfaces can make use of file system usage patterns to
 improve
 performance~\cite{sivathanu03semantically-smart,sivathanu05database-aware}.


As file system functionality increases, file system \emph{correctness} is
 also increasingly a focus of
 research~\cite{sivathanuetal05-logic,denehyetal05-journal-guided}.
%
File system extensions and disk-layer interventions risk violating
 the dependency relationships between written blocks on which file system
 correctness relies~\cite{ganger00soft}.
%
Stackable file
 systems~\cite{zadok00fist,zadok99extending,heidemann94filesystem,rosenthal90evolving}
 avoid some of these issues by placing extensions over an existing
 file system, which is responsible for maintaining consistency.
%
Unfortunately, not all extensions are easily implemented entirely above an
 unmodified file system.
%
Furthermore, a stackable file system may implement a single system call
 with multiple operations; for instance, imagine creating a file whose
 additional metadata information is stored in another file with a related
 name.
%
Since current VFS (virtual file system) implementations can't
 express dependencies among operations, the stackable
 file system must must either impose an ordering using \texttt{fsync},
 which is expensive, or accept and account for the possibility of
 inconsistency.
%
This problem exists for applications as well.
%
The expensive \texttt{fsync} and \texttt{sync} system calls are the only
 tools available for enforcing file consistency.
%
Robust applications, including databases, mail servers, and source code
 management tools, either accept the performance penalty of these system
 calls or rely on specialized raw-disk interfaces.


Proposed systems for improving file system integrity and consistency differ
 mainly in the kind of consistency they aim to impose, ranging from
 metadata consistency to full data journaling~\cite{tweedie98journaling}
 \todo{Is this really the best reference for this?} and even full ACID
 transactions~\cite{gal05transactional,liskov04transactional}.
%
However, different extensions within a file system, or different
 applications over the file system, may require different types of
 consistency semantics, and performance suffers when lower layers are
 unnecessarily denied the opportunity to reorder
 writes~\cite{ganger00soft}.
%
A better choice might be an abstraction that could express many consistency
 models.


This work develops a new fundamental data type called a \emph{\chdesc},
 which represents both a change to disk data and any \emph{dependencies}
 between that change and other changes. 
%
\Chdescs\ were inspired by the dependency abstraction from BSD's
 soft updates~\cite{ganger00soft}, but whereas the soft updates implementation
 is specific to the Unix File System, \chdescs\ are fully general.
%
We also develop a variety of dynamic optimizations to \chdescs, which
 significantly reduce the memory and CPU overhead associated with using them.
%
We present a formal theory of \chdescs, which we use to state their
 behavior and the safety properties they provide, and to reason about our
 dynamic optimizations to show that they will work correctly.
%
Finally, we demonstrate a prototype file system implementation using
 \chdescs\ called \Kudos.
%
\Chdescs\ allow us to decompose the entire file system layer, from system
 calls to block devices, into pluggable \modules, hopefully making the
 system as a whole more configurable, extensible, and easier to understand.
%
Any file system can generate \chdescs, and those \chdescs\ are obeyed
 by all other file system layers.
%
\Chdescs\ may be examined and modified by other modules as well, and
 even passed through layers such as loop-back block devices.
%
As a result, the loosely-coupled \modules\ that make up a file system
 implementation can cooperate to implement strong and often complex
 consistency guarantees, even though each individual \module\ does a
 relatively small part of the work.


\Chdescs\ can implement many consistency mechanisms, including
 soft updates and journaling.
%
Our file system modules impose soft updates-style \chdesc\
 requirements by default.
%
A single module placed downstream of any file system can analyze these
 \chdesc\ layouts and transform them into dependencies that
 implement a journal.
%
Additionally, we give user-level applications controlled access to \chdescs,
allowing applications to impose their own limited consistency
 policies.
%
Modifying an IMAP mail server to use this interface requires only localized
 changes; the resulting server follows IMAP's consistency
 requirements while writing fewer blocks to disk.
%
Although our prototype implementation is not yet as fast as we would like,
 and \chdescs\ do not yet support all consistency policies (for instance,
 not ACID transactions: transactions should be independent, but any file
 system client can observe all active \chdescs), we believe that using
 \chdescs\ will allow the construction of consistent, modular, extensible
 file systems that are much easier to understand.


Our contributions include the generalized \chdesc\ design, the
 optimizations we have developed for dealing with \chdescs, the formal
 model of \chdescs, the \module\ interfaces in our \Kudos\ prototype,
 several of the individual \Kudos\ \modules\ like the journal, and the
 \opgroup\ interface that exports \chdescs\ to userspace.


%% They can also be extended, in a carefully controlled way, into userspace --
%% enabling applications with custom consistency and performance requirements to
%% specify explicit write ordering restrictions to be honored by the file system.
%% We will show that this can give such applications several benefits over existing
%% interfaces like \texttt{fsync()} which provide only coarse control over
%% consistency, or which either impose high overhead (data journaling) or don't
%% guarantee data consistency (soft updates, for example, ensures metadata
%% consistency only).
