% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section {Introduction}
\label{sec:intro}

\begin{comment}
This paper aims to evaluate whether a simple, unified abstraction that
represents all modifications to stable storage, including
\emph{dependencies} among modifications, can be used to efficiently
implement a complete file system layer, where modifications are common
and cache sizes are large.
%
The answer is a qualified yes.
\end{comment}


As file system functionality increases, maintaining file system
 correctness in the presence of failures is increasingly a focus of
 research~\cite{sivathanuetal05-logic,denehyetal05-journal-guided}.
%
File systems today deal with many challenges that make implementing this
 property difficult: power losses, software failures, and even user
 intervention all pose significant threats.
%
To meet this challenge, file systems use a variety of techniques, like
 journaling and soft updates.
%
These mechanisms are each based on imposing some ``write before''
 relationship among buffered changes to the data in stable storage.
%
This paper aims to evaluate whether a simple, unified abstraction that
 represents this relationship can be used to efficiently implement a
 complete file system layer, where modifications are common and cache
 sizes are large.
%
The answer is a qualified yes.


We present a new fundamental data type called a \emph{\patch},
 which represents both a change to disk data and any \emph{dependencies}
 between that change and other changes. 
%
\Patches\ were inspired by the dependency abstraction from BSD's soft
 updates~\cite{ganger00soft}, but whereas the soft updates implementation
 involves many structures specific to the UFS file
 system~\cite{mckusick99soft}, \patches\ are fully general,
 specifying only how a range of bytes should be changed.
%
This lets file system implementations specify \emph{what} the desired
 write before relationship is between the changes without dictating
% (or worrying about)
 \emph{how} to write blocks to stable storage to implement that policy.
%
It also lets other storage system components examine and
 modify dependency structures independent of the file system's layout.
%
Additionally, we present a user-level interface called \patchgroups,
 which provides applications with controlled access to \patches---allowing
 them to impose their own limited consistency policies for the storage
 system to follow.


While it is already difficult for file system implementers to provide
 consistency guarantees~\cite{tweedie98journaling,mckusick99soft},
 the situation is further complicated by file system extensions and
 special disk interfaces~\cite{soules03metadata,fast04versionfs,quinlan02venti,cornell04wayback,wright03ncryptfs,sivathanu03semantically-smart,sivathanu05database-aware}.
%
Stackable file systems~\cite{zadok00fist,zadok99extending,heidemann94filesystem,rosenthal90evolving},
 for instance, may place extensions over an existing file system
 responsible for maintaining consistency.
%
However, some extensions, like creating a file containing metadata
 information about a directory, can introduce ordering requirements
 difficult to express at the VFS layer.
%
\Patches\ provide a simple and effective way for such extensions to
 express their requirements of the storage system, adding to the
 requirements already expressed by the file system itself.


This problem exists for applications as well, where even fewer mechanisms
 for controlling buffer cache behavior are available.
%
Robust applications, including databases, mail servers, and source code
 management tools, must choose between several mediocre options.
%
They can accept the performance penalty of expensive system calls like
 \texttt{fsync} and \texttt{sync}, use tedious and fragile sequences
 of operations that count on particular file system semantics, or
 rely on specialized raw-disk interfaces.
%
\Patchgroups\ allow applications the same benefit that \patches\ provide
 for kernel-level file system implementations and extensions.
%
Modifying an IMAP mail server to use \patchgroups\ required only localized
 changes; the resulting server follows IMAP's consistency requirements,
 is as fast or faster, and makes many fewer disk write requests.


Other proposed systems for improving file system integrity and consistency
 differ mainly in the kind of consistency they aim to impose, ranging from
 metadata consistency to full data journaling and even full ACID
 transactions~\cite{gal05transactional,liskov04transactional}.
%
However, different extensions within a file system, or different
 applications over the file system, may require different types of
 consistency semantics, and performance suffers when lower layers are
 unnecessarily denied the opportunity to reorder writes.
%
Some Google applications, for instance, get better locality by avoiding the
 use of a journal, and can tolerate the additional time spent doing (rare)
 consistency checks~\cite{googleext2}.
%
\Patches\ can implement many consistency mechanisms, including
 soft updates and journaling, and can allow combinations of different
 consistency protocols to exist at the same time.
%
Our file system modules impose soft updates-style \patch\ requirements by
 default, since doing so requires some knowledge of the file system's
 structures; we have also written a journal module that can change
 existing dependencies to express either full or metadata-only journaling.
%
A file system module not interested in supporting soft updates support
 could instead impose no \patch\ requirements, and count on the journal
 module to provide a consistency guarantee.


\begin{comment}
The \Kudos\ storage system implementation is decomposed entirely into
 pluggable \modules\ that manipulate \patches, hopefully making the system
 as a whole more configurable, extensible, and easier to understand.
%
Any storage system \module\ can generate \patches; other modules can examine
 them and modify them when required.
%
\Patch\ dependencies are obeyed by all other storage system layers, allowing
 them to be passed through layers such as loopback block devices.
%
As a result, the loosely-coupled \modules\ that implement a file system
 can cooperate to enforce strong and often complex consistency guarantees,
 even though each \module\ only does a small part of the work.
\end{comment}


This generality comes at a cost, but that cost can be partially mitigated.
%
Production file system implementations achieve consistency and write before
 relationships without sacrificing performance by using a variety of file
 system specific optimizations.
%
We found that a naive implementation using \patches\ scaled terribly,
 spending far more space and time on dependency manipulation than
 conventional systems.
%
We therefore developed a variety of dynamic optimizations that
 significantly reduce the memory and CPU overhead associated with \patches.


Our contributions include the generalized \patch\ design, the
 optimizations we have developed for making \patches\ more efficient,
 the formal model of \patches, the \patchgroup\ mechanism that exports
 \patches\ to user space, and several of the individual modules we
 have developed, like the journal.


We describe \patches\ abstractly, state their behavior and safety
 properties, give examples of their use, and reason about the
 correctness of our optimizations.
%
Finally, we demonstrate a prototype file system implementation using
 \patches\ called \Kudos.
%
\Kudos\ is decomposed entirely into pluggable modules that manipulate
 \patches, hopefully making the system as a whole more configurable,
 extensible, and easier to understand.
%
Our benchmarks show that our optimizations can reduce the number of
 \patches\ \Kudos\ creates by \patchoptcount\ and the amount of undo data
 memory it allocates by \patchoptundo.
%
Our prototype is not yet as fast as we would like, but it is competitive
 with Linux on many of our benchmarks.
