% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section {Introduction}
\label{sec:intro}


This paper aims to evaluate whether a simple, unified abstraction that
represents all modifications to stable storage, including
\emph{dependencies} among modifications, could support an entire file
system, where modifications are common and cache sizes are large.
%
The answer is a qualified yes.


\begin{comment}
Ongoing massive growth in both disk capacities and user and application
storage requirements, combined with the increasing
disparity between disk and processor speeds, has led to ongoing
innovation in file system design.
%
File systems are expected to do more things: they can automatically encrypt
stored data~\cite{wright03ncryptfs}, support extensible metadata, such as
content indexes~\cite{gifford91semantic}, automatically
version~\cite{soules03metadata,fast04versionfs,quinlan02venti,cornell04wayback},
and even detect viruses~\cite{miretskiy04avfs}.
%
Improved disk interfaces can make use of file system usage patterns to
improve
performance~\cite{sivathanu03semantically-smart,sivathanu05database-aware}.
\end{comment}


As file system functionality increases, file system correctness is
 increasingly a focus of
 research~\cite{sivathanuetal05-logic,denehyetal05-journal-guided}.
%
File systems must maintain dependency relationships between written blocks
 to preserve file system correctness.
%
This is difficult enough for file system
 implementers~\cite{tweedie98journaling,mckusick99soft}, but further
 complicated by file system extensions and special disk interfaces~\cite{soules03metadata,fast04versionfs,quinlan02venti,cornell04wayback,wright03ncryptfs,sivathanu03semantically-smart,sivathanu05database-aware}.
%
Although stackable file
 systems~\cite{zadok00fist,zadok99extending,heidemann94filesystem,rosenthal90evolving}
 %% can aid in preserving consistency by 
 place extensions over an existing file system responsible for maintaining
 consistency, some extensions---for instance, creating a file containing
 metadata information about a directory---can introduce ordering
 requirements difficult to express at the VFS layer.
%
This problem exists for applications as well.
%
The expensive \texttt{fsync} and \texttt{sync} system calls are the only
 tools available for enforcing file consistency.
%
Robust applications, including databases, mail servers, and source code
 management tools, either accept the performance penalty of these system
 calls or rely on specialized raw-disk interfaces.


Proposed systems for improving file system integrity and consistency differ
 mainly in the kind of consistency they aim to impose, ranging from
 metadata consistency to full data journaling
 and even full ACID
 transactions~\cite{gal05transactional,liskov04transactional}.
%
However, different extensions within a file system, or different
 applications over the file system, may require different types of
 consistency semantics, and performance suffers when lower layers are
 unnecessarily denied the opportunity to reorder
 writes.
%
A better choice might be an abstraction that could express many consistency
 models.


This work develops a new fundamental data type called a \emph{\patch},
 which represents both a change to disk data and any \emph{dependencies}
 between that change and other changes. 
%
\Patches\ were inspired by the dependency abstraction from BSD's soft
 updates~\cite{ganger00soft}, but whereas the soft updates implementation
 involves many structures specific to the UFS file
 system~\cite{mckusick99soft}, \patches\ are fully general, simply
 specifying how a range of data should be changed.
%
This lets file system implementations and extensions examine and modify
 dependency structures independent of the file system's layout.
%
This generality comes at a cost, but the cost can be partially mitigated.
%
Real file system implementations achieve consistency and write ordering
 relationships using a variety of file system specific optimizations, and
 we found that a naive implementation scaled terribly poorly, spending far
 more space and time on dependency manipulation than conventional systems.
%
We therefore developed a variety of dynamic optimizations that
 significantly reduce the memory and CPU overhead associated with \patches.
%
We describe \patches\ abstractly, state their behavior and safety
 properties, and reason about the correctness of our optimizations.
%
Finally, we demonstrate a prototype file system implementation using
 \patches\ called \Kudos.
%
For an untar-Linux benchmark that writes 253~MB of data, our optimizations
 can reduce the number of \patches\ created by half and the amount of
 rollback data memory required by 99.73\%. 


The \Kudos\ file system implementation is decomposed entirely into
 pluggable \modules\ that manipulate \patches, hopefully making the system
 as a whole more configurable, extensible, and easier to understand.
%
Any file system \module\ can generate \patches; other modules can examine
 them and modify them when required.
%
\Patch\ dependency requirements are obeyed by all other file system
 layers, allowing them to be passed through layers such as loopback block
 devices.
%
As a result, the loosely-coupled \modules\ that make up a file system
 implementation can cooperate to implement strong and often complex
 consistency guarantees, even though each individual \module\ does a
 relatively small part of the work.


\Patches\ can implement many consistency mechanisms, including
 soft updates and journaling.
%
Our file system modules impose soft updates-style \patch\
 requirements by default; we have also written a prototype journal module. 
%
Additionally, we give user-level applications controlled access to \patches,
allowing applications to impose their own limited consistency
 policies.
%
Modifying an IMAP mail server to use this interface requires only localized
 changes; the resulting server follows IMAP's consistency
 requirements while writing fewer blocks to disk.
%
Our prototype implementation is not yet as fast as we would like, but it
 already runs several benchmarks faster than FreeBSD on the same hardware.

\begin{comment}
 not ACID transactions: transactions should be independent, but any file
 system client can observe all active \patches), we believe that using
 \patches\ will allow the construction of consistent, modular, extensible
 file systems that are much easier to understand.
\end{comment}


Our contributions include the generalized \patch\ design, the
 optimizations we have developed for dealing with \patches, the formal
 model of \patches, the \module\ interfaces in our \Kudos\ prototype,
 several of the individual \Kudos\ \modules\ like the journal, and the
 \patchgroup\ interface that exports \patches\ to user space.


%% They can also be extended, in a carefully controlled way, into userspace --
%% enabling applications with custom consistency and performance requirements to
%% specify explicit write ordering restrictions to be honored by the file system.
%% We will show that this can give such applications several benefits over existing
%% interfaces like \texttt{fsync()} which provide only coarse control over
%% consistency, or which either impose high overhead (data journaling) or don't
%% guarantee data consistency (soft updates, for example, ensures metadata
%% consistency only).
