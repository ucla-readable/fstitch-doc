\section{Related Work}
\label{sec:related}

\paragraph{Consistency}

Most modern file systems protect file system integrity in the face of
possible power failure or crashes via journaling, which groups
operations into transactions that commit
atomically~\cite{seltzer00journaling}.
The content and the layout of the
journal vary in each implementation, but in all cases, the system can use the
journal to replay (or roll back) any transactions that did not complete due to
the shutdown. A recovery procedure, if correct~\cite{yang04using}, 
avoids time-consuming
\emph{fsck}-like file system
checks on reboot after a crash in favor of simple journal operations.

Soft updates~\cite{ganger00soft} is another important mechanism for
ensuring post-crash consistency. Carefully managed write orderings
avoid the need for synchronous writes to disk or duplicate writes to
a journal; only relatively harmless inconsistencies, such as leaked blocks,
are allowed to appear on the file system. As in journaling, soft updates
can avoid \emph{fsck} after a crash, although a background \emph{fsck} is
required to recover leaked storage.

Both journaling and soft updates are naturally represented in terms of
patches, as Section~\ref{sec:patch:examples} demonstrates, and we use both
journaling and soft updates as running examples throughout the paper.
%
Soft updates forms in some ways a more challenging test of the patch
abstraction: its dependencies are more variable and harder to predict,
it are widely considered difficult to implement, and the existing FreeBSD
implementation is quite optimized~\cite{mckusick99soft}.
%
We therefore frequently discuss soft updates-like
dependencies.
%
This should not be construed as a wholesale endorsement of soft updates,
which relies on a property (atomic block writes) that many disks do not
provide, and which often requires more seeks than journaling
despite writing less data.

CAPFS~\cite{vilayannur05providing} and Echo~\cite{mann94coherent}
have considered
customizable application-level consistency protocols
in the context of distributed, parallel file systems.
%
CAPFS allows application writers to design plug-ins for a parallel file store
that define what actions to take before and after each client-side system
call.
%
These plug-ins can enforce additional consistency policies.
%
Echo maintains a partial order on the locally cached updates to the remote file
system, and guarantees that the server will store the updates accordingly;
applications can extend the partial order.
%% , thus
%% reducing the server's flexibility to choose how to write the data or make it
%% available to other clients.
%
Both systems are based on the principle that not providing the right
consistency protocol can cause unpredictable failures, yet enforcing
unnecessary consistency protocols can be extremely expensive.
%
%% However, this is also true with a local file system, and as a result
%% applications currently use expensive interfaces like \texttt{fsync()} when
%% they require specific consistency guarantees.
%
\Kudos\ \patchgroups\ bring this sort of customizable consistency to all
applications, not just those using specialized distributed file systems.

A similar application interface to \patchgroups\ is explored in
Section~4 of Burnett's thesis~\cite{burnett06information}. However, the methods
used to implement the interfaces are very different: Burnett's system tracks
dependencies at the level of entire system calls, associates dirty blocks with
unique IDs returned by those calls, and duplicates dirty blocks when necessary
to preserve ordering. \Kudos\ tracks individual changes to blocks internally,
allowing kernel modules a finer level of control, and only chooses to expose a
userspace interface similar to Burnett's as a means to simplify the sanity
checking required of arbitrary user-submitted requests.
%
Additionally, our evaluation uses a real disk rather than trace-driven
simulations.
%% rather than an implementation. We have found that some aspects of real disks
%% have significant impacts which his simulator may not have taken into account;
%% for instance, we have found that the number of I/O requests to the disk, rather
%% than the theoretical seek time or the number of blocks accessed, can be a
%% bottleneck.

Dependency-like ideas have also been explored in
BlueFS~\cite{nightingale05speculative} and
xsyncfs~\cite{nightingale06rethink} to reduce the aggregate performance
impact of providing strong consistency guarantees.
%
In particular, xsyncfs gives users the illusion that the file system
synchronizes after every write, without actually blocking applications .

External synchrony~\cite{nightingale06rethink} builds on journaling to
automatically provide strict file system operation ordering for applications,
without requiring them to block on each write. It combines operations into a
journal, but tracks the activity of the calling processes after returning
control to them from the file system. If a process later performs some
\emph{user-visible} operation like printing text to the screen or sending
network traffic, the journal transaction containing the changes is forced to
commit before the process can continue.
%
External synchrony depends inherently on dependency tracking; dependencies
among processes with outstanding data are tracked to ensure that
uncommitted output never reaches a user. However, it also depends on a
particular file system consistency methodology, namely journaling, and it
is implemented only in an ext3-like file system called xsyncfs. \Kudos\
\patch\ dependencies could be a natural implementation strategy for its
dependencies, allowing them to apply to any file system.
%
Similar \patch-like dependencies are used to improve network file system
performance in BlueFS~\cite{nightingale05speculative}.

% "allow the kernel to safely and efficiently handle any metadata layout without understanding the layout itself"
% \cite{kaashoek97application}

\paragraph{Stackable File Systems}

% \cite{webber93portable}

Stackable \module\ software for file systems continues to attract active
research~\cite{rosenthal90evolving, heidemann91layered, skinner93stacking,
heidemann94filesystem,zadok99extending,
zadok00fist,wright03ncryptfs,wright06versatility}. Previous
systems like FiST~\cite{zadok00fist} or GEOM~\cite{geom} generally focus on
an individual portion of the system and thus restrict both what a \module\
can do and how \modules\ can be arranged. FiST, for instance, does not
provide a way to deal with structures on the disk directly -- it provides
only ``wrapper'' functionality around existing file
systems. %% (Wrapfs~\cite{zadok99stackable, zadok99extending} is similar.)
GEOM, on the other hand, deals only with the block device layer, and has no
way to work with the file systems stored on those block devices. Neither
has a formal way of specifying or honoring complex write-ordering
information, which is what \patches\ in \Kudos\ provide. We imagine that
systems like these could be adapted to work with \patches, giving the
benefits of both ideas.

\paragraph{Applications}

A variety of extensions to file systems and disk interfaces have been proposed
in recent work, like the FS2 Free Space File System~\cite{huang05fs2},
encrypting file systems like NCryptfs~\cite{wright03ncryptfs}, and type-safe
disks~\cite{sivathanu06typesafe}. The \Kudos\
\module\ system may provide an interesting platform for implementations 
of these ideas.
%% NCryptfs has been written in a
%% stackable way already, allowing it to be easily adapted for new underlying file
%% systems -- but FS2 is currently specific to ext2, since it deals directly with
%% low-level disk structures. The \Kudos\ \module\ interface should allow such an
%% extension to be written in a portable way, giving it the same benefit.

\paragraph{} \Kudos\ adds to this body of work by generalizing and making
explicit the ``write before'' relationship that is already present in many
storage systems, and making it a pervasive primitive throughout the storage
system. This allows many different consistency models to be created and
combined in file system independent ways, and it provides a means for file
system extensions to deal directly with consistency. It also allows the
extension of this concept into userspace, so that even user applications
can easily use this functionality.
