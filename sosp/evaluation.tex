\section {Evaluation}
\label{sec:evaluation}

Our evaluation shows that a \Kudos\ \patch-based storage system has
overall performance that is within reason, even though it is slower
than Linux in some benchmarks. We also evaluate \patch\ optimizations,
and demonstrate the effectiveness of \patchgroups\ for the UW IMAP
mail server.
%
\todo{Revise me}

\subsection{Methodology}

All tests were run on a Dell Precision 380 with a 3.2GHz Pentium 4
CPU, 2GB of RAM, and a Seagate ST3320620AS 320GB 7200RPM SATA2 disk.
%
All tests use a 10~GB file system and the Linux 2.6.20.1 kernel
with the Ubuntu v6.06 distribution.
%
We examine Linux ext2 and ext3 (in ordered and journal modes) and
\Kudos\ ext2 (in async, soft updates, metadata journal, and full
journal modes), all created with default configurations.
%
All timing results, except where otherwise noted, are the mean over three runs.

To evaluate \patch\ optimizations and \Kudos\ as a whole we ran four
benchmarks.
%
The \emph{tar benchmark} untars and syncs the Linux 2.6.15 source code
from the cached file \texttt{linux-2.6.15.tar} (218~MB).
%
The \emph{delete benchmark} deletes the result of the tar benchmark
and syncs, after unmounting and then remounting the file system.
%
The \emph{PostMark benchmark} emulates the small file workloads seen
on email and netnews servers~\cite{postmark}. We use PostMark v1.5,
configured to create 500 files ranging in size from 500~B to 200~kB;
perform 500 transactions consisting of file reads, writes, creates,
and deletes; deletes its files; and finally syncs.
%
The modified \emph{Andrew benchmark} emulates a software development
workload.  The benchmark creates a directory hierarchy, copies a
source tree, reads the extracted files, compiles the extracted files,
and syncs. The source code we use for the Andrew benchmark is the Ion
window manager, version 2-20040729.

\subsection {Optimization Benefits}

We evaluate the effectiveness of the \patch\ optimizations discussed in
Section~\ref{sec:patch:optimizations}, in terms of
%
the total number of \patches\ created, amount of undo data allocated,
and system CPU time used.
%
Figure~\ref{f:optdata} shows these results for the untar, delete,
PostMark, and Andrew benchmarks for \Kudos\ ext2 in soft updates mode,
with all combinations of using \nrb\ \patches\ and overlap merging.
%
While both optimizations work well alone, the combination of the two
is particularly effective at reducing the amount of undo data.
%
Undo data memory usage is reduced by 85--100\%,
%
the number of \patches\ created is reduced by 73--99\%,
%
and system CPU time is reduced by up to 63\%.
%
\todo{Why does postmark create more patches with both optimizations
  than with just overlap merging? Because of the unoptimized \texttt{rename}?}

\begin{figure}[t]
\centering
\small
\begin{tabular}{@{}lrrr@{}}
\textbf{Optimization}
        & \textbf{\# \patches} & \textbf{Undo data} & \textbf{System time} \\
% Results are from r3857
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Untar test}\raise2pt\hbox{\strut}} \\
None
        & 619,741               & 470.04~MB             & 3.60~sec \\
\Nrb\ \patches\
        & 446,013               & 210.88~MB             & 3.22~sec \\
Overlap merging
        & 112,644               & 260.14~MB             & 2.66~sec \\
Both optimizations
        &  67,498               & 0.34~MB               & 2.32~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Delete test}\raise2pt\hbox{\strut}} \\
None
        & 299,089               & 1.46~MB               & 0.91~sec \\
\Nrb\ \patches\
        & 41,108                & 0.93~MB               & 0.31~sec \\
Overlap merging
        & 54,656                & 0.96~MB               & 0.36~sec \\
Both optimizations
        &  1,800                & 0.00~MB               & 0.21~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{PostMark test}\raise2pt\hbox{\strut}} \\
None
        & 250,370               & 176.56~MB             & 1.46~sec \\
\Nrb\ \patches\
        & 155,484               & 86.14~MB              & 1.16~sec \\
Overlap merging
        &  48,184               & 90.27~MB              & 0.75~sec \\
Both optimizations
        &  22,620               & 0.00~MB               & 0.54~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Andrew test}\raise2pt\hbox{\strut}} \\
None
        &  70,911               & 65.63~MB              & 5.44~sec \\
\Nrb\ \patches\
        &  50,349               & 37.05~MB              & 5.66~sec \\
Overlap merging
        &  15,545               & 37.95~MB              & 5.45~sec \\
Both optimizations
        &  18,954               & 9.45~MB               & 5.41~sec \\
\end{tabular}
\caption{Effectiveness of \Kudos\ optimizations.}
\label{f:optdata}
\end{figure}


\begin{comment}
\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{rb_patch_size}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:patchsize-histo} \Rb\ \patch\ size histogram for a sample
workload (extracting a large archive into ext2). All the \patches\ larger than
63 bytes have been optimized into \nrb\ \patches. \Rb\ \patches\ 4 bytes and
smaller account for about 51\% of all \rb\ \patches.}
\end{figure}
\end{comment}

\subsection {Benchmarks}
\label{sec:eval:bench}

We compare \Kudos\ and Linux ext2 and ext3 for the tar, delete,
PostMark, and Andrew benchmarks. Times for these benchmarks are listed
in Figure~\ref{fig:bench_time}.

At the untar test, the \Kudos\ async mode is faster than Linux ext2, which
provides a similar consistency guarantee. The \Kudos\ soft updates mode is
only 15\% slower but provides a much stronger guarantee, and it is about 2.3
times as fast as the widely used Linux ext3 ordered mode which does provide a
comparable consistency guarantee. The \Kudos\ metadata journal mode is faster
than both Linux ext3 journal modes, though \Kudos\ full journaling is slower.
At the remove test, all \Kudos\ modes are substantially faster than all Linux
modes, due to differences in how \Kudos\ allocates inodes and blocks during
the untar test.

When looking only at the System CPU time, however, \Kudos\ can use up to
5.6 times as much CPU as a similar Linux mode. This effect is partially
mitigated by smaller I/O times, but it is an important concern and has
been the focus of most of our later optimizations.

%This demonstrates that the overhead of using \patches\ in \Kudos\ is not
%entirely unreasonable, but has room for significant improvement.
%
%% While \Kudos\ does still have some CPU usage and I/O delay problems, its
%% performance has been steadily improving over time and we expect that it will
%% continue to improve as we optimize it further.
%
%% There are more optimization opportunities that can likely bring us much closer
%% in performance to Linux. 

We next evaluate overall performance using the PostMark benchmark,
designed to simulate the small file workloads seen on email and
netnews servers~\cite{postmark}.
%
We use PostMark 1.5, configured to use 4kB reads and writes and to
create 100 files ranging in size from 500 B to 16 MB; perform 500
transactions consisting of file reads, writes, creates, and deletes;
and finally delete its files. PostMark is a single process, single
threaded program that performs these file system operations as quickly
as possible.


% The system time column shows time spent executing code in kernel space
% during the untar or remove; this is mostly \Kudos\ overhead.  Linux's
% system time numbers during a comparable test are much lower.  Profiling
% numbers indicate optimization opportunities in some of \Kudos's auxiliary
% libraries, such as its hash table, as well as more significant optimization
% opportunities we hope to address in future work.


\begin{figure}[tb]
\centering
\small
\begin{tabular}{@{}lrrrr@{}}
\textbf{System} & \multicolumn{1}{c}{\textbf{Untar}} & \multicolumn{1}{c}{\textbf{Delete}} & \multicolumn{1}{c}{\textbf{PostMark}} & \multicolumn{1}{c}{\textbf{Andrew}} \\ \hline
% Results are from r3862 and NDEBUG, except for WB from r3857 and no NDEBUG
% (though NDEBUG does not seem to really change any of the numbers)
\emph{\Kudos\ ext2} & & & & \\
async & 4.0 [1.5] & 0.7 [0.2] & 1.4 [0.5] & 37.3 [5.4] \\
soft updates & 6.1 [2.2] & 0.9 [0.2] & 2.4 [0.5] & 45.2 [5.4] \\
meta journal & 8.1 [3.8] & 1.4 [0.5] & 3.6 [1.6] & 37.6 [5.4] \\
full journal, WB & 10.0 [4.6] & 1.2 [0.5] & 4.4 [2.0] & 37.6 [5.5] \\
full journal & 12.8 [4.2] & 1.4 [0.5] & 5.2 [1.7] & 37.8 [5.4] \\ \hline

%FreeBSD (soft updates) & 23.22 & 15.95 \\ 
%FreeBSD (async) & 10.09 & 3.25 \\ \hline

\emph{Linux} & & & & \\
ext2 & 4.5 [0.7] & 4.6 [0.2] & 0.2 [0.1] & 37.3 [4.9] \\
ext3 ordered & 13.9 [1.0] & 4.3 [0.2] & 0.3 [0.2] & 37.1 [4.9] \\
ext3 journal & 10.9 [1.1] & 4.3 [0.3] & 2.7 [0.3] & 37.8 [5.0] \\
ext3 journal, WT & 12.7 [1.2] & 4.5 [0.2] & 3.4 [0.3] & 38.8 [5.0] \\
\end{tabular}
\caption{\label{fig:bench_time} Untar, delete, PostMark, and Andrew
  benchmark times (seconds). System CPU times are in square brackets.
  Kudos times are for a WT drive cache, except for ``WB,'' and Linux
  times are for a WB drive cache, except for ``WT.''}
\end{figure}

Finally, we evaluate performance using a modified Andrew benchmark,
which simulates a development workstation by extracting some source
code, scanning and reading the directory tree with several text
processing utilities, and then compiling the source code. The source
code we use is the Ion window manager, version 2-20040729.

Figure~\ref{fig:bench_time} shows the times to run PostMark and the Andrew
benchmark, and then synchronize their results to disk.

%\Kudos's PostMark performance, compared to Linux and FreeBSD, falls
%into the middle of \S\ref{sec:eval:untardel}'s untar and delete
%benchmarks. As PostMark combines file creation and deletion, its
%results follow for similar reasons as the untar and delete benchmarks'.

\Kudos\ appears to do well at the Andrew benchmark in all but the soft
updates case, where it spends a larger amount of I/O time than the other
modes. However, its performance at PostMark is much worse, generally
twice as slow as Linux with a comparable consistency guarantee, and it
exhibits the same larger CPU time as the untar and delete tests. The
extra I/O time in this case is due to the fact that Linux is normally
able to recognize operations that cancel out in the file system cache,
and avoid writing them to disk altogether. \Kudos\ does not yet support
this feature, so it writes many more unnecessary blocks.

\subsection {Correctness}
\label{sec:eval:correctness}

In order to check that we had implemented the soft updates rules correctly, we
implemented a \Kudos\ module which crashes the operating system, without
giving it a chance to synchronize its buffers, at a random time during the
untar test.
%
In \Kudos\ asynchronous mode, after crashing, fsck nearly always reported that
the file system contained many references to inodes that had been deleted: the
file system was corrupt.
%
With our soft updates dependencies, the file system was always mostly
consistent: fsck reported that inode reference counts were higher than the
correct values (an expected discrepancy after a soft updates crash).

\subsection {\Patchgroups}

% #reviewers who want measurements of all case studies: 1
% #reviewers who want measurements of at least svn and imap studies: 2
% include time
% comment on perf and any ordering guarantee differences
% make svn client fsync() and compare?

%\subsubsection {gzip}

%\subsubsection {Subversion Case Study}
%
%Complexity of implementation, reliance on specific FS semantics (i.e. ext3)
%even with all that jumping through hoops - broken on NTFS, for example.
%Straightforward to get correctness with \patchgroups; counts only on a simple API.

\label{sec:evaluation:uwimap}
We implemented a preliminary assessment of the \patchgroup-enabled UW IMAP mail server
(\S\ref{sec:patchgroup:uwimap}) by comparing the number of block writes
that \Kudos\ makes relative to FreeBSD to move 100 emails. The test
selects the source mailbox (with 100 messages, sized 2kB each),
creates the new mailbox, copies each of the 100 messages to the new
mailbox, marks each source message for deletion, expunges the marked
messages, requests a check, and logs out. We compare using soft updates;
Figure~\ref{fig:imap-compare} shows the results.

\begin{figure}[t]
\centering
\begin{tabular}{@{}lrr@{}}
\textbf{System} & \textbf{Time} & \textbf{Writes} \\ \hline
% Results are from r3862

% NOFUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 11.4 [0.4] & 3,015 \\
\Kudos\ (meta journal) & 1.4 [0.4] & 33 \\
\Kudos\ (full journal) & 1.4 [0.4] & 33 \\ \hline

% FUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 27.5 [1.1] & 3,015 \\
\Kudos\ (meta journal) & 1.5 [0.4] & 32 \\
\Kudos\ (full journal) & 1.5 [0.4] & 32 \\ \hline

% without patchgroups, FUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 64.9 [0.3] & 8,367 \\
\Kudos\ (meta journal) & 51.3 [0.4] & 7,111 \\
\Kudos\ (full journal) & 51.4 [0.4] & 7,117 \\ \hline

% WB
Linux (ext2) & 1.5 [0.3] & 2,503 \\
Linux (ext3 ordered) & 2.0 [0.3] & 3,025 \\
Linux (ext3 journal) & 1.8 [0.3] & 2,531 \\ \hline

% WT
Linux (ext2) & 16.7 [0.3] & 2,503 \\
Linux (ext3 ordered) & 23.9 [0.3] & 3,025 \\
Linux (ext3 journal) & 20.4 [0.3] & 2,531 \\ \hline
Linux (ext3 journal) & min fsyncs & ? \\
\end{tabular}
\caption{\label{fig:imap-compare} IMAP benchmark: move 1000 messages
  to a second folder. Times are in seconds, writes in number of requests.
  System CPU times are in square brackets.}
\end{figure}
