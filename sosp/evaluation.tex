% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section {Evaluation}
\label{sec:evaluation}

We evaluate
%
the effectiveness of \patch\ optimizations,
%
the performance of the \Kudos\ implementation relative to Linux ext2
and ext3,
%
the correctness of the \Kudos\ implementation,
%
and the performance of \patchgroups.
%
This evaluation shows
%
that \patch\ optimizations significantly reduce \patch\ memory and CPU
requirements;
%
that a \Kudos\ \patch-based storage system has overall performance
that is within reason, even though it is slower than Linux in some
benchmarks;
%
that \Kudos\ file systems are consistent after system crashs;
%
and that a \patchgroup-enabled IMAP server performs as well as or
better than the unmodified server.

\subsection{Methodology}

All tests were run on a Dell Precision 380 with a 3.2~GHz Pentium 4
CPU, 2~GB of RAM, and a Seagate ST3320620AS 320~GB 7200~RPM SATA2 disk.
%
All tests use a 10~GB file system and the Linux 2.6.20.1 kernel
with the Ubuntu v6.06.1 distribution.
%
Because the \Kudos-kernel integration does not use high memory and
because \Kudos\ uses its own block cache in addition to the kernel's,
we limit \Kudos\ and Linux configurations to an effective 312~MB of
RAM available for the block cache.
%
Specifically, \Kudos\ configurations have 662~MB of RAM total and
312~MB of RAM for the \Kudos\ block cache
%
and Linux configurations have 350~MB of RAM total and 312~MB of RAM
for the block cache.

We examine Linux ext2 (in asynchronous mode) and ext3 (in writeback,
ordered, and full journal modes) and \Kudos\ ext2 (in asynchronous,
soft updates, metadata journal, and full journal modes), all created
with default configurations.

The three journal modes provide different consistency guarantees.
The strength of these guarantees is strictly ordered:
\vspace{-0.5\baselineskip}
\begin{center}
asynchronous $<$ writeback $<$ ordered $<$ full
\end{center}
\vspace{-0.5\baselineskip}
Writeback journaling commits metadata atomically and commits data only
after the corresponding metadata. \Kudos\ metadata journaling is
equivalent to ext3 writeback journaling.
%
Ordered journaling commits data associated with a given transaction
prior to the proceeding transacation's metadata. It is the most
commonly used ext3 journaling mode.
%
In all tests ext3 writeback and ordered journaling modes performed
similarly, and \Kudos\ does not implement ordered mode, so we report
only writeback results.
%
Full journaling commits data atomically.

There is a notable write durability difference between the default
\Kudos\ and Linux ext2/ext3 configurations: \Kudos\ presumes a write
is durable after it is on the disk platter (safe) and Linux ext2 and
ext3 after it is in the disk cache (unsafe). However, Linux can write
safely (by restricting the disk to providing only a write through
cache) and \Kudos\ can write unsafely (by disabling FUA).
%
We report both results for each when comparing the systems.
%
All timing results are the mean over three runs.

To evaluate \patch\ optimizations and \Kudos\ as a whole we ran four
benchmarks.
%
The \emph{untar benchmark} untars and syncs the Linux 2.6.15 source code
from the cached file \texttt{linux-2.6.15.tar} (218~MB).
%
The \emph{delete benchmark}, after unmounting and remounting the file
system following the untar benchmark, deletes the result of the untar
benchmark and syncs.
%
The \emph{PostMark benchmark} emulates the small file workloads seen
on email and netnews servers~\cite{postmark}. We use PostMark v1.5,
configured to create 500 files ranging in size from 500~B to 4~MB;
perform 500 transactions consisting of file reads, writes, creates,
and deletes; delete its files; and finally sync.
%
The modified \emph{Andrew benchmark} emulates a software development
workload.  The benchmark creates a directory hierarchy, copies a
source tree, reads the extracted files, compiles the extracted files,
and syncs. The source code we use for the modified Andrew benchmark is
the Ion window manager, version 2-20040729.

\subsection {Optimization Benefits}

% this table is a command so that we can move its placement without conflicts
\newcommand{\opttable}{
\begin{figure}[t]
\centering
\small
\begin{tabular}{@{}lrrrr@{}}
\textbf{Optimization}
        & \textbf{\# \Patches} & \textbf{Undo data} & \textbf{System time} \\ % Malloc
% Results are from r4020, but only for 2 runs
% NOTE: also update numbers in \patchoptundo and \patchoptcount
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Untar test}\raise2pt\hbox{\strut}} \\
None              &   619,740 &   459.41~MB &  3.44~sec \\ % 773~MB
\Nrb\ \patches\   &   445,927 &   210.88~MB &  3.09~sec \\ % 515~MB
Overlap merging   &   109,152 &   260.00~MB &  2.18~sec \\ % 544~MB
Both              &    67,363 &     0.33~MB &  2.33~sec \\ % 293~MB
\hline

\multicolumn{4}{@{}c@{}}{\textbf{Delete test}\raise2pt\hbox{\strut}} \\
None              &   299,089 &     1.43~MB &  0.85~sec \\ % 48~MB
\Nrb\ \patches\   &    41,113 &     0.90~MB &  0.29~sec \\ % 20~MB
Overlap merging   &    54,665 &     0.94~MB &  0.33~sec \\ % 21~MB
Both              &     1,800 &     0.00~MB &  0.19~sec \\ % 13~MB
\hline

\multicolumn{4}{@{}c@{}}{\textbf{PostMark test}\raise2pt\hbox{\strut}} \\
None              & 4,591,533 & 3,175.28~MB & 26.06~sec \\ % 5,347~MB
\Nrb\ \patches\   & 2,561,815 & 1,583.16~MB & 20.44~sec \\ % 3,672~MB
Overlap merging   &   542,665 & 1,587.81~MB & 13.50~sec \\ % 3,649~MB
Both              &   633,382 &     0.10~MB & 13.62~sec \\ % 2,073~MB
\hline

\multicolumn{4}{@{}c@{}}{\textbf{Andrew test}\raise2pt\hbox{\strut}} \\
None              &    70,922 &    64.09~MB &  4.30~sec \\ % 97~MB
\Nrb\ \patches\   &    50,680 &    36.18~MB &  4.32~sec \\ % 69~MB
Overlap merging   &    12,479 &    27.91~MB &  4.21~sec \\ % 60~MB
Both              &    10,118 &     0.03~MB &  4.18~sec \\ % 31~MB
\end{tabular}
\caption{Effectiveness of \Kudos\ optimizations.}
\label{f:optdata}
\end{figure}
}

\opttable{}

We evaluate the effectiveness of the \patch\ optimizations discussed in
Section~\ref{sec:patch:optimizations}, in terms of
%
the total number of \patches\ created, amount of undo data allocated,
total amount of memory allocated for \Kudos, and system CPU time used.
%
Figure~\ref{f:optdata} shows these results for the untar, delete,
PostMark, and Andrew benchmarks for \Kudos\ ext2 in soft updates mode,
with all combinations of using \nrb\ \patches\ and overlap merging.
The results for metadata and full data journaling are similar.
%
While both optimizations work well alone, the combination of the two
is particularly effective at reducing the amount of undo data.
%
Undo data memory usage is reduced by \patchoptundo,
%
the number of \patches\ created is reduced by \patchoptcount,
%
the total amount of memory allocated by \Kudos\ by 61--73\%,
%
and system CPU time is reduced by up to 77\%.
\todo{Discuss why both can increase \#patches and CPU.}

\begin{comment}
\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{rb_patch_size}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:patchsize-histo} \Rb\ \patch\ size histogram for a sample
workload (extracting a large archive into ext2). All the \patches\ larger than
63 bytes have been optimized into \nrb\ \patches. \Rb\ \patches\ 4 bytes and
smaller account for about 51\% of all \rb\ \patches.}
\end{figure}
\end{comment}

\subsection {Benchmarks}
\label{sec:eval:bench}

\newcommand{\safe}[1]{\textbf{#1}}
\newcommand{\unsafe}[1]{#1}

% this table is a command so that we can move its placement without conflicts
\newcommand{\benchtable}{
\begin{figure}[tb]
\centering
\small
\begin{tabular}{@{}lrrrr@{}}
\textbf{System} & \multicolumn{1}{c}{\textbf{Untar}} & \multicolumn{1}{c}{\textbf{Delete}} & \multicolumn{1}{c}{\textbf{PostMark}} & \multicolumn{1}{c}{\textbf{Andrew}} \\ \hline
% Results are from r4037, mean of 5 runs
\multicolumn{5}{@{}l}{\emph{\Kudos\ ext2}\raise2pt\hbox{\strut}} \\
\safe{soft updates} & \safe{6.4 [1.9]} & \safe{0.8 [0.2]} & \safe{47.0 [13.5]} & \safe{36.9 [4.1]} \\
\safe{meta journal} & \safe{8.5 [2.6]} & \safe{1.4 [0.5]} & \safe{70.8 [15.6]} & \safe{36.7 [4.2]} \\
\safe{full journal} & \safe{12.8 [3.2]} & \safe{1.3 [0.5]} & \safe{93.8 [19.7]} & \safe{36.9 [4.4]} \\
\unsafe{async} & \unsafe{4.3 [1.4]} & \unsafe{0.7 [0.2]} & \unsafe{45.4 [~~7.3]} & \unsafe{36.4 [4.1]} \\
\unsafe{full journal} & \unsafe{11.1 [3.8]} & \unsafe{1.1 [0.5]} & \unsafe{83.9 [23.7]} & \unsafe{36.7 [4.3]} \\ \hline

% Results mean of 3 runs
\multicolumn{5}{@{}l}{\emph{Linux}\raise2pt\hbox{\strut}} \\
\safe{ext3 writeback} & \safe{19.5 [1.0]} & \safe{4.5 [0.3]} & \safe{55.7 [~~3.7]} & \safe{37.8 [4.0]} \\
\safe{ext3 journal} & \safe{20.3 [1.2]} & \safe{4.6 [0.2]} & \safe{82.5 [~~5.0]} & \safe{38.2 [4.0]} \\
\unsafe{ext2} & \unsafe{9.5 [0.7]} & \unsafe{4.7 [0.2]} & \unsafe{45.8 [~~2.0]} & \unsafe{37.0 [4.0]} \\
\unsafe{ext3 journal} & \unsafe{15.3 [1.2]} & \unsafe{4.3 [0.3]} & \unsafe{80.2 [~~4.9]} & \unsafe{37.3 [4.0]} \\

%FreeBSD (soft updates) & 23.22 & 15.95 & & \\ 
%FreeBSD (async) & 10.09 & 3.25 & & \\
\end{tabular}
\caption{\label{fig:bench_time} Benchmark times (seconds). System CPU
  times are in square brackets. Safe configurations are \safe{bold},
  unsafe configurations are \unsafe{normal text}.}
\end{figure}
}

We benchmark \Kudos\ and Linux ext2/ext3 for the untar, delete,
PostMark, and Andrew benchmarks. Results are listed in
Figure~\ref{fig:bench_time}.
%
The general result is that \Kudos\ and Linux ext2/ext3 perform
similarly when providing similar durability guarantees. Linux
ext2/ext3 also outperforms \Kudos, and vice versa, in some scenarios.

\benchtable{}

While \Kudos\ performs similarly for total time for the untar, delete,
and Andrew benchmarks, during each test \Kudos\ uses significantly
more CPU time than Linux ext2 or ext3 do---up to three times the CPU
time.
%
Higher CPU requirements are an important concern and, though they were
the focus of many of our optimization efforts, remain a weakness
for \Kudos.
%
Some of the contributors to \Kudos\ CPU usage are inherent, e.g.
\patch\ creation, while others are artifacts of the current
implementation, e.g.  creating a second copy of a block to write it to
disk. We have not separated these two categories.
%
Further, while \Kudos\ I/O times are lower than Linux ext2/ext3 I/O
times for the untar and delete benchmarks, we have found that small
block allocation strategy changes can significantly affect I/O time
for many of these benchmarks. This further emphasizes the importance
of the system CPU time difference.

Unlike the untar, delete, and Andrew benchmarks, Linux ext3 writeback
and journal modes outperform \Kudos\ meta journal and full journal
modes, respectively, at PostMark.\todo{Note that we do not know why
  and/or note cpu time difference?}

%This demonstrates that the overhead of using \patches\ in \Kudos\ is not
%entirely unreasonable, but has room for significant improvement.

\subsection {Correctness}
\label{sec:eval:correctness}

In order to check that we had implemented the soft updates rules correctly,
we implemented a \Kudos\ module which crashes the operating system, without
giving it a chance to synchronize its buffers, at a random time during each
run.
%
In \Kudos\ asynchronous mode, after crashing, fsck nearly always reported
that the file system contained many references to inodes that had been
deleted, among other errors: the file system was corrupt.
%
With our soft updates dependencies, the file system was always mostly
consistent: fsck reported that inode reference counts were higher than the
correct values (an expected discrepancy after a soft updates crash).

\subsection {\Patchgroups}
\label{sec:evaluation:uwimap}

% #reviewers who want measurements of all case studies: 1
% #reviewers who want measurements of at least svn and imap studies: 2

We evaluate the performance of the \patchgroup-enabled UW IMAP mail
server (\S\ref{sec:patchgroup:uwimap}) by benchmarking moving 1,000
messages from one folder to another.
%
To move the messages the client selects the source mailbox (containing
1,000 2~kB messages), creates a new mailbox, copies each message to
the new mailbox and marks each source message for deletion, expunges
the marked messages, commits the mailboxes, and logs out.

Figure~\ref{fig:imap-compare} shows the results for safe file system
configurations,
%
reporting total time, system CPU time, and the number of disk write
requests (an indicator of the number of required seeks in safe
configurations).
%
We benchmark
%
\Kudos\ and Linux with the unmodified server (sync after each message
copy),
%
\Kudos\ with the \patchgroup-enabled server (sync only at the end),
%
and Linux and \Kudos\ with the server modified to take advantage of
fully journaled file systems (changes are effectively committed
linearly, so sync only at the end).

Unsafe \Kudos\ and Linux configurations complete in about 1.5~seconds;
we do not include their results among the safe configurations in
Figure~\ref{fig:imap-compare}.
%
\Kudos\ meta and full journal modes perform similarly so we report
only for the full journal mode.
%
Linux ext3 writeback, ordered, and full journal modes also perform simiarly
so we report only for the full journal mode.
%
Using the linear consistency method with \Kudos\ and Linux full
journal modes perform similarly so we report only Linux results.

Fully journaled \Kudos\ with \patchgroups\ performs at least as well
as all other (safe and unsafe) \Kudos\ and all Linux configurations.
It is 11--13 times faster than safe Linux ext3 with the unmodified
server.
%
Using the linear consistency method with \Kudos\ and Linux, the IMAP
server performs similarly to the \patchgroup\ consistency method with
\Kudos. However, the linear consistency method requires the underlying
file system use full data journaling.
%
\Kudos\ in soft updates mode with \patchgroups\ is significantly
slower than \Kudos\ in journal modes. As the number of write requests
indicate, each of soft updates mode's \patchgroups\ require multiple
write requests (e.g. to update the destination mailbox and the
destination mailbox's modification time). In contrast, journaling is
able to commit a large number of copies atomically, using only a small
constant number of requests.
%
\Kudos\ with the unmodified server makes significantly many more
requests than Linux ext3; we believe this is due to \Kudos\ also
committing file system summary information that Linux does not commit
for the \texttt{fsync} system call.

\begin{figure}[t]
\centering
\begin{tabular}{@{}llrr@{}}
\textbf{File System} & \textbf{Consistency method} & \textbf{Time} & \textbf{Writes} \\ \hline

% Results are from r3933
% Single commented out reuslts are from r3933
%% Double commented out results are from r3862

%\multicolumn{5}{@{}c@{}}{\textbf{Unsafe}\raise2pt\hbox{\strut}} \\

% WB
%fsync & Linux & ext2 & 1.5 [0.3] & 2,503 \\
%%Linux ext3 ordered (fsync) & 2.0 [0.3] & 3,025 \\
%fsync & Linux & ext3 journal & 1.8 [0.3] & 2,531 \\

% NOFUA
%\patchgroups & \Kudos & async & 1.2 [0.3] & 18 \\
%%\Kudos\ soft updates (pg) & 11.4 [0.4] & 3,015 \\
%%\Kudos\ meta journal (pg) & 1.4 [0.4] & 33 \\
%\patchgroups & \Kudos & full journal & 1.3 [0.5] & 33 \\ \hline

%\multicolumn{5}{@{}c@{}}{\textbf{Safe}\raise2pt\hbox{\strut}} \\

\multicolumn{4}{@{}l}{\emph{\Kudos\ ext2}\raise2pt\hbox{\strut}} \\

soft updates & fsync & 65.0 [0.3] & 8,083 \\
%%\Kudos\ meta journal (pg) & 51.3 [0.4] & 7,111 \\
full journal & fsync & 51.0 [0.5] & 7,114 \\

%%\Kudos\ async (pg) & 1.6 [0.3] & 2,503 \\
soft updates & \patchgroups & 27.2 [1.2] & 3,015 \\
%%\Kudos\ meta journal (pg) & 1.5 [0.4] & 32 \\
full journal & \patchgroups & 1.5 [0.5] & 32 \\ \hline

%linear & \Kudos & full journal & 1.4 [0.4] & 31 \\

\multicolumn{4}{@{}l}{\emph{Linux ext3}\raise2pt\hbox{\strut}} \\

%fsync & Linux & ext2 & 16.7 [0.3] & 2,503 \\
%%Linux ext3 ordered (fsync) & 23.9 [0.3] & 3,025 \\
journal & fsync & 20.4 [0.3] & 2,531 \\

journal & assume linear & 1.2 [0.3] & 26 \\

\end{tabular}
\caption{\label{fig:imap-compare} IMAP benchmark: move 1,000 messages.
  Times are in seconds (system CPU times in square brackets) and
  writes in number of requests.}
\end{figure}

\subsection{Summary}
\label{sec:evaluation:summary}

TODO\todo{Write me?}?
