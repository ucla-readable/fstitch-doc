\section {Evaluation}
\label{sec:evaluation}

Our evaluation shows that a \Kudos\ \patch-based storage system has
overall performance that is within reason, even though it is slower
than Linux in some benchmarks. We also evaluate \patch\ optimizations,
and demonstrate the effectiveness of \patchgroups\ for the UW IMAP
mail server.
%
\todo{Revise me}

\subsection{Methodology}

All tests were run on a Dell Precision 380 with a 3.2~GHz Pentium 4
CPU, 2~GB of RAM, and a Seagate ST3320620AS 320~GB 7200~RPM SATA2 disk.
%
All tests use a 10~GB file system and the Linux 2.6.20.1 kernel
with the Ubuntu v6.06 distribution.
%
We examine Linux ext2 and ext3 (in ordered and journal modes) and
\Kudos\ ext2 (in asynchronous, soft updates, metadata journal, and
full journal modes), all created with default configurations.
%
There is a notable write durability difference between the default
\Kudos\ and Linux ext2/3 configurations. A system can presume a write
is durable after it is on the disk platter (safe) or after it is in
the disk cache (unsafe). \Kudos\ defaults to safe and Linux ext2 and
ext3 to unsafe, but both systems can run with either durability
assumption and we report both results.
%
All timing results, except where otherwise noted, are the mean over three runs.

To evaluate \patch\ optimizations and \Kudos\ as a whole we ran four
benchmarks.
%
The \emph{tar benchmark} untars and syncs the Linux 2.6.15 source code
from the cached file \texttt{linux-2.6.15.tar} (218~MB).
%
The \emph{delete benchmark}, after unmounting and remounting the file
system following the tar benchmark, deletes the result of the tar
benchmark and syncs.
%
The \emph{PostMark benchmark} emulates the small file workloads seen
on email and netnews servers~\cite{postmark}. We use PostMark v1.5,
configured to create 500 files ranging in size from 500~B to 200~kB;
perform 500 transactions consisting of file reads, writes, creates,
and deletes; deletes its files; and finally syncs.
%
The modified \emph{Andrew benchmark} emulates a software development
workload.  The benchmark creates a directory hierarchy, copies a
source tree, reads the extracted files, compiles the extracted files,
and syncs. The source code we use for the Andrew benchmark is the Ion
window manager, version 2-20040729.

\subsection {Optimization Benefits}

% this table is a command so that we can move its placement without conflicts
\newcommand{\opttable}{
\begin{figure}[t]
\centering
\small
\begin{tabular}{@{}lrrr@{}}
\textbf{Optimization}
        & \textbf{\# \patches} & \textbf{Undo data} & \textbf{System time} \\
% Results are from r3857
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Untar test}\raise2pt\hbox{\strut}} \\
None
        & 619,741               & 470.04~MB             & 3.60~sec \\
\Nrb\ \patches\
        & 446,013               & 210.88~MB             & 3.22~sec \\
Overlap merging
        & 112,644               & 260.14~MB             & 2.66~sec \\
Both optimizations
        &  67,498               & 0.34~MB               & 2.32~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Delete test}\raise2pt\hbox{\strut}} \\
None
        & 299,089               & 1.46~MB               & 0.91~sec \\
\Nrb\ \patches\
        & 41,108                & 0.93~MB               & 0.31~sec \\
Overlap merging
        & 54,656                & 0.96~MB               & 0.36~sec \\
Both optimizations
        &  1,800                & 0.00~MB               & 0.21~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{PostMark test}\raise2pt\hbox{\strut}} \\
None
        & 250,370               & 176.56~MB             & 1.46~sec \\
\Nrb\ \patches\
        & 155,484               & 86.14~MB              & 1.16~sec \\
Overlap merging
        &  48,184               & 90.27~MB              & 0.75~sec \\
Both optimizations
        &  22,620               & 0.00~MB               & 0.54~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Andrew test}\raise2pt\hbox{\strut}} \\
None
        &  70,911               & 65.63~MB              & 5.44~sec \\
\Nrb\ \patches\
        &  50,349               & 37.05~MB              & 5.66~sec \\
Overlap merging
        &  15,545               & 37.95~MB              & 5.45~sec \\
Both optimizations
        &  18,954               & 9.45~MB               & 5.41~sec \\
\end{tabular}
\caption{Effectiveness of \Kudos\ optimizations.}
\label{f:optdata}
\end{figure}
}

\opttable{}

We evaluate the effectiveness of the \patch\ optimizations discussed in
Section~\ref{sec:patch:optimizations}, in terms of
%
the total number of \patches\ created, amount of undo data allocated,
and system CPU time used.
%
Figure~\ref{f:optdata} shows these results for the untar, delete,
PostMark, and Andrew benchmarks for \Kudos\ ext2 in soft updates mode,
with all combinations of using \nrb\ \patches\ and overlap merging.
Results are each from a single run.
%
While both optimizations work well alone, the combination of the two
is particularly effective at reducing the amount of undo data.
%
Undo data memory usage is reduced by 85--100\%,
%
the number of \patches\ created is reduced by 73--99\%,
%
and system CPU time is reduced by up to 63\%.
%
\todo{Why does postmark create more patches with both optimizations
  than with just overlap merging? Because of the unoptimized \texttt{rename}?}

\begin{comment}
\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{rb_patch_size}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:patchsize-histo} \Rb\ \patch\ size histogram for a sample
workload (extracting a large archive into ext2). All the \patches\ larger than
63 bytes have been optimized into \nrb\ \patches. \Rb\ \patches\ 4 bytes and
smaller account for about 51\% of all \rb\ \patches.}
\end{figure}
\end{comment}

\subsection {Benchmarks}
\label{sec:eval:bench}

\newcommand{\safe}[1]{\textbf{#1}}
\newcommand{\unsafe}[1]{#1}

% this table is a command so that we can move its placement without conflicts
\newcommand{\benchtable}{
\begin{figure}[tb]
\centering
\small
\begin{tabular}{@{}lrrrr@{}}
\textbf{System} & \multicolumn{1}{c}{\textbf{Untar}} & \multicolumn{1}{c}{\textbf{Delete}} & \multicolumn{1}{c}{\textbf{PostMark}} & \multicolumn{1}{c}{\textbf{Andrew}} \\ \hline
% Results are from r3862 and NDEBUG, except for WB from r3857 and no NDEBUG
% (though NDEBUG does not seem to really change any of the numbers)
\emph{\Kudos\ ext2} & & & & \\
\safe{async} & \safe{4.0 [1.5]} & \safe{0.7 [0.2]} & \safe{1.4 [0.5]} & \safe{37.3 [5.4]} \\
\safe{soft updates} & \safe{6.1 [2.2]} & \safe{0.9 [0.2]} & \safe{2.4 [0.5]} & \safe{45.2 [5.4]} \\
\safe{meta journal} & \safe{8.1 [3.8]} & \safe{1.4 [0.5]} & \safe{3.6 [1.6]} & \safe{37.6 [5.4]} \\
\safe{full journal} & \safe{12.8 [4.2]} & \safe{1.4 [0.5]} & \safe{5.2 [1.7]} & \safe{37.8 [5.4]} \\
\unsafe{full journal} & \unsafe{10.0 [4.6]} & \unsafe{1.2 [0.5]} & \unsafe{4.4 [2.0]} & \unsafe{37.6 [5.5]} \\ \hline

%FreeBSD (soft updates) & 23.22 & 15.95 \\ 
%FreeBSD (async) & 10.09 & 3.25 \\ \hline

\emph{Linux} & & & & \\
\unsafe{ext2} & \unsafe{4.5 [0.7]} & \unsafe{4.6 [0.2]} & \unsafe{0.2 [0.1]} & \unsafe{37.3 [4.9]} \\
\unsafe{ext3 ordered} & \unsafe{13.9 [1.0]} & \unsafe{4.3 [0.2]} & \unsafe{0.3 [0.2]} & \unsafe{37.1 [4.9]} \\
\unsafe{ext3 journal} & \unsafe{10.9 [1.1]} & \unsafe{4.3 [0.3]} & \unsafe{2.7 [0.3]} & \unsafe{37.8 [5.0]} \\
\safe{ext3 journal} & \safe{12.7 [1.2]} & \safe{4.5 [0.2]} & \safe{3.4 [0.3]} & \safe{38.8 [5.0]} \\
\end{tabular}
\caption{\label{fig:bench_time} Benchmark times (seconds). System CPU
  times are in square brackets. Safe configurations are \safe{bold},
  unsafe configurations are \unsafe{normal text}.}
\end{figure}
}

We compare \Kudos\ and Linux ext2 and ext3 for the tar, delete,
PostMark, and Andrew benchmarks. Times for these benchmarks are listed
in Figure~\ref{fig:bench_time}.

\benchtable{}

At the untar benchmark, the \Kudos\ async mode is faster than Linux
ext2, both provide a similar consistency guarantee.
%
\Kudos\ soft updates mode is 50\% slower, but provides a much stronger
consistency guarantee; it provides comparable consistency guarantees
to the widely used Linux ext3 in ordered data mode but is 50\% faster.
%
The \Kudos\ metadata journal mode is most similar to Linux ext3 in
ordered data mode and is 40\% faster.
%
The \Kudos\ full journal mode is 17\% slower than Linux ext3 in full
journal mode.
%
However, when run with the same durability assumptions \Kudos\ and
Linux ext3 in full journal modes run more similarly.

While \Kudos\ compares favorably for total time, during each test
\Kudos\ uses significantly more CPU time than Linux ext2 or ext3
do---up to four times the CPU time.
%
Higher CPU requirements are an important concern and, though they were
the focus of many of our optimization efforts, remain a strong issue
for \Kudos.
%
Additionally, while \Kudos\ I/O times are lower than Linux ext2/3 I/O
times, we have found that small block allocation strategy changes can
significantly affect I/O time for many of these benchmarks. This further
emphasizes the importance of the system CPU time difference.

%This demonstrates that the overhead of using \patches\ in \Kudos\ is not
%entirely unreasonable, but has room for significant improvement.

The delete benchmark results are similar to the tar benchmark's,
except that \Kudos\ total time is less than Linux ext2/3 total time
for all configurations. \Kudos\ I/O times are substantially lower
than Linux ext2/3 I/O times because of the block layout differences in
the tar benchmark.

We next evaluate overall performance using the PostMark benchmark.
Unlike the tar and delete benchmarks, \Kudos\ is slower than Linux
ext2 and ext3 in all configurations.
%
We believe the primary contributor to this difference comes is a
difference in the amount of I/O. Linux ext2 and Linux ext3 in ordered
journal mode detect that most dirty blocks are no longer referenced at
the end of the test, and so do not write them to disk (writing only
0.1--0.2~MB). In contrast, \Kudos\ and Linux ext3 in full journal mode
do not and so do write these blocks (writing 90--180~MB and 120~MB,
respectively).
%
While we believe that \Kudos\ probably can be improved to make this
optimization, we have not implemented it.
%
\todo{Use larger PostMark benchmark. Or note that a larger benchmark would
show less of an I/O difference.}

Finally, we evaluate performance using a modified Andrew benchmark.
\Kudos\ and Linux ext2/3 perform similarly in total time,
%
except for \Kudos\ in soft updates mode. In this mode \Kudos\ issues
an order of magnitude more write requests, we believe due to \Kudos's
unoptimized \texttt{rename} implementation which uses unnecessarily
strict dependencies between directory entries and inodes.

\subsection {Correctness}
\label{sec:eval:correctness}

In order to check that we had implemented the soft updates rules correctly, we
implemented a \Kudos\ module which crashes the operating system, without
giving it a chance to synchronize its buffers, at a random time during the
untar test.
%
In \Kudos\ asynchronous mode, after crashing, fsck nearly always reported that
the file system contained many references to inodes that had been deleted: the
file system was corrupt.
%
With our soft updates dependencies, the file system was always mostly
consistent: fsck reported that inode reference counts were higher than the
correct values (an expected discrepancy after a soft updates crash).

\subsection {\Patchgroups}

% #reviewers who want measurements of all case studies: 1
% #reviewers who want measurements of at least svn and imap studies: 2
% include time
% comment on perf and any ordering guarantee differences
% make svn client fsync() and compare?

%\subsubsection {gzip}

%\subsubsection {Subversion Case Study}
%
%Complexity of implementation, reliance on specific FS semantics (i.e. ext3)
%even with all that jumping through hoops - broken on NTFS, for example.
%Straightforward to get correctness with \patchgroups; counts only on a simple API.

\label{sec:evaluation:uwimap}
We implemented a preliminary assessment of the \patchgroup-enabled UW IMAP mail server
(\S\ref{sec:patchgroup:uwimap}) by comparing the number of block writes
that \Kudos\ makes relative to FreeBSD to move 100 emails. The test
selects the source mailbox (with 100 messages, sized 2kB each),
creates the new mailbox, copies each of the 100 messages to the new
mailbox, marks each source message for deletion, expunges the marked
messages, requests a check, and logs out. We compare using soft updates;
Figure~\ref{fig:imap-compare} shows the results.

\begin{figure}[t]
\centering
\begin{tabular}{@{}lrr@{}}
\textbf{System} & \textbf{Time} & \textbf{Writes} \\ \hline
% Results are from r3862

% NOFUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 11.4 [0.4] & 3,015 \\
\Kudos\ (meta journal) & 1.4 [0.4] & 33 \\
\Kudos\ (full journal) & 1.4 [0.4] & 33 \\ \hline

% FUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 27.5 [1.1] & 3,015 \\
\Kudos\ (meta journal) & 1.5 [0.4] & 32 \\
\Kudos\ (full journal) & 1.5 [0.4] & 32 \\ \hline

% without patchgroups, FUA
\Kudos\ (async) & 1.6 [0.3] & 2,503 \\
\Kudos\ (soft updates) & 64.9 [0.3] & 8,367 \\
\Kudos\ (meta journal) & 51.3 [0.4] & 7,111 \\
\Kudos\ (full journal) & 51.4 [0.4] & 7,117 \\ \hline

% WB
Linux (ext2) & 1.5 [0.3] & 2,503 \\
Linux (ext3 ordered) & 2.0 [0.3] & 3,025 \\
Linux (ext3 journal) & 1.8 [0.3] & 2,531 \\ \hline

% WT
Linux (ext2) & 16.7 [0.3] & 2,503 \\
Linux (ext3 ordered) & 23.9 [0.3] & 3,025 \\
Linux (ext3 journal) & 20.4 [0.3] & 2,531 \\ \hline
Linux (ext3 journal) & min fsyncs & ? \\
\end{tabular}
\caption{\label{fig:imap-compare} IMAP benchmark: move 1000 messages
  to a second folder. Times are in seconds, writes in number of requests.
  System CPU times are in square brackets.}
\end{figure}
