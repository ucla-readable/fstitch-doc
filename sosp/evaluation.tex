\section {Evaluation}
\label{sec:evaluation}

Our evaluation shows that a \Kudos\ \patch-based file system layer has
overall performance that is within reason, even though it is slower than
Linux by a nontrivial amount.  We also demonstrate the effectiveness of
\opgroups\ on some of our sample applications. All tests were run on a Dell
Precision 380 with a 3.2GHz Pentium 4 CPU, 2GB of RAM, and a Seagate
ST3320620AS 320GB 7200RPM SATA2 disk, using 10GB file systems.
%
All tests use a 10 GB file system.
%
Our tests use Linux 2.6.20.1 with ext2 and ext3, \Kudos\ with ext2 with
soft updates, and FreeBSD 6.0 with UFS in soft updates mode, all created
with default configurations.

Two tests are repeated throughout this section: first, we untar
the Linux 2.6.15 source code from \texttt{linux-2.6.15.tar} (218 MB), which is
already decompressed and cached in RAM. Second, we delete the resulting source
tree, after unmounting and remounting the file system.

\subsection {Optimization Benefits}

\Kudos\ benefits greatly from the optimizations discussed in
Section~\ref{sec:patch:optimizations}. The total number of \chdescs\ created,
amount of rollback data allocated, and system CPU time used are shown for the
untar and rm tests in Figure~\ref{f:optdata}, with all combinations of using
\nrb\ \chdescs\ and overlap merging. While both optimizations work well by
themselves, the combination of the two is particularly effective at reducing the
amount of rollback data.
%
The system time column shows time spent executing code in kernel space
during the untar or remove; this is mostly \Dodder\ overhead.  Linux's
system time numbers during a comparable test are much lower.  Profiling
numbers indicate optimization opportunities in some of \Dodder's auxiliary
libraries, such as its hash table, as well as more significant optimization
opportunities we hope to address in future work.


\begin{figure}[t]
\small
\begin{tabular}{@{}lrrr@{}}
%& \multicolumn{3}{c}{\textbf{Untar}} &
%\multicolumn{3}{c@{}}{\textbf{Delete}} \\
\textbf{Optimization}
        & \textbf{\# patches} & \textbf{Rollback data} & \textbf{System time} \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Untar test}\raise2pt\hbox{\strut}} \\
None
        & 537,989		& 458.64~MB             & 4.42~sec \\
Hard patches
        & 537,131               & 205.68~MB             & 4.53~sec \\
Overlap merging
        & 253,839               & 255.45~MB             & 3.58~sec \\
Both optimizations
        & 276,829               & 1.24~MB               & 3.58~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Rm test}\raise2pt\hbox{\strut}} \\
None
        & 193,062               & 3.17~MB               & 1.14~sec \\
Hard patches
        & 172,351               & 3.15~MB               & 1.08~sec \\
Overlap merging
        & 87,692                & 1.83~MB               & 0.85~sec \\
Both optimizations
        & 54,076                & 0.64~MB               & 0.75~sec \\
\end{tabular}
\caption{Effectiveness of \Kudos\ optimizations.  The combination of hard
patches and overlap merging removes almost half the patches and 99.73\% of
the rollback data required to untar Linux.}
\label{f:optdata}
\end{figure}


\begin{comment}
\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{opts-patches}
\includegraphics[width=\columnwidth]{opts-rollback}
\begin{tabular}{@{}l|r|r@{}}
Optimization & Untar (sys sec) & Delete (sys sec) \\ \hline\hline
None & 4.42 & 1.14 \\ \hline\hline
\Nrb\ \Chdescs{} & 4.53 & 1.08 \\
Overlap Merge & 3.58 & 0.85 \\ \hline\hline
HP $+$ OM & 3.58 & 0.75 \\
\end{tabular}
\caption{Effects of \nrb\ \chdescs\ with \nrb\ merging and overlap
merging for the untar and rm tests.}
\label{fig:opts}
\end{figure}
\end{comment}

\begin{comment}
\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{rb_chdesc_size}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:patchsize-histo} \Rb\ \chdesc\ size histogram for a sample
workload (extracting a large archive into ext2). All the \chdescs\ larger than
63 bytes have been optimized into \nrb\ \chdescs. \Rb\ \chdescs\ 4 bytes and
smaller account for about 51\% of all \rb\ \chdescs.}
\end{figure}
\end{comment}

\subsection {Microbenchmarks}
Our first microbenchmark measures the number of blocks written by Linux ext2
and ext3 and \Kudos\ ext2 with soft updates during the untar test. Linux ext2
writes 523,248 blocks; Linux ext3 writes 523,192; \Kudos\ writes 540,472.

We also tested that \Kudos's soft updates ext2 writes a similar number of blocks as FreeBSD's
soft updates UFS. In one test, we create 100 small files in a directory and
measure the number of blocks written to disk. \Kudos\ writes 122 blocks,
while FreeBSD writes 135 blocks.

Finally, Figure~\ref{fig:mergereq-cdf} plots a CDF of the sizes of disk
write requests during the untar test. Here we can see one likely contributing
factor to the speed difference between Linux and \Kudos: \Kudos\ makes over
twice as many requests to the disk. We suspect that this is due to a suboptimal
cache eviction algorithm, as described above.

\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{merge_cdf}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:mergereq-cdf} CDF of disk write request sizes for
  Linux ext2 and \Kudos\ ext2 during the untar test. Linux totals 2021
  requests to the disk, while \Kudos\ totals 4382 requests.}
\end{figure}

\subsection {Macrobenchmarks}
\label{sec:eval:macro}

\subsubsection{Untar and Delete}
\label{sec:eval:untardel}

Times to untar and remove our Linux tarball are listed in
Figure~\ref{fig:macro} for several systems, including time to fully sync
the changes to disk.

% make this into a table
\begin{figure}[t]
\centering{
\begin{tabular}{@{}lrr@{}}
System & Untar (sec) & Delete (sec) \\ \hline
\Kudos\ (SU) & 18.39 & 9.47 \\
\Kudos\ (async) & 3.88 & 6.94 \\ \hline
FreeBSD (SU) & 23.22 & 15.95 \\ 
FreeBSD (async) & 10.09 & 3.25 \\ \hline
Linux (ext2) & 5.27 & 4.43 \\
Linux (ext3) & 13.92 & 4.47 \\
\end{tabular}
}
\caption{\label{fig:macro} Untar and delete times.}
\end{figure}

\Kudos\ is about 21\% faster than FreeBSD using soft updates for
writes, and about 41\% faster for deletions.\footnote{Interestingly, FreeBSD 5.4
performs better than version 6.0 at these tests, particularly the delete test,
but \Kudos\ is still faster on the untar test.}
%
When compared to Linux ext3, \Kudos\ is about 32\% slower for writes, but many
times slower for deletions.
(A major cause of the slow delete performance is writing
updates to blocks which have been freed, which we have a plan to optimize.)
%
This demonstrates that the overhead of using \chdescs\ in \Kudos\ is not
entirely unreasonable, but has room for significant improvement.
%
%% While \Kudos\ does still have some CPU usage and I/O delay problems, its
%% performance has been steadily improving over time and we expect that it will
%% continue to improve as we optimize it further.
%
%% There are more optimization opportunities that can likely bring us much closer
%% in performance to Linux. 

\subsubsection {Postmark}
\label{sec:eval:postmark}

We next evaluate overall performance using the PostMark benchmark,
designed to simulate the small file workloads seen on email and
netnews servers~\cite{postmark}.
%
We use PostMark 1.5, configured to use 4kB reads and writes and to
create 500 files ranging in size from 500 B to 2 MB; perform 500
transactions consisting of file reads, writes, creates, and deletes;
and finally delete its files. PostMark is a single process, single
threaded program that performs these file system operations as quickly
as possible.
%
Figure~\ref{fig:postmark} shows the results.

\begin{figure}[t]
\centering
\begin{tabular}{@{}lr@{}}
System & Time (sec) \\ \hline
\Kudos\ & 46.6 \\ % r3266: 46.173 46.555 46.495 46.479 47.371
Linux (ext2) & 16.9 \\ % 10.602 16.983 17.033 16.905 16.798
Linux (ext3) & 19.6 \\ % 16.590 20.533 19.713 19.174 19.129
FreeBSD & 27.0 \\ 
\end{tabular}
\caption{PostMark times.}
\label{fig:postmark}
\end{figure}

\todo{Comment on benchmark.}

\subsection {Patchgroups}

%\subsubsection {gzip}

%\subsubsection {Subversion Case Study}
%
%Complexity of implementation, reliance on specific FS semantics (i.e. ext3)
%even with all that jumping through hoops - broken on NTFS, for example.
%Straightforward to get correctness with \opgroups; counts only on a simple API.

\subsubsection {UW IMAP Case Study}
\label{sec:evaluation:uwimap}
To assess the \opgroup-enabled UW IMAP mail server
(\S\ref{sec:opgroup:uwimap}) we compare the number of block writes
that \Kudos\ makes relative to FreeBSD to move 100 emails. The test
selects the source mailbox (with 100 messages, sized 2kB each),
creates the new mailbox, copies each of the 100 messages to the new
mailbox, marks each source message for deletion, expunges the marked
messages, requests a check, and logs out. We compare using soft updates;
Figure~\ref{fig:imap-compare} shows the results.

\begin{figure}[t]
\centering{
\begin{tabular}{@{}lr@{}}
System & \# writes (blocks) \\ \hline
\Kudos\ (with \opgroups) & 919 \\
\Kudos\ (w/o \opgroups) & 1537 \\
FreeBSD 5.4 & 2200 \\
\end{tabular}
}
\caption{\label{fig:imap-compare} Number of block writes to move 100
  IMAP messages.}
\end{figure}
