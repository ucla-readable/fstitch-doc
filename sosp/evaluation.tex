\section {Evaluation}
\label{sec:evaluation}

Our evaluation shows that a \Kudos\ \patch-based file system layer has
overall performance that is within reason, even though it is slower than
Linux in some benchmarks.  We also demonstrate the effectiveness of
\patchgroups\ on some of our sample applications. All tests were run on a
Dell Precision 380 with a 3.2GHz Pentium 4 CPU, 2GB of RAM, and a Seagate
ST3320620AS 320GB 7200RPM SATA2 disk.
%
All tests use a 10 GB file system.
%
%Our tests use Linux 2.6.20.1 with ext2 and ext3, \Kudos\ with ext2 with
%soft updates and journaling, and FreeBSD 6.0 with UFS in soft updates mode,
%all created with default configurations.
Our tests use Linux 2.6.20.1 with ext2/3 and \Kudos\ with ext2 with
soft updates and journaling, both created with default configurations.

Two simple tests are repeated throughout this section: first, we untar
the Linux 2.6.15 source code from \texttt{linux-2.6.15.tar} (218 MB), which is
already decompressed and cached in RAM. Second, we delete the resulting source
tree, after unmounting and remounting the file system.

\subsection {Optimization Benefits}

\Kudos\ benefits greatly from the optimizations discussed in
Section~\ref{sec:patch:optimizations}. The total number of \patches\ created,
amount of rollback data allocated, and system CPU time used are shown for the
untar and rm tests in Figure~\ref{f:optdata}, with all combinations of using
\nrb\ \patches\ and overlap merging. While both optimizations work well by
themselves, the combination of the two is particularly effective at reducing the
amount of rollback data.
%
The system time column shows time spent executing code in kernel space
during the untar or remove; this is mostly \Kudos\ overhead.  Linux's
system time numbers during a comparable test are much lower.  Profiling
numbers indicate optimization opportunities in some of \Kudos's auxiliary
libraries, such as its hash table, as well as more significant optimization
opportunities we hope to address in future work.


\begin{figure}[t]
\small
\begin{tabular}{@{}lrrr@{}}
%& \multicolumn{3}{c}{\textbf{Untar}} &
%\multicolumn{3}{c@{}}{\textbf{Delete}} \\
\textbf{Optimization}
        & \textbf{\# \patches} & \textbf{Rollback data} & \textbf{System time} \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Untar test}\raise2pt\hbox{\strut}} \\
None
        & 537,989		& 458.64~MB             & 4.42~sec \\
\Nrb\ \patches\
        & 464,825               & 205.62~MB             & 3.30~sec \\
Overlap merging
        & 112,634               & 254.00~MB             & 3.04~sec \\
Both optimizations
        &  67,478               & 0.34~MB               & 2.56~sec \\
\hline
\multicolumn{4}{@{}c@{}}{\textbf{Delete test}\raise2pt\hbox{\strut}} \\
None
        & 193,062               & 3.17~MB               & 1.14~sec \\
\Nrb\ \patches\
        & 41,108                & 0.91~MB               & 0.35~sec \\
Overlap merging
        & 54,685                & 0.93~MB               & 0.55~sec \\
Both optimizations
        &  1,800                & 0.00~MB               & 0.32~sec \\
\end{tabular}
\caption{Effectiveness of \Kudos\ optimizations.  The combination of \nrb\
\patches\ and overlap merging removes 87\% to 99\% of the \patches\ and
99.93\% to 100\% of the rollback data required to untar Linux.}
\label{f:optdata}
\end{figure}


\begin{comment}
\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{opts-patches}
\includegraphics[width=\columnwidth]{opts-rollback}
\begin{tabular}{@{}l|r|r@{}}
Optimization & Untar (sys sec) & Delete (sys sec) \\ \hline\hline
None & 4.42 & 1.14 \\ \hline\hline
\Nrb\ \Patches\ & 4.53 & 1.08 \\
Overlap Merge & 3.58 & 0.85 \\ \hline\hline
HP $+$ OM & 3.58 & 0.75 \\
\end{tabular}
\caption{Effects of \nrb\ \patches\ with \nrb\ merging and overlap
merging for the untar and rm tests.}
\label{fig:opts}
\end{figure}
\end{comment}

\begin{comment}
\begin{figure}[t]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{rb_patch_size}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:patchsize-histo} \Rb\ \patch\ size histogram for a sample
workload (extracting a large archive into ext2). All the \patches\ larger than
63 bytes have been optimized into \nrb\ \patches. \Rb\ \patches\ 4 bytes and
smaller account for about 51\% of all \rb\ \patches.}
\end{figure}
\end{comment}

\subsection {Benchmarks}
\label{sec:eval:bench}

%Our first microbenchmark measures the number of blocks written by Linux ext2
%and ext3 and \Kudos\ ext2 with soft updates during the untar test. Linux ext2
%writes 523,248 blocks; Linux ext3 writes 523,192; \Kudos\ writes 540,472.

%We also tested that \Kudos's soft updates ext2 writes a similar number of
%blocks as FreeBSD's soft updates UFS. In one test, we create 100 small files
%in a directory and measure the number of blocks written to disk. \Kudos\
%writes 122 blocks, while FreeBSD writes 135 blocks.

Times to untar and remove our Linux tarball are listed in
Figure~\ref{fig:tar_rm_time} for several systems, including time to fully sync
the changes to disk.

% make this into a table
\begin{figure}[t]
\centering{
\begin{tabular}{@{}lrr@{}}
System & Untar (sec) & Delete (sec) \\ \hline
% Results are from r3652
\Kudos\ (soft updates) & 5.90 [2.56] & 1.03 [0.32] \\
\Kudos\ (meta journal) & 8.70 [4.84] & 1.65 [0.75] \\
\Kudos\ (full journal) & 13.40 [5.46] & 1.63 [0.77] \\
\Kudos\ (async) & 4.38 [1.84] & 0.80 [0.29] \\ \hline
%FreeBSD (soft updates) & 23.22 & 15.95 \\ 
%FreeBSD (async) & 10.09 & 3.25 \\ \hline
Linux (ext2) & 4.50 [0.72] & 4.57 [0.16] \\
Linux (ext3 ordered) & 13.86 [1.01] & 4.29 [0.25] \\
Linux (ext3 journal) & 10.89 [1.12] & 4.32 [0.26] \\
\end{tabular}
}
\caption{\label{fig:tar_rm_time} Untar and delete times. System CPU times are
in square brackets.}
\end{figure}

At the untar test, the \Kudos\ async mode is faster than Linux ext2, which
provides a similar consistency guarantee. The \Kudos\ soft updates mode is
only 15\% slower but provides a much stronger guarantee, and it is about 2.3
times as fast as the widely used Linux ext3 ordered mode which does provide a
comparable consistency guarantee. The \Kudos\ metadata journal mode is faster
than both Linux ext3 journal modes, though \Kudos\ full journaling is slower.
At the remove test, all \Kudos\ modes are substantially faster than all Linux
modes, due to differences in how \Kudos\ allocates inodes and blocks during
the untar test.

When looking only at the System CPU time, however, \Kudos\ can use up to
5.6 times as much CPU as a similar Linux mode. This effect is partially
mitigated by smaller I/O times, but it is an important concern and has
been the focus of most of our later optimizations.

%This demonstrates that the overhead of using \patches\ in \Kudos\ is not
%entirely unreasonable, but has room for significant improvement.
%
%% While \Kudos\ does still have some CPU usage and I/O delay problems, its
%% performance has been steadily improving over time and we expect that it will
%% continue to improve as we optimize it further.
%
%% There are more optimization opportunities that can likely bring us much closer
%% in performance to Linux. 

We next evaluate overall performance using the PostMark benchmark,
designed to simulate the small file workloads seen on email and
netnews servers~\cite{postmark}.
%
We use PostMark 1.5, configured to use 4kB reads and writes and to
create 100 files ranging in size from 500 B to 16 MB; perform 500
transactions consisting of file reads, writes, creates, and deletes;
and finally delete its files. PostMark is a single process, single
threaded program that performs these file system operations as quickly
as possible.

Finally, we evaluate performance using a modified Andrew benchmark,
which simulates a development workstation by extracting some source
code, scanning and reading the directory tree with several text
processing utilities, and then compiling the source code. The source
code we use is the Ion window manager, version 2-20040729.

Figure~\ref{fig:postmark} shows the times to run PostMark and the Andrew
benchmark, and then synchronize their results to disk.

\begin{figure}[t]
\centering
\begin{tabular}{@{}lrr@{}}
System & PostMark (sec) & Andrew (sec) \\ \hline
% Results are from r3652
\Kudos\ (soft updates) & 129.72 [50.88] & 44.90 [5.28] \\
\Kudos\ (meta journal) & 210.36 [111.50] & 37.46 [5.31] \\
\Kudos\ (full journal) & 240.28 [89.64] & 37.93 [5.38] \\
\Kudos\ (async) & 121.74 [26.39] & 37.20 [5.30] \\ \hline
Linux (ext2) & 64.91 [4.93] & 37.30 [4.86] \\
Linux (ext3 ordered) & 67.12 [9.13] & 37.14 [4.89] \\
Linux (ext3 journal) & 125.13 [11.18] & 37.83 [4.99] \\
\end{tabular}
\caption{PostMark and Andrew benchmark times. System CPU times are in
square brackets.}
\label{fig:postmark}
\end{figure}

%\Kudos's PostMark performance, compared to Linux and FreeBSD, falls
%into the middle of \S\ref{sec:eval:untardel}'s untar and delete
%benchmarks. As PostMark combines file creation and deletion, its
%results follow for similar reasons as the untar and delete benchmarks'.

\Kudos\ appears to do well at the Andrew benchmark in all but the soft
updates case, where it spends a larger amount of I/O time than the other
modes. However, its performance at PostMark is much worse, generally
twice as slow as Linux with a comparable consistency guarantee, and it
exhibits the same larger CPU time as the untar and delete tests. The
extra I/O time in this case is due to the fact that Linux is normally
able to recognize operations that cancel out in the file system cache,
and avoid writing them to disk altogether. \Kudos\ does not yet support
this feature, so it writes many more unnecessary blocks.

\subsection {Correctness}
\label{sec:eval:correctness}

In order to check that we had implemented the soft updates rules correctly, we
implemented a \Kudos\ module which crashes the operating system, without
giving it a chance to synchronize its buffers, at a random time during the
untar test.
%
In \Kudos\ asynchronous mode, after crashing, fsck nearly always reported that
the file system contained many references to inodes that had been deleted: the
file system was corrupt.
%
With our soft updates dependencies, the file system was always mostly
consistent: fsck reported that inode reference counts were higher than the
correct values (an expected discrepancy after a soft updates crash).

\subsection {\Patchgroups}

%\subsubsection {gzip}

%\subsubsection {Subversion Case Study}
%
%Complexity of implementation, reliance on specific FS semantics (i.e. ext3)
%even with all that jumping through hoops - broken on NTFS, for example.
%Straightforward to get correctness with \patchgroups; counts only on a simple API.

\label{sec:evaluation:uwimap}
We implemented a preliminary assessment of the \patchgroup-enabled UW IMAP mail server
(\S\ref{sec:patchgroup:uwimap}) by comparing the number of block writes
that \Kudos\ makes relative to FreeBSD to move 100 emails. The test
selects the source mailbox (with 100 messages, sized 2kB each),
creates the new mailbox, copies each of the 100 messages to the new
mailbox, marks each source message for deletion, expunges the marked
messages, requests a check, and logs out. We compare using soft updates;
Figure~\ref{fig:imap-compare} shows the results\footnote{TERTL readers:
we plan to measure time for this and the other patchgroup tests and
compare against Linux ext2 and ext3.}

\begin{figure}[t]
\centering{
\begin{tabular}{@{}lr@{}}
System & \# writes (blocks) \\ \hline
\Kudos\ (with \patchgroups) & 919 \\
\Kudos\ (w/o \patchgroups) & 1537 \\
FreeBSD 5.4 & 2200 \\
\end{tabular}
}
\caption{\label{fig:imap-compare} Number of block writes to move 100
  IMAP messages.}
\end{figure}
