\subsection{UFS}
\label{sec:using:ufs}

\Kudos\ supports a version of UFS (Unix File System), the modern incarnation of
the Fast File System~\cite{mckusick84fast} used in 4.2 BSD. UFS is of
particular interest because it is the only file system that has been extended
with both soft updates and journaling.~\cite{seltzer00journaling} We chose UFS1
over UFS2, as UFS1 is well established and more widely supported. We describe
UFS as an example of a complete and relatively complex file system.

The UFS \module\ is implemented at the \LFS\ interface. This keeps properties
specific to UFS (such as the UFS on-disk format and rules governing block
allocation) hidden within the file system \module. For instance, UFS uses 2KB
\emph{fragments} to store small files efficiently. Once a file gets big enough
to require the use of indirect blocks, UFS changes its allocation policy and
starts allocating 16KB \emph{blocks}, where a block is made up of 8 aligned and
contiguous fragments. Our UFS \module\ implements this by using fragments as
the basic block size. For large files, the UFS \module\ internally allocates a
block, but returns only the first fragment in that block at the \LFS\ level.
The next 7 allocation calls will simply return the subsequent fragments in the
already allocated block. In this way, UFS can stay consistent internally
without special support from other \Kudos\ modules.

The UFS \module\ creates \chdescs\ for all its changes to the disk, and
connects them to form configurations that achieve soft updates consistency.
Unlike FreeBSD's soft updates implementation, once the dependencies have been
hooked up, UFS no longer needs to concern itself with the \chdescs\ it has
created. The block device subsystem will track and enforce the \chdesc\
orderings.

In order to implement soft update ordering, we examined the places where UFS
created \chdescs. With the consistency rules for soft updates in mind, we
carefully connected the \chdescs\ created within each \LFS\ call. Once
satisfied that all \LFS\ calls in the UFS \module\ followed soft updates
ordering, we counted on UHFS (\S\ref{sec:modules:uhfs}) to connect the
\chdescs\ generated by the \LFS\ calls in the appropriate soft updates
configuration to complete the \chdesc\ graphs.

\subsubsection {Modularity}
Although the UFS implementation must be somewhat monolithic in order to
understand the interlinked UFS-specific disk structures, we would like to take
advantage of modularity to allow for flexibility and encapsulation. UFS is
divided into modules at boundaries that expose naturally replaceable policies,
such as resource allocation and directory entry traversal. We use specialized
interfaces specific to UFS, because these interfaces do not necessarily apply
to all file systems in general (see Figure~\ref{fig:moduleinterface}).
Currently we have two allocator modules as a proof of concept for modularity.

\begin{figure}[htb]
\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{alltt}
int \textbf{find_free_block}(fdesc_t * file, int purpose);
int \textbf{find_free_frag}(fdesc_t * file, int purpose);
int \textbf{find_free_inode}(fdesc_t * file, int purpose);
\end{alltt}
\end{scriptsize}
\vspace{-0.5\baselineskip}
\caption{\label{fig:moduleinterface} UFS allocator module interface.}
\end{figure}

%The UFS cylinder group module interface regulates access to the cylinder
%groups. While there is unrestricted read access to cylinder groups, the
%interface limits write access to certain fields within the \emph{UFS\_cg}
%struct. This is because, under normal operations, fields like the number of
%data blocks per cylinder group remain constant. The cylinder group module can
%also define the policy for when changes to the cylinder group are written to
%disk. It can, for example, make the policy ``write-through'' and have all
%changes immediately go to disk. However, choosing this policy means that on
%every block allocation, UFS needs to write \emph{cg\_rotor}, the position of
%the last used block, to disk. To avoid performance hits like this, we
%implemented the ``write-back'' policy instead. To support flushing dirty data
%to disk, the cylinder group module interface also has a sync call. Similarly,
%the super block module interface controls access to the super block.

The UFS allocator module interface has methods for allocating blocks,
fragments, and inodes. All three methods take in a \emph{file descriptor} and a
\emph{purpose} variable. The UFS \emph{file descriptor} contains all relevant
information pertaining to a given file, including an in-memory copy of the
file's inode. The intent of the \emph{purpose} variable is to provide hints to
the allocator about how the newly allocated resource will be used.  Given these
two pieces of information, as well as cylinder group information from the
previously mentioned module, UFS allocator modules can make informed decisions
to allocate resources in an efficient manner. For instance, given the status
for all cylinder groups, a block allocator function can examine the blocks
previously allocated to a given file and figure out what block to allocate next
based on the strategies used by FreeBSD.
