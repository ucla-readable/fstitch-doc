% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section{\Modules}
\label{sec:modules}

\begin{comment}
This section describes several \Kudos\ \modules\ which contribute significantly
to the overall functionality of \Kudos, or which demonstrate unique or
important capabilities of \patches\ and the \module\ system. The journal
\module\ has already been described (in \S\ref{sec:using:journal}), while
others like the write-through cache, partitioner, and memory block device, have
functions which are fairly obvious from their names and need no further
description.
\end{comment}

%% \subsection {Interfaces}
\label{sec:modules:interfaces}

\begin{comment}
New \modules\ are
simple to write, and by changing the \module\ arrangement, a broad range of
behaviors can be implemented. It's also easy to tell what behavior a given
arrangement will give just by looking at the connections between the \modules.
\end{comment}

A complete \Kudos\ configuration is composed of many \modules, making it
in some sense a finer-grained variant of a stackable file system.
%
There are three major types of \modules.
%
Closest to the disk are block device (BD) \modules, which have a fairly
conventional block device interface with interfaces such as ``read block'' and
``flush''. 
%
Closest to the system call interface are \emph{common file system} (CFS)
\modules, which have an interface similar to VFS~\cite{kleiman86vnodes}. 
%
\Kudos\ also supports an intermediate interface between BD and CFS.
%
This \emph{low-level file system} (\LFS) interface helps divide file system
implementations into code common across block-structured file systems and
code specific to a given file system layout.
%
\begin{comment}
A
\Kudos\ file system designer combines modules with all three interfaces in many
ways -- a departure from stackable file systems, which act only at the VFS/CFS
layer. \Kudos\ \modules\ are implemented in C using structures of function
pointers to achieve object oriented behavior, very much like the rest of the
Linux kernel.
\end{comment}
%
The \LFS\ interface has functions to allocate blocks, add blocks to files,
allocate file names, and other file system micro-operations. A \module\
implementing the \LFS\ interface defines how bits are laid out on the disk, but
doesn't have to know how to combine the micro-operations into larger, more
familiar file system operations. A generic CFS-to-\LFS\ \module\ called UHFS
(``universal high-level file system'') decomposes the larger file write, read,
append, and other standard operations into \LFS\ micro-operations. 
%
File system extensions like those often implemented by stackable file
systems would generally use the CFS interface; for example, we wrote a
simple CFS module that provides case-insensitive access to a case-sensitive
file system.
%
File system implementations, such as our ext2 and UFS implementations, use
the \LFS\ interface.


\Patches\ are explicitly part of the \LFS\ interface.
%
Every \LFS\ function that might modify the file system takes a
\texttt{\textit{patch\char`\_t **p}} argument.
%
Before the function is called, \texttt{*p} should be set to the \patch,
if any, on which the modification should depend;
%
when the function returns, \texttt{*p} will be set to some \patch\
corresponding to the modification itself.
%
(\Noop\ \patches\ allow this interface to generalize to multiple
dependencies.)
%
For example, this function is called to append a block to an \LFS\ inode
(which is called ``\verb+fdesc_t+''):

\begin{small}
\begin{alltt}
int (*append_file_block)(LFS_t *module, 
   fdesc_t *file, uint32_t block, patch_t **p);
\end{alltt}
\end{small}

\noindent%
This design lets \LFS\ modules examine and modify the dependency structure.

%% \input{uhfs}

\input{wbcache}

\subsection{Loopback Module}
\label{sec:modules:loop}

The loopback module is a BD module that uses a file in an \LFS\ module as
its underlying data store. It is very similar to the device of the same
name in Linux, but with one critical difference: it is aware of \patches.
%
The loopback module preserves its file system's dependencies and forwards
them to its underlying data store.
%
As a result, the data store will honor those dependencies and preserve the
loopback file system's consistency, even if the data store would normally
provide no guarantees for consistency of file system data (e.g., it used
metadata-only journaling).

\begin{figure}[t]
  \centering
  \includegraphics[height=2.5in]{fig/figures_1}
  \caption{A running \Kudos\ configuration. {\it/} is a soft updated
    file system on an IDE drive; {\it/loop} is an externally journaled
    file system on loop devices.}
  \label{fig:kfs-graph}
\end{figure}

Figure~\ref{fig:kfs-graph} shows an example configuration using the
loopback module.
%
A file system image is mounted with an external journal, both of
which are loopback block devices stored on the root file system (which uses
soft updates). The journaled file system's ordering requirements are sent
through the loopback module as \patches, allowing dependency information to be
maintained across boundaries that might otherwise lose that information. In
contrast, without \patches\ and the ability to forward \patches\ through
loopback devices, BSD cannot express soft updates' consistency requirements
through loopback devices. The \modules\ in Figure~\ref{fig:kfs-graph} are a
complete and working \Kudos\ configuration, and although the use of a loopback
device is somewhat contrived in the example, they are increasingly being used in
conventional operating systems. For instance, Mac OS X uses them in order to
allow users to encrypt their home directories.

\begin{comment}
An example configuration taking advantage of this ability could be a file
system image mounted with an external journal, both of which are loopback block
devices stored on the root file system (which could use soft updates). The
journaled file system's ordering requirements are sent through the loopback
device as \patches, allowing dependency information to be maintained across
boundaries that might otherwise lose that information. In contrast, without
\patches\ and the ability to forward \patches\ through loopback devices, BSD
cannot express soft updates' consistency requirements through loopback devices.
Although the use of a loopback device is somewhat contrived in the example,
they are increasingly being used in conventional operating systems. For
instance, Mac OS X uses them in order to allow users to encrypt their home
directories.
\end{comment}

\subsection{ext2 and UFS}

\Kudos\ currently has \modules\ that implement two file system types, Linux
ext2 and 4.2 BSD UFS (Unix File System, the modern incarnation of the Fast File
System~\cite{mckusick84fast}).
%
Both of these \modules\ initially generate dependencies arranged according to the
soft updates rules; other dependency arrangements are achieved by transforming these.
%
% We briefly describe these \modules\ as examples of complete and relatively
% complex file systems.
%
To the best of our knowledge, our implementation of ext2 is the first to provide
soft updates consistency guarantees.
%
%% UFS is of particular interest because it is the only file system that has been
%% extended with both soft updates and journaling.~\cite{seltzer00journaling}
%
% We chose UFS1 over UFS2, as UFS1 is well established and more widely
% supported.
%
We verified that file systems generated by our modules are considered
correct by their reference implementations on FreeBSD and Linux by mounting
and running \emph{fsck} on \Kudos-generated disk images.

Both \modules\ are implemented at the \LFS\ interface. 
%
%% This keeps properties
%% specific to the file system (such as the on-disk format and rules governing
%% block allocation) hidden within the \module. 
%
The \modules\ create \patches\ for all their changes to the disk and
connect them to form subgraphs that enforce the soft updates
rules~\cite{ganger00soft} as applied to each file system. 
%
The UHFS \module\ is also aware of soft updates order when necessary; when
it implements a single operation using multiple \LFS\ calls, it hooks the
resulting \patches\ up in the correct order.
%
Unlike FreeBSD's soft updates implementation, once the dependencies have
been hooked up, the ext2 and UFS \modules\ no longer need to concern
themselves with their \patches, as the block device subsystem tracks and
enforces the dependency orderings.

\begin{comment}
The UFS \module\ provides a good demonstration of some of the flexibility of the
\module\ interfaces in \Kudos. For instance, UFS uses 2KB \emph{fragments} to
store small files efficiently. Once a file gets big enough to require the use of
indirect blocks, UFS changes its allocation policy and starts allocating 16KB
\emph{blocks}, where a block is made up of 8 aligned and contiguous fragments.
Our UFS \module\ implements this by using fragments as the basic block size. For
large files, the UFS \module\ internally allocates a block, but returns only the
first fragment in that block at the \LFS\ level. The next 7 allocation calls
will simply return the subsequent fragments in the already allocated block.
% In this way, the UFS \module\ can stay consistent internally without special
% support from other \Kudos\ modules.
\end{comment}

%\input{ext2}
%\input{ufs}

\begin{comment}
\subsection{Case Insensitivity}
\label{sec:modules:icase}

\Kudos\ provides a case insensitivity \module\ at the CFS layer. It allows file
systems such as UFS and ext2, which inherently handle filenames case
sensitively, to become case insensitive. If a user needs to run an application
that expects the underlying filenames to be case insensitive on top of a case
sensitive file system, they can simply add this \module\ to the \Kudos\
\module\ graph. By allowing a \module\ to intercept actions between the CFS and
\LFS\ layers, filename transformations can be made transparently for the user
regardless of the on-disk storage format of the actual filename.
\end{comment}
