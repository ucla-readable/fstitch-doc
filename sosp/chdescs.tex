\section {\ChDescs}
\label{sec:chdescs}

\newcommand{\ChAll}{\ensuremath{\textit{All}}}
\newcommand{\ChAllB}[1]{\ensuremath{\textit{All}[#1]}}
\newcommand{\ChMem}{\ensuremath{\textit{Mem}}}
\newcommand{\ChMemB}[1]{\ensuremath{\textit{Mem}[#1]}}
\newcommand{\ChDisk}{\ensuremath{\textit{Disk}}}
\newcommand{\ChDiskB}[1]{\ensuremath{\textit{Disk}[#1]}}
\newcommand{\ChInf}{\ensuremath{\textit{Inf}}}
\newcommand{\ChInfB}[1]{\ensuremath{\textit{Inf\/}[#1]}}
\newcommand{\ChNrb}{\ensuremath{\textit{\Nrb}}}
\newcommand{\ChNrbB}[1]{\ensuremath{\textit{\Nrb}[#1]}}

\newcommand{\Before}[1]{\ensuremath{\textit{Pre}[#1]}}
\newcommand{\BeforeS}[1]{\ensuremath{\textit{Pre}^*[#1]}}
\newcommand{\After}[1]{\ensuremath{\textit{Post}[#1]}}
\newcommand{\AfterS}[1]{\ensuremath{\textit{Post}^*[#1]}}

\newcommand{\statenone}{\ensuremath{\textit{cached}}}
\newcommand{\stateinf}{\ensuremath{\textit{inflight}}}
\newcommand{\statedisk}{\ensuremath{\textit{ondisk}}}

% {{{ fig:chdesc
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct patch {
    bdev_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct patch_queue *leaders;
    uint32_t nleaders[NBDLEVEL];
    patch_t * ddesc_ready_next;
    patch_t ** ddesc_ready_prev;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}
% }}}

% {{{ fig:chdapi
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
int \textbf{patch_create_byte}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_create_bit}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint32_t xor,
    patch_t **head);
int \textbf{patch_create_empty}(
    bdev_t *owner, patch_t **tail,
    size_t nheads, patch_t * heads[]);
int \textbf{patch_create_diff}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_add_depend}(
    patch_t *\after, patch_t *\before);
void \textbf{patch_remove_depend}(
    patch_t *\after, patch_t *\before);
int \textbf{patch_apply}(patch_t *patch);
int \textbf{patch_rollback}(patch_t *patch);
int \textbf{patch_satisfy}(patch_t *patch);
int \textbf{patch_push_down}(
    bdev_t *current_bd, bdesc_t *current_block,
    bdev_t *target_bd, bdesc_t *target_block);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}
% }}}

The fundamental new abstraction in \Kudos\ is called a \chdesc. Each in-memory
modification to a cached disk block has an associated \chdesc. A \chdesc's
\emph{\befores} point to other \chdescs\ that must precede it to stable storage;
the other \chdescs\ which point to it as a \before\ are its \emph{\afters}. A
\chdesc\ can be applied or reverted to switch the cached block's state between
old and new.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows much of the API for working with them. The ability
to revert and re-apply \chdescs\ is inspired by soft updates dependencies, but
generalized so that it is not specific to any particular file system. \Chdesc\
dependencies can create cyclic dependencies among blocks. \Chdescs\ themselves
are not allowed to form cycles to ensure that they can always be written to disk
in an order which does not violate the dependency graph. To break block-level
cycles, some \chdescs\ may need to be reverted, or ``rolled back,'' in order to
first write other \chdescs\ on the same block, just as in soft updates.

\Kudos\ \modules\ change blocks by attaching \chdescs\ to them, using functions
such as \texttt{patch\_create\_byte}. Most file system \modules\ initially
generate \chdescs\ whose dependencies impose soft-update-like ordering
requirements (see \S\ref{sec:using:softupdate}). These \chdescs\ are then passed
down, through other \modules, in the general direction of the disk. The
intervening \modules\ can inspect, delay, and even modify them before passing
them on further. For instance, the write-back cache \module\
(\S\ref{sec:using:wbcache}), essentially a buffer cache, holds on to blocks and
their \chdescs\ instead of forwarding them immediately. Finally, \chdescs\ are
\emph{satisfied} when their associated data reaches stable storage.

\input{model}
\input{noop}
\input{readylist}
\input{nrb}
\input{merge}
\input{chdescdiscuss}
