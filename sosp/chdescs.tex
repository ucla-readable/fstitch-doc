\section {\ChDescs}
\label{sec:chdescs}

% {{{ fig:chdesc
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct patch {
    bdev_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct patch_queue *leaders;
    uint32_t nleaders[NBDLEVEL];
    patch_t * ddesc_ready_next;
    patch_t ** ddesc_ready_prev;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}
% }}}

Each in-memory modification to a cached disk block has an associated \chdesc. A
\chdesc's \emph{\befores} point to other \chdescs\ that must precede it to
stable storage; the \chdesc\ is then one of their \emph{\afters}. A \chdesc\ can
be applied or reverted to switch the cached block's state between old and new.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows much of the API for working with them. The ability
to revert and re-apply \chdescs\ is inspired by soft updates dependencies, but
generalized so that it is not specific to any particular file system.
%
\Chdesc\ dependencies can create cyclic dependencies among blocks. \Chdescs\
themselves are not allowed to form cycles to ensure that they can always be
written to disk in an order which does not violate the dependency graph. This
property is the first \chdesc\ invariant:
\cdinvar{acyclic}{\Chdesc\ dependency graphs are acyclic.}
%
To break block-level cycles, some \chdescs\ may need to be reverted, or ``rolled
back,'' in order to first write other \chdescs\ on the same block. To ensure a
rollback operation results in a well-defined block state, we have our second
\chdesc\ invariant: \cdinvar{rollback}{A rolled back \chdesc{}'s \afters\ are
rolled back\todo{Be more precise to be correct.}.}

% {{{ fig:chdapi
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
int \textbf{patch_create_byte}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_create_bit}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint32_t xor,
    patch_t **head);
int \textbf{patch_create_empty}(
    bdev_t *owner, patch_t **tail,
    size_t nheads, patch_t * heads[]);
int \textbf{patch_create_diff}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_add_depend}(
    patch_t *\after, patch_t *\before);
void \textbf{patch_remove_depend}(
    patch_t *\after, patch_t *\before);
int \textbf{patch_apply}(patch_t *patch);
int \textbf{patch_rollback}(patch_t *patch);
int \textbf{patch_satisfy}(patch_t *patch);
int \textbf{patch_push_down}(
    bdev_t *current_bd, bdesc_t *current_block,
    bdev_t *target_bd, bdesc_t *target_block);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}
% }}}

\Kudos\ \modules\ change blocks by attaching \chdescs\ to them, using functions
such as \texttt{patch\_create\_byte}.
%
Most file system modules initially generate \chdescs\ whose dependencies impose
soft-update-like ordering requirements (see \S\ref{sec:using:softupdate}).
These \chdescs\ are then passed down, through other modules, in the general
direction of the disk. The intervening \modules\ can inspect, delay, and even
modify them before passing them on further. For instance, the write-back cache
\module\ (\S\ref{sec:modules:wbcache}), essentially a buffer cache, holds on to
blocks and their \chdescs\ instead of forwarding them immediately.
% Each delay-inducing \module\ increases its \module\ level by one over the
% module(s) it uses, starting at zero.
%
When writing a block and associated \chdescs, the write-back cache enforces an
order consistent with the \chdesc\ dependency information. Specifically,
\cdinvar{before-levels}{The \befores\ of a \chdesc\ at level $l$ are at levels
$\leq l$.\todo{we have not yet defined levels, and probably should never define
or mention them}}

When a \module\ asynchronously writes the data associated with a set of
\chdescs\ to stable storage it marks the \chdescs\ as \emph{in flight} to
indicate that the \chdescs\ are considered to still have their previous,
higher, level. Their \afters\ will therefore remain at that level (or higher),
thus correctly implementing the dependency structure. A \chdesc\ is
\emph{satisfied} when its associated data reaches stable storage.
\todo{mention NCQ and FUA/wtcache, safe reordering, remove levels}

Each \chdesc\ on a block may or may not be visible to a given \module. For
example, modules that respond to user requests generally view the most current
state of every block -- the block with all \chdescs\ applied. However, a
write-back cache may choose to write some \chdescs\ on a block while reverting
others, since those others currently have unsatisfied \befores. In this case,
\modules\ below the write-back cache should view the unsatisfied \chdescs\ in
the reverted state.
%
\Kudos\ provides a block revisioning library function that automatically rolls
back those \chdescs\ that should not be visible at a particular \module, and
then rolls them forward again after that \module\ is done with the block.

% {{{ sec:chdescs:noop
\subsection{\Noop\ \ChDescs}
\label{sec:chdescs:noop}
\Chdescs\ as so far described can be tedious and inefficient to manage when
dealing with large sets of them corresponding to file system operations. For
instance, if writing some file \texttt{\after.txt} is to depend on writing some
other file \texttt{\before.txt}, it will be inconvenient to keep arrays of all
the \chdescs\ corresponding to the two operations and inefficient to store the
potentially quadratic number of edges in the \chdesc\ graph.

To solve this problem, we introduce an additional type of \chdesc. The
prototypical \chdesc\ corresponds to some change on disk, but \Kudos\ also
supports \aemphnoop\ \chdesc\ type, which doesn't change the disk at all.
\Noop\ \chdescs\ can have \befores, like other \chdescs, but they don't need to
be written to disk: they are trivially satisfied when all of their \befores\ are
satisfied. Thus, they can be used to ``stand for'' entire sets of other changes.
%
This capability is extremely useful, and is used by most operations on disk
structures so that a single \chdesc\ can be returned that depends on the whole
change. Likewise, \anoop\ \chdesc\ can be passed in as a parameter to a disk
operation to make the whole operation depend on a set of other changes. \Noop\
\chdescs\ allow dependencies between sets with only a linear number of
dependency edges in the \chdesc\ graph, and without having to pass around arrays
of \chdescs.
%
The cost is that some functions may have to traverse trees of \noop\ \chdescs\
to determine true dependencies.
%
% FIXME: move this into the precalculation section?
% \Anoop\ \chdesc's level is defined to be the max level of its \befores;
% in effect, propagating \anoop\ \chdesc's \befores\ to its \afters.

Modules can also use \noop\ \chdescs\ to \emph{prevent} changes from being
written. A \emph{managed} \noop\ \chdesc\ must be explicitly satisfied; any
changes that depend on that \noop\ \chdesc\ are delayed until the owning module
explicitly satisfies it. This is used, for instance, by the journal \module\
(\S\ref{sec:using:journal}) to prevent a transaction's \chdescs\ from
being written before the journal commits.
% }}}

% {{{ formalisms
\subsection{Initial Formalisms}

\noindent\\ Invariants:
\cdinvar{a}{If \indirdepends{a}{b} then \notindirdepends{b}{a}.}

\cdinvar{b}{If \(\indirdepends{a}{b} \land \inset{a}{\psetinflight{t}}\)
then \(\inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}}
\land \blockof{a} = \blockof{b})\).}

\noindent Want invariant:
\cdinvar{c}{If \(\inset{a}{\psetsat{t}} \land \indirdepends{a}{b}\)
then \inset{b}{\psetsat{t}} }

\noindent At any time $t$, one of the following transformations may be applied:
\begin{enumerate}
\item For some \block{w}:\\
Let \(\pset{B} = \{a\ |\ \inset{a}{\psetinflight{t}} \land \blockof{a} = \block{w} \}\) in\\
\(\psetsat{t+1} := \psetsat{t} \cup \pset{B}\)\\
\(\psetinflight{t+1} := \psetinflight{t} \setminus \pset{B}\)
\label{action:write}

\item \(\deps{t+1} := \deps{t} \cup\ \pset{X}\) where
\(\notinset{a}{\psetall{t}} \land \pset{X} \subset \{\depends{a}{b}\}\)\\
\(\psetall{t+1} := \psetall{t} \cup\ \{a\}\)
\label{action:create}

\item \(\psetinflight{t+1} := \psetinflight{t} \cup \{a\}\) for some
\notinset{a}{\psetsat{t}} s.t. \(\forall b: \indirdepends{a}{b},\
\inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}} \land
\blockof{a} = \blockof{b}\)
\label{action:fly}
\end{enumerate}

We can prove that invariants~\ref{cdinvar:a} and~\ref{cdinvar:b}
with actions~\ref{action:write}, \ref{action:create}, and~\ref{action:fly}
imply that invariant~\ref{cdinvar:c} holds.

\noindent Action~\ref{action:create} replacements for hard patches:
\begin{enumerate}
\item \(\deps{t+1}\ := \deps{t} \cup\ \pset{X}\) for
\(\notinset{a}{\psetall{t}} \land \pset{X}\! \subset\!
\{\depends{a}{b}\ |\ \inset{b}{\psetall{t}}\}\)\\
\(\psetall{t+1} := \psetall{t} \cup\ \{a\}\)

\item \(\psethard{t+1}\ := \psethard{t} \cup \{a\}\) where \(\forall b\!:
\indirdepends{b}{a},\ \blockof{b} = \blockof{a}\)
\end{enumerate}

\noindent Action~\ref{action:fly} replacements for hard patches:
\begin{enumerate}
\item \(\psetinflight{t+1} := \psetinflight{t} \cup \{a\}\) for
\notinset{a}{\psetall{t} \cup \psethard{t}}\\
\(\forall b\!: \indirdepends{a}{b},\ \inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}} \land \blockof{a} = \blockof{b})\)\\
\(\not\exists\inset{b}{\psethard{t}}\ \mbox{s.t.}\ \blockof{b} = \blockof{a}\)

\item For some \block{w}:\\
\(\psetinflight{t+1} := \psetinflight{t} \cup \pset{X}\) for
\(\pset{X} = \{\inset{a}{\psethard{t}}\ |\ \blockof{a} = \block{w}\}\)\\
\(\forall \notinset{b}{\pset{X}}\!: \forall \inset{a}{\pset{X}}\!:
\indirdepends{a}{b},\ \inset{b}{\psetsat{t}} \lor
(\inset{b}{\psetinflight{t}} \land \blockof{a} = \blockof{b})\)\\
\(\psethard{t+1} := \psethard{t} \setminus \pset{X}\)
\end{enumerate}
% }}}

% {{{ precalculation
\subsection{Scalable Dependency-Preserving Writes}
For a \module\ like the write back cache to forward \chdescs\ in a
dependency-preserving order, the \module\ must find \chdescs\ whose
\befores\ are on a lower block device (or are part of the block write
and on the current block device). Because the write back cache
frequently searches for and writes many ready \chdescs, redundant
\before\ traversals to calculate \chdesc\ ready state would severly
limit cache size scalabity.
%
\Kudos\ therefore
%
1) explictly tracks a \chdesc's \before\ counts through incremental
dependency updates
%
and 2) uses these counts to maintain a \chdesc\ ready list for each
block.

A \chdesc's \before\ counts are incrementally updated
%
as \befores\ are added and removed
%
and as \beforing\ \chdesc's change levels.
%

Due to invariant~\ref{cdinvar:before-levels}, only directly reachable
\beforing\ \chdescs\ need to be included in a \chdesc's \before\ counts.
%
Note that because \anoop\ \chdesc's level is a function of its \befores,
%
\anoop\ \chdesc\ \before\ count update that changes the \noop\ \chdesc's level
must propagate the level change to the \noop\ \chdesc's \afters.
%
When a \before\ count update changes whether a \chdesc\ is ready to
write, the \chdesc's inclusion in its block's ready list is updated.
%
To write a block, an owner thus iterates through the block's ready
list, moving \chdescs\ to the target block device, until the list is
empty.

TODO: Include invariants that the max \before\ level computation is
$O(1)$ or that ready \chdescs\ can be moved in $\sim\! O(r)$ time?
% }}}

% {{{ sec:chdescs:nrb
\subsection{\Nrb\ \ChDescs}
\label{sec:chdescs:nrb}
To enable \chdesc\ rollback, each \chdesc\ contains a copy of the
previous block data.\footnote{Actually, \Kudos\ supports a specialized
type of \chdesc\ for efficiently flipping individual bits using an
inline exclusive-or mask instead of a copy of the previous data, but
most \chdescs\ are not of this type.}
%
While these copies are needed to roll back \chdescs, many
\chdescs\ are never actually rolled back (e.g. file data blocks) and
previous data copies nearly double the memory usage of \chdescs\ and
cached blocks.
%
\Kudos\ addresses this issue by identifying those \chdescs\ which will
never need to be rolled back, and omitting the previous data copies for
them. We call these \emph{\nrb} \chdescs. (The opposite naturally being
a \emph{\rb} \chdesc, when necessary to differentiate them.)

To identify potential \nrb\ \chdescs, \Kudos\ uses a conservative algorithm
based on a \chdesc\ graph invariant. Merely detecting that the current
\chdesc\ graph can be written without rolling back a particular \chdesc\ is
not sufficient, as the graph may change in the future. Thus we need an
invariant which will guarantee that future changes to the graph will not
require \nrb\ \chdescs\ to be rolled back, where \nrb\ \chdescs\ are
selected based on some property of the current graph.

\cdinvar{add-before}{All block-level cycles induced through
\chdesc\ $C$'s \befores\ exist when $C$ is
created\todo{Change this phrasing? ``Once created, a \chdesc\ will not
gain any \befores\ that induce block-level cycles.''}.}
%
\Kudos\ ensures this invariant by restricting \before\ additions to
\chdesc\ creation, \noop\ \chdescs\ with no \afters, or when the invariant
is statically proven to hold.

To avoid a costly dependency traversal to determine whether a new
\chdesc\ will need to be rolled back, \Kudos\ conservatively identifies
a new \chdesc\ as \nrb\ only if the block has no \chdescs\
with external (on a different block\todo{Descriptive enough? Mention
\noop\ \chdesc\ \after\ recursion?}) \afters. Each block tracks the number of
external \afters\ through incremental updates as \afters\ are added and
removed.
% }}}

% {{{ sec:chdescs:overlap-merge
\subsection{Overlap \ChDesc\ Merging}
\label{sec:chdescs:overlap-merge}
\Kudos\ drastically reduces the number of \chdescs\ created to
describe a system of changes by (conservatively) identifying when a
second \chdesc\ may safely be written at the same time as an existing
\chdesc\ and, instead of creating the second \chdesc, updating the
existing \chdesc's disk change and dependencies; in effect, merging
the two \chdescs.
%
In this section we describe overlapping \chdesc\ merging; after
introducing \nrb\ \chdescs\ in the next section we describe
two additional merge opportunties.
%
All three merge rules build on invariant~\ref{cdinvar:add-before}
and use fast, conservative checks during \chdesc\ creation to identify
\chdescs\ that will be possible to write together;
%
the merge rules differ in their conservatively applicable conditions.

Bitmap blocks and inode size fields accumulate many nearby and
overlapping mergeable \chdescs\ as data is appended to a file.
%
Many of these and similar \chdescs\ are mergeable and have
dependencies that allow simple (and fast) reasoning to identify many
of the mergeable pairs: two \chdescs\ that overlap no other in-memory\todo{Have we introduced this terminology?} \chdescs\
and which have no dependency path from the new to the existing \chdesc\
will not induce a block-level cycle and so are writeable together.
We know that \textit{later} changes will not cause them to induce a block-level cycle due to
invariant~\ref{cdinvar:add-before} and by not merging if the new \chdesc{}
has a before and the before is marked as allowed to violate
invariant~\ref{cdinvar:add-before}.
%
While path existance testing is expensive, a conservative path test
of only a depth of two identifies most mergeable \chdescs. If the new
\chdesc{} has an explicit \before\ that is not the existing \chdesc\ and
this \before\ has a \before, then there may be a path to the existing
\chdesc.
%
To merge two such overlapping \chdescs, add the new \chdesc{}'s explicit
before to the existing \chdesc\ (if any and if not the existing \chdesc).
% }}}

% {{{ sec:chdescs:nrb-merge
\subsection{\Nrb\ \ChDesc\ Merging}
\label{sec:chdescs:nrb-merge}
Recall from FOO\todo{Name FOO} that to write any \chdesc\ on a given block,
all \nrb\ \chdescs\ on the block must also be written. 
%
These implicit dependencies complicate determining whether a block can
be written, requiring a search for non-ready \nrb\ \chdescs.
%
By merging \nrb\ \chdescs\ together and by merging existing \rb\
\chdescs\ into the block's \nrb\ \chdesc\ when the \nrb\ \chdesc\ is
created,
%
\Kudos\ ensures that there is at most one \nrb\ \chdesc\ per block and
that all \chdescs\ on the same block depend on the \nrb\
\chdesc\,
%
and so avoids dependency complication and further reduces \chdesc\
memory overhead.

While any two \nrb\ \chdescs\ on the same block will be written
together, to merge the \chdescs\ the dependencies involving the merged
\chdescs\ must be transformed to preserve the non-merged system's
semantics.  Sections~\ref{sec:chdescs:nrb-merge:hard-hard}
and~\ref{sec:chdescs:nrb-merge:hard-soft} discuss these
transformations.

Mention?:
%
\Nrb\ \chdescs, \rb\ \chdescs, and ready lists:
%
all post-NRB created \chdescs\ depend on NRB because of overlaps.
%
no NRB-prior created \chdescs\ exist (RB->NRB).
%
single NRB.

\subsubsection{\Nrb{}-\Nrb{} \ChDesc\ Merging}
\label{sec:chdescs:nrb-merge:hard-hard}
% Although merging two \chdescs\ will not induce block-level dependency
% cycles, without sufficient care merging could induce \chdesc-level
% dependency cycles.  A trivial example is merging \p{q} into \p{p} when
% \p{q} has an explicit dependency on \p{p}; the combined \p{(p+q)}
% should not and need not depend on itself.
To preserve the non-merged dependency semantics when merging a new
\nrb\ \chdesc\ \p{q} into an existing \nrb\ \chdesc\ \p{p}, the merged
\p{(p+q)} must depend on the union of \p{p} and \p{q}'s transitive
\befores.
%
From \chdesc\ invariant~\ref{cdinvar:add-before} and the \nrb\
\chdesc\ creation rule, the only possible dependencies involving \p{p}
and \p{q} are those show in Figure~\ref{fig:nrb-merge}\todo{Should we
  give these deductions or a flavor?}.
%
An algorithm to transform dependencies for \nrb\ \chdesc\ merges
follows from these possible dependencies.
%
Notice, for example, that the dependency paths that could become a
cycle upon the merge of \p{p} of \p{q} involve only \noop\ \chdescs\
and that \chdesc\ invariant~\ref{cdinvar:add-before} ensures these
\noop\ \chdesc\ will not gain data \chdesc\ \befores.
%
TODO: explain further?

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \nrb\ \chdesc\ \p{q}
    into existing \nrb\ \chdesc\ \p{p}.}
  \label{fig:nrb-merge}
\end{figure}

\noindent Algorithm called on \p{q} and \p{p}:\\
Input: \chdesc\ \p{a} and existing \nrb\ \chdesc\ \p{p}.
\begin{itemize}
\item If \p{a} is external, return ``no path to \p{p}.''
\item If \p{a} equals \p{p}, return ``path to \p{p}.''
\item Call self on \p{a} and \p{p}.
\item If \p{a} has no path to \p{p}, return ``no path to \p{p}.''
\item For each \p{a} \befores\ \p{b}:
  \begin{itemize}
    \item If \p{b} has no path to \p{p}:
      \begin{itemize}
      \item Move \p{b} from a \before\ of \p{a} to a \before\ of \p{p}.
      \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{\Nrb{}-\Rb{} \ChDesc\ Merging}
\label{sec:chdescs:nrb-merge:hard-soft}
TODO: talk about why \nrb\ \chdescs\ slow down revision slice creation or talk
about how we detect RB$\rightarrow$NRB changes and then do \nrb\ \chdesc\ merges
to avoid this slowdown.

Say something along the lines:
%
The dynamic optimizations facilitated through \nrb\
\chdescs\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we include memory/performance improvement numbers?}
\todo{Should we talk about why we allow NRBs to be disabled? (Debugging
simplicity and depend add to \noop\ \chdescs\ with \afters\ bug catching.)}

\cdinvar{extern-after}{Each block tracks the total number of
external \afters\ for \chdescs\ on that block.}

\cdinvar{one-nrb}{Each block has at most one \nrb\ \chdesc.}
% }}}

% {{{ sec:chdescs:discussion
\subsection{Discussion}
\label{sec:chdescs:discussion}

\subsubsection{Unnecessary \ChDesc\ Dependencies}
Even with \Kudos\ dynamically optimizing \chdesc\ graphs, there is only so much
that can be done while preserving the semantics of the dependencies specified by
the \module\ which created the \chdescs. It is obvious that having too few
dependencies compromises the correctness of the system; it is perhaps less
obvious but no less true that having too many dependencies can nontrivially
degrade the performance of the system.

In Figure~\ref{fig:chdescarrange}, we have two possible arrangements for three
\chdescs. The \noop\ \chdesc\ represents a root node that can reach all
other \chdescs. In the parallel arrangement on the right, \Kudos\ has the
freedom to write \chdescs\ $C_1$, $C_2$, and $C_3$ to disk in any order. In the
serial arrangement on the left, there exists only one valid write ordering.
Depending on the arrangement of other \chdescs, \Kudos\ may have to perform
additional rollbacks and write some blocks more times than would otherwise be
necessary in order to write these \chdescs\ to disk. Even if that is not
necessary, \Kudos\ will still have less flexibility in choosing an order to
write the blocks, potentially increasing disk seek times due to suboptimal
ordering.

% {{{ fig:chdescarrange
\begin{figure}[htb]
  \centering
  \includegraphics[width=192pt]{fig/figures_6}
  \caption{\label{fig:chdescarrange} \Chdesc\ dependencies, when
  not strictly needed, restrict the possible choices for write ordering.
  This results in suboptimal write ordering and more scans through the
  \chdescs\ for \Kudos. On the right, \chdescs\ C1, C2, and C3 can be written
  in any order. Only one ordering is possible on the left.}
\end{figure}
% }}}

Even when no unnecessary dependencies are explicitly created, they can still be
created implicitly and care must be taken to avoid them. When \chdescs\ overlap,
the later \chdesc\ is made to depend on the first so that it cannot precede the
change it is changing further to disk. As a result, however, unnecessary
dependencies may result if the \chdescs\ are larger than the data they are
actually changing. In Figure~\ref{fig:overlap}, to update a field in an inode
structure on disk, a \chdesc\ spanning the entire inode could be created even
though only a single field changed. A later change to a different field would
appear to overlap the first, creating an unnecessary dependency. Creating
\chdescs\ which correspond more precisely to the changes being made avoids this
problem, so a utility function is provided by \Kudos\ to make this operation as
convenient as creating a single \chdesc\ for an entire large structure.

% {{{ fig:overlap
\begin{figure}[htb]
  \centering
  \includegraphics[width=64pt]{fig/figures_5}
  \caption{\label{fig:overlap} On inode 17, the gray regions represent
  modified fields that do not overlap. If \chdesc\ A and \chdesc\ B are
  exactly the size of the gray regions, then there is no implicit dependency.
  However, making \chdescs\ for the entire inode data structure will make
  one \chdesc\ depend on the other because they overlap.}
\end{figure}
% }}}

\subsubsection{\ChDesc\ List Ordering}
Several functions in \Kudos\ iterate over lists of \chdescs\ looking for either
a single \chdesc\ or set of \chdescs\ satisfying some property, or trying to
process all the \chdescs\ in the list in some order determined by the dependency
graph. It is generally the case that the \chdescs\ satisfying the property or
the order in which the \chdescs\ should be processed can be determined very
quickly by keeping the lists sorted. For instance, the library function which
rolls \chdescs\ back needs to perform the rollbacks essentially in inverse
creation order, so that rolling back a \chdesc\ which has since been overwritten
by a later \chdesc\ does the right thing. Keeping the list of all \chdescs\ on a
block sorted in creation order (which is very easy) makes this an efficient
operation, while it might otherwise take $O(n^2)$ time to execute. Similarly,
many \chdesc\ merging functions need to find for a given block some \chdesc\
which has no \befores\ on the same block, and the oldest \chdesc\ on a block
always satisfies this requirement.
% }}}
