% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Block Descriptors}

Disk blocks are represented by objects called \emph{block descriptors}.
\Kudos\ maintains a block descriptor object for each cached block, and tracks
pointers to the block descriptors using reference counting. In addition to the
``retain'' and ``release'' operations which increment and decrement the
reference counts, \Kudos\ also provides an ``autorelease'' operation which
decrements the usage count after the calling system call completes. This is
useful for simulating garbage collection.

\Kudos\ expects to be able to write blocks atomically. Thus, the modules that
interface with the disk return blocks that are 512 bytes long (the sector
size). However, a single block descriptor can correspond to a range of
contiguous blocks. This feature is used by the \Kudos\ block resizer module to
``join'' sector-sized blocks into a more convenient size for the relevant file
system, such as 2048 or 4096 bytes.


\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct chdesc {
    BD_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct chdesc_queue *dependencies;
    uint32_t nbefores[NBDLEVEL];
    chdesc_t * ddesc_ready_next;
    chdesc_t ** ddesc_ready_prev;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}


\subsection {Change Descriptors}
\label{sec:design:chdescs}

%%\subsubsection {Overview}


% The first use of "change descriptor" is written out. All others, if not the
% same, should be defined in parentheses here.
Each in-memory modification to a cached disk block has an associated
change descriptor.
%
A \chdesc's \emph{dependencies} point to other \chdescs\ that must
precede it to stable storage. A \chdesc\ can be applied or reverted to switch
the cached block's state between old and new.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows much of the API for working with them.
%
The ability
to revert and re-apply \chdescs\ is inspired by soft updates dependencies, but
generalized so that it is not specific to any particular file system.
%
\Chdesc\ dependencies can create cyclic dependencies among
blocks. \Chdescs\ themselves are not allowed to form cycles
to prevent inter-block cycles and to simplify \chdesc\ algorithms;
this is the first \chdesc\ invariant:
\cdinvar{acyclic}{\Chdesc\ dependency graphs are acyclic.}
%
To break block-level cycles, some \chdescs\ may need to be rolled
back, or reverted, in order to first write other \chdescs. To ensure a
rollback operation results in a well-defined block state, we have our
second \chdesc\ invariant: \cdinvar{rollback}{A rolledback \chdesc{}'s
afters are rolledback\todo{Be more precise to be correct.}.}

\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
int \textbf{chdesc_create_byte}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, chdesc_t **head);
chdesc_t *\textbf{chdesc_create_bit}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint32_t xor);
chdesc_t *\textbf{chdesc_create_noop}(
    BD_t *owner, chdesc_t *tail, ...);
int \textbf{chdesc_create_diff}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *newdata, chdesc_t **head);
int \textbf{chdesc_add_depend}(
    chdesc_t *depender, chdesc_t *dependee);
void \textbf{chdesc_remove_depend}(
    chdesc_t *depender, chdesc_t *dependee);
int \textbf{chdesc_apply}(chdesc_t *chdesc);
int \textbf{chdesc_rollback}(chdesc_t *chdesc);
int \textbf{chdesc_satisfy}(chdesc_t *chdesc);
int \textbf{chdesc_push_down}(
    BD_t *current_bd, bdesc_t *current_block,
    BD_t *target_bd, bdesc_t *target_block);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}

\Kudos\ \modules\ change blocks by attaching change descriptors to them,
using functions such as \texttt{chdesc\_create\_byte}.
%
Most file system modules initially generate \chdescs\ whose
dependencies impose soft-update-like ordering requirements (see
\S\ref{sec:consistency:softupdate}).  These \chdescs\ are then passed down,
through other modules, in the general direction of the disk.  The
intervening \modules\ can
inspect, delay, and even modify them before passing them on further. For
instance, the write-back cache \module\ (\S\ref{sec:modules:wbcache}),
essentially a buffer cache, holds
on to blocks and their \chdescs\ instead of forwarding them
immediately. Each delay-inducing \module\ increases its \module\
level by one over the module(s) it uses, starting at zero.
%
When evicting a block and associated \chdescs, the write-back
cache enforces an order consistent with the \chdesc\ dependency
information. Specifically,
\cdinvar{before-levels}{The befores of a \chdesc\ at level $l$ are at levels $\leq l$.}

When a \module\ asynchronously writes the data associated with a set
of \chdescs\ to stable storage it marks the \chdescs\ as
\emph{in flight} to indicate that the \chdescs\ are considered to still
have the above level. Afters will thus remain at the above level (or
higher), preserving the \chdescs{}'s dependencies.
%
A \chdesc\ is \emph{satisfied} when its associated data reaches stable
storage.

%% Since many \modules\ may be stacked on top of one another in \Kudos, and since
%% many of them may want to refer to the same block at the same time, 
Each \chdesc\ on a block may or may not be visible to a given \module.
%
For example, modules that respond to user requests generally view the most
 current state of every block -- the block with all \chdescs\ applied.
%
However, a write-back cache may choose to write some \chdescs\ on a block
 while reverting others, since those others currently have unsatisfiable
 dependencies.
%
In this case, \modules\ below the write-back cache should view the
 unsatisfied \chdescs\ in the reverted state.
%
%% If this \module\ is the disk, it will need to be able to write a version of
%%  the block's data that does not include the \chdescs\ that have not yet
%%  been sent to it.
%
\Kudos\ provides a block revisioning library function that automatically rolls back those
 \chdescs\ that should not be visible at a particular \module, and then
 rolls them forward again after that \module\ is done with the block.


%% \paragraph{Manipulations and Transformations}
% FIXME: add concrete details here

%% \Chdescs\ play a central role in \Kudos, and therefore many parts of the system
%% need to generate, consume, forward, and manipulate them. Obviously there are many
%% simple block devices like partitioners will need to simply forward \chdescs\ on
%% to the next block device after adjusting the block number being written. The
%% write-back cache (\S\ref{sec:modules:wbcache}) needs to determine whether
%% \chdescs\ are ready to send to the next block device or not.

%% A collection of simple operations, such as shifting a \chdesc\ from one block
%% to another, checking whether a \chdesc\ has unsatisfiable dependencies, and
%% copying a \chdesc\ (useful for modules such as RAID), are handled by common
%% library functions available to any module.

%% Additionally, there are some more complex transformations which are useful for
%% devices like the journaling \module (\S\ref{sec:consistency:journal}). The
%% journal must copy entire blocks into a journal area, and overwrite that journal
%% area efficiently when the blocks are changed again during the same transaction.
%% This \chdesc\ transformation is handled by a library function, so that if other
%% \modules\ need to do similar things, the functionality will already be available.

\subsection{\ChDesc\ Optimizations}
\label{sec:design:chdesc-opts}

Here we describe \chdesc\ optimizations that speed \chdesc\ state
queries through incremental cache updates
%
and lower \chdesc\ memory overhead by
%
providing specialized change descriptions,
%
expressing dependencies more efficiently,
%
omitting unneeded rollback information,
%
and merging \chdescs.

Mention these?:
%
Each block has a list of \chdescs\ on that block.
%
Each block has a list of \chdescs\ on that block that are ready to be
moved down by one level.
%
Each block has a list of \chdescs\ that are not entirely overlaped.

\paragraph{Bit \ChDescs}
\label{sec:design:chdescs:bit}
A bit \chdesc\ is a specialized \chdesc\ that expresses small changes
more efficiently than than the general byte \chdesc\, using an inline
mask instead of a pointer to a copy of previous data to support rollbacks.

\paragraph{\Noop\ \ChDescs}
\label{sec:design:chdescs:noop}
The prototypical \chdesc\ corresponds to some change on disk, but \Kudos\
 also supports a \emph{\noop} \chdesc\ type, which doesn't change the disk
 at all.
%
%% An important type of \chdesc\ is actually one that doesn't change the disk at
%% all: the \noop\ \chdesc. 
%
\Noop\ \chdescs\ can have dependencies, like any other
\chdesc, but they don't need to be written to disk:  they are trivially satisfied when all of their dependencies are
satisfied.
%
Thus, they can be used to ``stand for'' entire sets of other changes.
%
This capability is extremely useful, and is used by most operations on disk
structures so that a single \chdesc\ can be returned that depends on the whole
change. Likewise, a \noop\ \chdesc\ can be passed in as a parameter to a disk
operation to make the whole operation depend on a set of other changes. \Noop\
\chdescs\ allow dependencies between sets without a quadratic number
of dependency edges in the \chdesc\ graph, and without having to pass around
arrays of \chdescs.
%
The cost is that some functions may have to traverse trees of \noop\ change
 descriptors to determine true dependencies.
%
A \noop\ \chdesc's level is defined to be the max level of its befores;
in effect, propagating a \noop's befores to its afters.

Modules can also use \noop\ \chdescs\ to \emph{prevent} changes from being
 written.
%
A \emph{managed} \noop\ must be explicitly satisfied; any changes that
 depend on that \noop\ are delayed until the owning module explicitly
 satisfies it.
%
This is used, for instance, by the journal \module\
 (\S\ref{sec:consistency:journal}) to prevent a transaction's \chdescs\
 from being written before the journal commits.

\paragraph{Scalable Dependency-Preserving Writes}
For a \module\ like the write back cache to forward \chdescs\ in a
dependency-preserving order, the \module\ must find \chdescs\ whose
befores are on a lower block device (or are part of the block write
and on the current block device). Because the write back cache
frequently searches for and writes many ready \chdescs{}, redundant
before traversals to calculate \chdesc\ ready state would severly
limit cache size scalabity.
%
\Kudos\ therefore
%
1) explictly tracks a \chdesc{}'s before counts through incremental
dependency updates
%
and 2) uses these counts to maintain a \chdesc\ ready list for each
block.

A \chdesc{}'s before counts are incrementally updated
%
as befores are added and removed
%
and as before \chdesc{}'s change levels.
%

Due to invariant~\ref{cdinvar:before-levels}, only directly reachable
before \chdescs\ need to be included in a \chdesc's before counts.
%
Note that because a \noop\ \chdesc's level is a function of its befores,
%
a \noop\ \chdesc\ before count update that changes the \noop's level
must propagate the level change to the \noop's afters.
%
When a before count update changes whether a \chdesc\ is ready to
write, the \chdesc's inclusion in its block's ready list is updated.
%
To write a block, an owner thus iterates through the block's ready
list, moving \chdescs\ to the target block device, until the list is
empty.

TODO: Include invariants that the max before level computation is
$O(1)$ or that ready \chdescs\ can be moved in $\sim\! O(r)$ time?

\paragraph{\ChDesc\ Merging}
\Kudos\ drastically reduces the number of \chdescs\ created to
describe a system of changes by (conservatively) identifying when a
second \chdesc\ may safely be written at the same time as an existing
\chdesc\ and, instead of creating the second \chdesc, updating the
existing \chdesc's disk change and dependencies; in effect, merging
the two \chdescs.
%
In this section we describe overlapping \chdesc\ merging; after
introducing nonrollbackable \chdescs\ in the next section we describe
two additional merge opportunties.
%
All three merge rules build on invariant~\ref{cdinvar:add-before}\todo{Introduce invariant~\ref{cdinvar:add-before} sooner than with NRBs}
and use fast, conservative checks during \chdesc\ creation to identify
\chdescs\ that will be possible to write together;
%
the merge rules differ in their conservatively applicable conditions.

Bitmap blocks and inode size fields accumulate many nearby and
overlapping mergeable \chdescs\ as data is appended to a file.
%
Many of these and similar \chdescs\ are mergeable and have
dependencies that allow simple (and fast) reasoning to identify many
of the mergeable pairs: two \chdescs\ that overlap no other \chdescs{}
and which have no dependency path from the new to the existing \chdesc\
will not induce a block-level cycle and so are writeable together.
We know that \textit{later} changes will not cause them to induce a block-level cycle due to
invariant~\ref{cdinvar:add-before}.
%
While path existance testing is expensive, testing only whether the new
\chdesc\ has a before with a before identifies most mergeable
\chdescs. \ldots

This section's key points:
Rule: exactly one overlap and new before does not depend on overlap.
Overlapping makes it easy (but could extend chdescs so that they do overlap).
Gain new before (if not the overlap).

\paragraph{Nonrollbackable \ChDescs}
To enable byte \chdesc\ rollback, each byte \chdesc\ contains a copy
of the previous block data.
%
While these copies are needed to rollback byte \chdescs, many
\chdescs\ are actually never rolledback (e.g. file data blocks) and
previous data copies nearly double the memory usage of change and
block descriptors.
%
\Kudos\ makes use of invariant~\ref{cdinvar:add-before} and
conservative heuristics to identify \chdescs\ that will never need to
be rolledback. We call these \emph{nonrollbackable} \chdescs\
(\emph{NRB}s). NRBs can safely omit their previous data copies and
can safely be merged together.

To not store the previous block data when creating a \chdesc\ one must know
%
that the \chdesc\ need not be rolledback to write the existing
\chdesc\ graph
%
and also that later \chdesc\ graph changes will not induce a forced
rollback:
%
\cdinvar{add-before}{All block-level cycles induced through
\chdesc\ $C$'s befores exist when $C$ is
created\todo{Change this phrasing? ``Once created, a \chdesc\ will not
  gain any befores that induce block-level cycles.''}.}
%
\Kudos\ ensures this invariant by restricting before additions to
\chdesc\ creation, \noops\ with no afters, or when the invariant
is statically proven to hold.

To avoid a costly dependency traversal to determine whether a new
\chdesc\ will need to be rolledback, \Kudos\ conservatively identifies
a new \chdesc\ as nonrollbackable only if the block has no \chdescs\
with external (on a different block\todo{Descriptive enough? Mention
\noop\ after recursion?}) afters. Each block tracks the number of
external afters through incremental updates as afters are added and
removed.

\paragraph{Nonrollbackable \ChDesc\ Merging}
\label{sec:design:chdesc-opts:nrb-merge}
Notice that two nonrollbackable \chdescs\ on a block must be committed
in the same revision slice; neither can (or will need to) be rolled
back. This illustrates the underlying reason why two nonrollbackable
\chdescs\ can be merged into a single nonrollbackable \chdesc.
%
While no block-level dependency cycles can be induced by a merge,
without sufficient care a merge could induce \chdesc{}-level
dependency cycles. A trivial example is merging \nrb{B} into \nrb{A}
when \nrb{B} has an explicit dependency on \nrb{A}; the combined
\nrb{(A+B)} should not and need not depend on itself. The dependency
addition and nonrollbackable \chdesc\ creation rules restrict the
possible dependencies involving \nrb{A} and \nrb{B} to \textit{only}
those shown in Figure~\ref{fig:nrb-merge}\todo{Should we give these
  deductions or a flavor?}. From these possible dependencies follows
an algorithm that recurses \nrb{B}'s before dependency chains until an
external \chdesc\ is encountered and that for each \ncd{C} along the
chain with a before path to \nrb{A}, moves all of \ncd{C}'s befores
without before paths to be befores of \nrb{A}\todo{This could be more
  lucid.} This graph manipulation preserves the system's \chdesc\
dependencies.

NRBs, RBs, and ready lists:
%
all post-NRB created chdescs depend on NRB because of overlaps.
%
no NRB-prior created chdescs exist (RB->NRB).
%
single NRB.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \nrb{B} into \nrb{A}.}
  \label{fig:nrb-merge}
\end{figure}

TODO: talk about why NRBs slow down revision slice creation or talk
about how we detect RB$\rightarrow$NRB changes and then do NRB merges
to avoid this slowdown.

Say something along the lines:
%
The dynamic optimizations facilitated through nonrollbackable
\chdescs\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we include memory/performance improvement numbers?}
\todo{Should we talk about why we allow NRBs to be disabled? (Debugging
simplicity and depend add to noops with afters bug catching.)}

\cdinvar{extern-after}{Each block tracks the total number of
  external afters for \chdescs\ on that block.}

\cdinvar{one-nrb}{Each block has at most one nonrollbackable \chdesc.}

%% \subsubsection{Block Revisions}
% FIXME maybe make an analogy to packets flowing through a network? -LZ

% Should end with an example -- a little diagram, perhaps
% borrowed from soft updates -- and then perhaps discussion, with things like
% the last paragraph of optimizations above
