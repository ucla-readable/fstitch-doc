% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Block Descriptors}

Disk blocks are represented by objects called \emph{block descriptors}.
\Kudos\ maintains a block descriptor object for each cached block, and tracks
pointers to the block descriptors using reference counting. In addition to the
``retain'' and ``release'' operations which increment and decrement the
reference counts, \Kudos\ also provides an ``autorelease'' operation which
decrements the usage count after the calling system call completes. This is
useful for simulating garbage collection.

\Kudos\ expects to be able to write blocks atomically. Thus, the modules that
interface with the disk return blocks that are 512 bytes long (the sector
size). However, a single block descriptor can correspond to a range of
contiguous blocks. This feature is used by the \Kudos\ block resizer module to
``join'' sector-sized blocks into a more convenient size for the relevant file
system, such as 2048 or 4096 bytes.


\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct chdesc {
    BD_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct chdesc_queue *dependencies;
    uint32_t nbefores[NBDLEVEL];
    chdesc_t * ddesc_ready_next;
    chdesc_t ** ddesc_ready_prev;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}


\subsection {Change Descriptors}
\label{sec:design:chdescs}

\newcounter{chdescinvari}
\newcommand{\chdescinvar}[2]{\begin{enumerate}\setcounter{enumi}{\value{chdescinvari}}\item #2\label{invar:#1}\setcounter{chdescinvari}{\value{enumi}}\end{enumerate}}

%%\subsubsection {Overview}


% The first use of "change descriptor" is written out. All others, if not the
% same, should be defined in parentheses here.
Each in-memory modification to a cached disk block has an associated
change descriptor.
%
A \chdesc's \emph{dependencies} point to other \chdescs\ that must
precede it to stable storage. A \chdesc\ can be applied or reverted to switch
the cached block's state between old and new.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows much of the API for working with them.
%
The ability
to revert and re-apply \chdescs\ is inspired by soft updates dependencies, but
generalized so that it is not specific to any particular file system.
%
\Chdesc\ dependencies can create cyclic dependencies among
blocks. \Chdescs\ themselves are not allowed to form cycles
to prevent inter-block cycles and to simplify \chdesc\ algorithms;
this is the first \chdesc\ invariant:
\chdescinvar{acyclic}{\Chdesc\ dependency graphs are acyclic.}
%
To break block-level cycles, some \chdescs\ may need to be rolled
back, or reverted, in order to first write other \chdescs. To ensure a
rollback operation results in a well-defined block state, we have our
second \chdesc\ invariant: \chdescinvar{rollback}{A rolledback \chdesc{}'s
afters are rolledback.}

\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
int \textbf{chdesc_create_byte}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, chdesc_t **head);
chdesc_t *\textbf{chdesc_create_bit}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint32_t xor);
chdesc_t *\textbf{chdesc_create_noop}(
    BD_t *owner, chdesc_t *tail, ...);
int \textbf{chdesc_create_diff}(
    bdesc_t *block, BD_t *owner,
    uint16_t offset, uint16_t length,
    const void *newdata, chdesc_t **head);
int \textbf{chdesc_add_depend}(
    chdesc_t *depender, chdesc_t *dependee);
void \textbf{chdesc_remove_depend}(
    chdesc_t *depender, chdesc_t *dependee);
int \textbf{chdesc_apply}(chdesc_t *chdesc);
int \textbf{chdesc_rollback}(chdesc_t *chdesc);
int \textbf{chdesc_satisfy}(chdesc_t *chdesc);
int \textbf{chdesc_push_down}(
    BD_t *current_bd, bdesc_t *current_block,
    BD_t *target_bd, bdesc_t *target_block);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}

\Kudos\ \modules\ change blocks by attaching change descriptors to them,
using functions such as \texttt{chdesc\_create\_byte}.
%
Most file system modules initially generate \chdescs\ whose
dependencies impose soft-update-like ordering requirements (see
\S\ref{sec:consistency:softupdate}).  These \chdescs\ are then passed down,
through other modules, in the general direction of the disk.  The
intervening \modules\ can
inspect, delay, and even modify them before passing them on further. For
instance, the write-back cache \module\ (\S\ref{sec:modules:wbcache}),
essentially a buffer cache, holds
on to blocks and their \chdescs\ instead of forwarding them
immediately. Each delay-inducing \module\ increases its \module\
level by one over its below \module{}(s), starting at zero.
%
When evicting a block and associated \chdescs, the write-back
cache enforces an order consistent with the \chdesc\ dependency
information. Specifically,
\chdescinvar{before-levels}{The befores of a \chdesc\ at level $l$ are at levels $\leq l$.}

When a \module\ asynchronously writes the data associated with a set
of \chdescs\ to stable storage it marks the \chdescs\ as
\emph{inflight} to indicate that the \chdescs\ are considered to still
have the above level. Afters will thus remain at the above level (or
higher), preserving the \chdescs{}'s dependencies.
%
A \chdesc\ is \emph{satisfied} when its associated data reaches stable
storage.

%% Since many \modules\ may be stacked on top of one another in \Kudos, and since
%% many of them may want to refer to the same block at the same time, 
Each \chdesc\ on a block may or may not be visible to a given \module.
%
For example, modules that respond to user requests generally view the most
 current state of every block -- the block with all \chdescs\ applied.
%
However, a write-back cache may choose to write some \chdescs\ on a block
 while reverting others, since those others currently have unsatisfiable
 dependencies.
%
In this case, \modules\ below the write-back cache should view the
 unsatisfied \chdescs\ in the reverted state.
%
%% If this \module\ is the disk, it will need to be able to write a version of
%%  the block's data that does not include the \chdescs\ that have not yet
%%  been sent to it.
%
\Kudos\ provides a block revisioning library function that automatically rolls back those
 \chdescs\ that should not be visible at a particular \module, and then
 rolls them forward again after that \module\ is done with the block.


%% \paragraph{Manipulations and Transformations}
% FIXME: add concrete details here

%% \Chdescs\ play a central role in \Kudos, and therefore many parts of the system
%% need to generate, consume, forward, and manipulate them. Obviously there are many
%% simple block devices like partitioners will need to simply forward \chdescs\ on
%% to the next block device after adjusting the block number being written. The
%% write-back cache (\S\ref{sec:modules:wbcache}) needs to determine whether
%% \chdescs\ are ready to send to the next block device or not.

%% A collection of simple operations, such as shifting a \chdesc\ from one block
%% to another, checking whether a \chdesc\ has unsatisfiable dependencies, and
%% copying a \chdesc\ (useful for modules such as RAID), are handled by common
%% library functions available to any module.

%% Additionally, there are some more complex transformations which are useful for
%% devices like the journaling \module (\S\ref{sec:consistency:journal}). The
%% journal must copy entire blocks into a journal area, and overwrite that journal
%% area efficiently when the blocks are changed again during the same transaction.
%% This \chdesc\ transformation is handled by a library function, so that if other
%% \modules\ need to do similar things, the functionality will already be available.

\subsection{\ChDesc\ Optimizations}
\label{sec:design:chdesc-opts}

Here we describe \chdesc\ optimizations that speed \chdesc\ state
queries through incremental cache updates
%
and lower \chdesc\ memory overhead by
%
providing specialized change descriptions,
%
expressing dependencies more efficiently,
%
omitting unneeded rollback information,
%
and merging \chdescs.

Include this invariant?
\chdescinvar{add-before}{A data \chdesc\ can gain befores only during creation.  A
  \noop\ \chdesc\ can also gain befores if it has no afters.}

Mention these?:
%
Each block has a list of \chdescs\ on that block.
%
Each block has a list of \chdescs\ on that block that are ready to be
moved down by one level.
%
Each block has a list of \chdescs\ that are not entirely overlaped.

\paragraph{Bit \ChDescs}
\label{sec:design:chdescs:bit}
A bit \chdesc\ is a specialized \chdesc\ that expresses small changes
more efficiently than than the general byte \chdesc\, using an inline
mask instead of a pointer to a copy of previous data to support rollbacks.

\paragraph{\Noop\ \ChDescs}
\label{sec:design:chdescs:noop}
The prototypical \chdesc\ corresponds to some change on disk, but \Kudos\
 also supports a \emph{\noop} \chdesc\ type, which doesn't change the disk
 at all.
%
%% An important type of \chdesc\ is actually one that doesn't change the disk at
%% all: the \noop\ \chdesc. 
%
\Noop\ \chdescs\ can have dependencies, like any other
\chdesc, but they don't need to be written to disk:  they are trivially satisfied when all of their dependencies are
satisfied.
%
Thus, they can be used to ``stand for'' entire sets of other changes.
%
This capability is extremely useful, and is used by most operations on disk
structures so that a single \chdesc\ can be returned that depends on the whole
change. Likewise, a \noop\ \chdesc\ can be passed in as a parameter to a disk
operation to make the whole operation depend on a set of other changes. \Noop\
\chdescs\ allow dependencies between sets without a quadratic number
of dependency edges in the \chdesc\ graph, and without having to pass around
arrays of \chdescs.
%
The cost is that some functions may have to traverse trees of \noop\ change
 descriptors to determine true dependencies.
%
A \noop\ \chdesc's level is defined to be the max level of its befores;
in effect, propagating a \noop's befores to its afters.

Modules can also use \noop\ \chdescs\ to \emph{prevent} changes from being
 written.
%
A \emph{managed} \noop\ must be explicitly satisfied; any changes that
 depend on that \noop\ are delayed until the owning module explicitly
 satisfies it.
%
This is used, for instance, by the journal \module\
 (\S\ref{sec:consistency:journal}) to prevent a transaction's \chdescs\
 from being written before the journal commits.

\paragraph{Scalable Dependency-Preserving Writes}
For a \module\ like the write back cache to forward \chdescs\ in a
dependency-preserving order, the \module\ must find \chdescs\ whose
befores are on a lower block device (or are part of the block write
and on the current block device). Because the write back cache
frequently searches for and writes many ready \chdescs{}, redundant
before traversals to calculate \chdesc\ ready state would severly
limit cache size scalabity.
%
\Kudos\ therefore
%
1) explictly tracks a \chdesc{}'s before counts through incremental
dependency updates
%
and 2) uses these counts to maintain a \chdesc\ ready list for each
block.

A \chdesc{}'s before counts are incrementally updated
%
as befores are added and removed
%
and as before \chdesc{}'s change levels.
%

Due to invariant~\ref{invar:before-levels}, only directly reachable
before \chdescs\ need to be included in a \chdesc's before counts.
%
Note that because a \noop\ \chdesc's level is a function of its befores,
%
a \noop\ \chdesc\ before count update that changes the \noop's level
must propagate the level change to the \noop's afters.
%
When a before count update changes whether a \chdesc\ is ready to
write, the \chdesc's inclusion in its block's ready list is updated.
%
To write a block, an owner thus iterates through the block's ready
list, moving \chdescs\ to the target block device, until the list is
empty.

TODO: Include invariants that the max before level computation is
$O(1)$ or that ready \chdescs\ can be moved in $\sim\! O(r)$ time?

\paragraph{Nonrollbackable \ChDescs\ and \ChDesc\ Merging}
\todo{Should we entitle this paragraph after the goal (two goals?)
  instead of our solution?}
%
Each byte and bit \chdesc\ includes information permitting that
\chdesc\ to be rolled back to resolve block-level dependency cycles,
implemented using two bytes of memory for each byte to change on disk.
%
However, many \chdescs\ are never rolled back; e.g., file data blocks
often contain a single \chdesc. Restricting the addition of befores to
\chdescs\ being created and to \noops\ with no afters\todo{Talk about
  this more? Elsewhere?} allows strong reasoning about a \chdesc{}'s
future.  Significantly, a \chdesc\ created on a block for which there
were no external afters on any existing \chdesc\ on the block will
\textit{never} need to be rolled back. One can thus omit such a
\chdesc{}'s rollback information, creating a \textit{nonrollbackable}
\chdesc.

A \chdesc\ is external to a block if and only if it is a byte, bit, or
on-block \noop\ \chdesc\ on a different block. In determining whether a
\noop\ not on a block is an external after, the \noop{}'s afters are
recursively analyzed. To avoid redundant scanning, each block
descriptor tracks its number of external afters, updated when afters
are added to and removed from \chdescs\ on the block. Whereas \chdesc\
before counts track befores and propagate through \noop\ afters, block
descriptor external after counts track afters and propagate through
\noop\ befores\todo{Does this sentence actually provide any insight?}.

Notice that two nonrollbackable \chdescs\ on a block must be committed
in the same revision slice; neither can (or will need to) be rolled
back. This illustrates the underlying reason why two nonrollbackable
\chdescs\ can be merged into a single nonrollbackable \chdesc.
%
While no block-level dependency cycles can be induced by a merge,
without sufficient care a merge could induce \chdesc{}-level
dependency cycles. A trivial example is merging \nrb{B} into \nrb{A}
when \nrb{B} has an explicit dependency on \nrb{A}; the combined
\nrb{(A+B)} should not and need not depend on itself. The dependency
addition and nonrollbackable \chdesc\ creation rules restrict the
possible dependencies involving \nrb{A} and \nrb{B} to \textit{only}
those shown in Figure~\ref{fig:nrb-merge}\todo{Should we give these
  deductions or a flavor?}. From these possible dependencies follows
an algorithm that recurses \nrb{B}'s before dependency chains until an
external \chdesc\ is encountered and that for each \ncd{C} along the
chain with a before path to \nrb{A}, moves all of \ncd{C}'s befores
without before paths to be befores of \nrb{A}\todo{This could be more
  lucid.} This graph manipulation preserves the system's \chdesc\
dependencies.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \chdesc\ $C$ into $A$.}
  \label{fig:nrb-merge}
\end{figure}

TODO: talk about why NRBs slow down revision slice creation or talk
about how we detect RB$\rightarrow$NRB changes and then do NRB merges
to avoid this slowdown.

Say something along the lines:
%
The dynamic optimizations facilitated through nonrollbackable
\chdescs\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we include memory/performance improvement numbers?}
\todo{Should we talk about why we allow NRBs to be disabled? (Debugging
simplicity and depend add to noops with afters bug catching.)}

\chdescinvar{extern-after}{Each block tracks the total number of
  external afters for \chdescs\ on that block.}

\chdescinvar{one-nrb}{Each block has at most one nonrollbackable \chdesc.}

%% \subsubsection{Block Revisions}
% FIXME maybe make an analogy to packets flowing through a network? -LZ

% Should end with an example -- a little diagram, perhaps
% borrowed from soft updates -- and then perhaps discussion, with things like
% the last paragraph of optimizations above
