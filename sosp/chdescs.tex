\section {\ChDescs}
\label{sec:chdescs}

% {{{ fig:chdesc
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.58in}p{2in}@{}}
\begin{scriptsize}
\begin{verbatim}
struct patch {
    bdev_t *device;
    bdesc_t *block;
    enum {BIT, BYTE, NOOP} type;
    union {
        struct {
            uint16_t offset;
            uint32_t xor;
        } bit;
        struct {
            uint16_t offset, length;
            uint8_t *data;
        } byte;
    };
    struct patch_queue *leaders;
    uint32_t nleaders[NBDLEVEL];
    patch_t * ddesc_ready_next;
    patch_t ** ddesc_ready_prev;
/* ... */ };
\end{verbatim}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdesc} Partial \chdesc\ structure.}
\end{figure}
% }}}

Each in-memory modification to a cached disk block has an associated
\chdesc.
%
A \chdesc's \emph{\befores} point to other \chdescs\ that must precede it to
stable storage; the \chdesc\ is then one of their \emph{\afters}. A \chdesc\ can
be applied or reverted to switch the cached block's state between old and new.

Figure~\ref{fig:chdesc} gives a simplified version of the structure, and
Figure~\ref{fig:chdapi} shows much of the API for working with them.
%
The ability
to revert and re-apply \chdescs\ is inspired by soft updates dependencies, but
generalized so that it is not specific to any particular file system.
%
\Chdesc\ dependencies can create cyclic dependencies among
blocks. \Chdescs\ themselves are not allowed to form cycles
to prevent inter-block cycles and to simplify \chdesc\ algorithms;
this is the first \chdesc\ invariant:
\cdinvar{acyclic}{\Chdesc\ dependency graphs are acyclic.}
%
To break block-level cycles, some \chdescs\ may need to be rolled
back, or reverted, in order to first write other \chdescs. To ensure a
rollback operation results in a well-defined block state, we have our
second \chdesc\ invariant: \cdinvar{rollback}{A rolled back \chdesc{}'s
\afters\ are rolled back\todo{Be more precise to be correct.}.}

% {{{ fig:chdapi
\begin{figure}[t]
\vskip-14pt
\begin{tabular}{@{\hskip0.25in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
int \textbf{patch_create_byte}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_create_bit}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint32_t xor,
    patch_t **head);
int \textbf{patch_create_empty}(
    bdev_t *owner, patch_t **tail,
    size_t nheads, patch_t * heads[]);
int \textbf{patch_create_diff}(
    bdesc_t *block, bdev_t *owner,
    uint16_t offset, uint16_t length,
    const void *data, patch_t **head);
int \textbf{patch_add_depend}(
    patch_t *\after, patch_t *\before);
void \textbf{patch_remove_depend}(
    patch_t *\after, patch_t *\before);
int \textbf{patch_apply}(patch_t *patch);
int \textbf{patch_rollback}(patch_t *patch);
int \textbf{patch_satisfy}(patch_t *patch);
int \textbf{patch_push_down}(
    bdev_t *current_bd, bdesc_t *current_block,
    bdev_t *target_bd, bdesc_t *target_block);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:chdapi} Partial \chdesc\ API.}
\end{figure}
% }}}

\Kudos\ \modules\ change blocks by attaching \chdescs\ to them, using functions
such as \texttt{patch\_create\_byte}.
%
Most file system modules initially generate \chdescs\ whose dependencies impose
soft-update-like ordering requirements (see \S\ref{sec:consistency:softupdate}).
These \chdescs\ are then passed down, through other modules, in the general
direction of the disk. The intervening \modules\ can inspect, delay, and even
modify them before passing them on further. For instance, the write-back cache
\module\ (\S\ref{sec:modules:wbcache}), essentially a buffer cache, holds on to
blocks and their \chdescs\ instead of forwarding them immediately. Each
delay-inducing \module\ increases its \module\ level by one over the module(s)
it uses, starting at zero.
%
When writing a block and associated \chdescs, the write-back cache enforces an
order consistent with the \chdesc\ dependency information. Specifically,
\cdinvar{before-levels}{The \befores\ of a \chdesc\ at level $l$ are at levels
$\leq l$.}

When a \module\ asynchronously writes the data associated with a set of
\chdescs\ to stable storage it marks the \chdescs\ as \emph{in flight} to
indicate that the \chdescs\ are considered to still have their previous,
higher, level. Their \afters\ will therefore remain at that level (or higher),
thus correctly implementing the dependency structure. A \chdesc\ is
\emph{satisfied} when its associated data reaches stable storage.

Each \chdesc\ on a block may or may not be visible to a given \module.
%
For example, modules that respond to user requests generally view the most
current state of every block -- the block with all \chdescs\ applied.
%
However, a write-back cache may choose to write some \chdescs\ on a block
while reverting others, since those others currently have unsatisfied
\befores.
%
In this case, \modules\ below the write-back cache should view the
unsatisfied \chdescs\ in the reverted state.
%
\Kudos\ provides a block revisioning library function that automatically
rolls back those \chdescs\ that should not be visible at a particular \module,
and then rolls them forward again after that \module\ is done with the block.

% {{{ sec:chdescs:bit
\subsection{Bit \ChDescs}
\label{sec:chdescs:bit}
A bit \chdesc\ is a specialized \chdesc\ that expresses small changes
more efficiently than than the general byte \chdesc\, using an inline
mask instead of a pointer to a copy of previous data to support rollbacks.
% }}}

% {{{ sec:chdescs:noop
\subsection{\Noop\ \ChDescs}
\label{sec:chdescs:noop}
The prototypical \chdesc\ corresponds to some change on disk, but \Kudos\
also supports a \emph{\noop} \chdesc\ type, which doesn't change the disk
at all. \Noop\ \chdescs\ can have \befores, like any other
\chdesc, but they don't need to be written to disk:  they are trivially
satisfied when all of their \befores\ are satisfied.
%
Thus, they can be used to ``stand for'' entire sets of other changes.
%
This capability is extremely useful, and is used by most operations on disk
structures so that a single \chdesc\ can be returned that depends on the whole
change. Likewise, \anoop\ \chdesc\ can be passed in as a parameter to a disk
operation to make the whole operation depend on a set of other changes. \Noop\
\chdescs\ allow dependencies between sets without a quadratic number
of dependency edges in the \chdesc\ graph, and without having to pass around
arrays of \chdescs.
%
The cost is that some functions may have to traverse trees of \noop\ \chdescs\
to determine true dependencies.
%
\Anoop\ \chdesc's level is defined to be the max level of its \befores;
in effect, propagating \anoop\ \chdesc's \befores\ to its \afters.

Modules can also use \noop\ \chdescs\ to \emph{prevent} changes from being
written.
%
A \emph{managed} \noop\ \chdesc\ must be explicitly satisfied; any changes that
depend on that \noop\ \chdesc\ are delayed until the owning module explicitly
satisfies it.
%
This is used, for instance, by the journal \module\
(\S\ref{sec:consistency:journal}) to prevent a transaction's \chdescs\
from being written before the journal commits.
% }}}

% {{{ sec:chdescs:optimizations
\subsection{\ChDesc\ Optimizations}
\label{sec:chdescs:optimizations}

Here we describe \chdesc\ optimizations that speed \chdesc\ state
queries through incremental cache updates
%
and lower \chdesc\ memory overhead by
%
providing specialized \chdescs,
%
expressing dependencies more efficiently,
%
omitting unneeded rollback information,
%
and merging \chdescs.

Mention these?:
%
Each block has a list of \chdescs\ on that block.
%
Each block has a list of \chdescs\ on that block that are ready to be
moved down by one level.
%
Each block has a list of \chdescs\ that are not entirely overlaped.

% {{{ formalisms
\subsubsection{Initial formalisms}

\noindent\\ Invariants:
\cdinvar{a}{If \indirdepends{a}{b} then \notindirdepends{b}{a}.}

\cdinvar{b}{If \(\indirdepends{a}{b} \land \inset{a}{\psetinflight{t}}\)
then \(\inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}}
\land \blockof{a} = \blockof{b})\).}

\noindent Want invariant:
\cdinvar{c}{If \(\inset{a}{\psetsat{t}} \land \indirdepends{a}{b}\)
then \inset{b}{\psetsat{t}} }

\noindent At any time $t$, one of the following transformations may be applied:
\begin{enumerate}
\item For some \block{w}:\\
Let \(\pset{B} = \{a\ |\ \inset{a}{\psetinflight{t}} \land \blockof{a} = \block{w} \}\) in\\
\(\psetsat{t+1} := \psetsat{t} \cup \pset{B}\)\\
\(\psetinflight{t+1} := \psetinflight{t} \setminus \pset{B}\)
\label{action:write}

\item \(\deps{t+1} := \deps{t} \cup\ \pset{X}\) where
\(\notinset{a}{\psetall{t}} \land \pset{X} \subset \{\depends{a}{b}\}\)\\
\(\psetall{t+1} := \psetall{t} \cup\ \{a\}\)
\label{action:create}

\item \(\psetinflight{t+1} := \psetinflight{t} \cup \{a\}\) for some
\notinset{a}{\psetsat{t}} s.t. \(\forall b: \indirdepends{a}{b},\
\inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}} \land
\blockof{a} = \blockof{b}\)
\label{action:fly}
\end{enumerate}

We can prove that invariants~\ref{cdinvar:a} and~\ref{cdinvar:b}
with actions~\ref{action:write}, \ref{action:create}, and~\ref{action:fly}
imply that invariant~\ref{cdinvar:c} holds.

\noindent Action~\ref{action:create} replacements for hard patches:
\begin{enumerate}
\item \(\deps{t+1}\ := \deps{t} \cup\ \pset{X}\) for
\(\notinset{a}{\psetall{t}} \land \pset{X}\! \subset\!
\{\depends{a}{b}\ |\ \inset{b}{\psetall{t}}\}\)\\
\(\psetall{t+1} := \psetall{t} \cup\ \{a\}\)

\item \(\psethard{t+1}\ := \psethard{t} \cup \{a\}\) where \(\forall b\!:
\indirdepends{b}{a},\ \blockof{b} = \blockof{a}\)
\end{enumerate}

\noindent Action~\ref{action:fly} replacements for hard patches:
\begin{enumerate}
\item \(\psetinflight{t+1} := \psetinflight{t} \cup \{a\}\) for
\notinset{a}{\psetall{t} \cup \psethard{t}}\\
\(\forall b\!: \indirdepends{a}{b},\ \inset{b}{\psetsat{t}} \lor (\inset{b}{\psetinflight{t}} \land \blockof{a} = \blockof{b})\)\\
\(\not\exists\inset{b}{\psethard{t}}\ \mbox{s.t.}\ \blockof{b} = \blockof{a}\)

\item For some \block{w}:\\
\(\psetinflight{t+1} := \psetinflight{t} \cup \pset{X}\) for
\(\pset{X} = \{\inset{a}{\psethard{t}}\ |\ \blockof{a} = \block{w}\}\)\\
\(\forall \notinset{b}{\pset{X}}\!: \forall \inset{a}{\pset{X}}\!:
\indirdepends{a}{b},\ \inset{b}{\psetsat{t}} \lor
(\inset{b}{\psetinflight{t}} \land \blockof{a} = \blockof{b})\)\\
\(\psethard{t+1} := \psethard{t} \setminus \pset{X}\)
\end{enumerate}
% }}}

% {{{ precalculation
\subsubsection{Scalable Dependency-Preserving Writes}
For a \module\ like the write back cache to forward \chdescs\ in a
dependency-preserving order, the \module\ must find \chdescs\ whose
\befores\ are on a lower block device (or are part of the block write
and on the current block device). Because the write back cache
frequently searches for and writes many ready \chdescs, redundant
\before\ traversals to calculate \chdesc\ ready state would severly
limit cache size scalabity.
%
\Kudos\ therefore
%
1) explictly tracks a \chdesc's \before\ counts through incremental
dependency updates
%
and 2) uses these counts to maintain a \chdesc\ ready list for each
block.

A \chdesc's \before\ counts are incrementally updated
%
as \befores\ are added and removed
%
and as \beforing\ \chdesc's change levels.
%

Due to invariant~\ref{cdinvar:before-levels}, only directly reachable
\beforing\ \chdescs\ need to be included in a \chdesc's \before\ counts.
%
Note that because \anoop\ \chdesc's level is a function of its \befores,
%
\anoop\ \chdesc\ \before\ count update that changes the \noop\ \chdesc's level
must propagate the level change to the \noop\ \chdesc's \afters.
%
When a \before\ count update changes whether a \chdesc\ is ready to
write, the \chdesc's inclusion in its block's ready list is updated.
%
To write a block, an owner thus iterates through the block's ready
list, moving \chdescs\ to the target block device, until the list is
empty.

TODO: Include invariants that the max \before\ level computation is
$O(1)$ or that ready \chdescs\ can be moved in $\sim\! O(r)$ time?
% }}}

% {{{ nrb chdescs
\subsubsection{\Nrb\ \ChDescs}
To enable byte \chdesc\ rollback, each byte \chdesc\ contains a copy
of the previous block data.
%
While these copies are needed to roll back byte \chdescs, many
\chdescs\ are never actually rolled back (e.g. file data blocks) and
previous data copies nearly double the memory usage of \chdescs\ and
\bdescs.
%
\Kudos\ addresses this issue by identifying those \chdescs\ which will
never need to be rolled back, and omitting the previous data copies for
them. We call these \emph{\nrb} \chdescs. (The opposite naturally being
a \emph{\rb} \chdesc, when necessary to differentiate them.)

To identify potential \nrb\ \chdescs, \Kudos\ uses a conservative algorithm
based on a \chdesc\ graph invariant. Merely detecting that the current
\chdesc\ graph can be written without rolling back a particular \chdesc\ is
not sufficient, as the graph may change in the future. Thus we need an
invariant which will guarantee that future changes to the graph will not
require \nrb\ \chdescs\ to be rolled back, where \nrb\ \chdescs\ are
selected based on some property of the current graph.

\cdinvar{add-before}{All block-level cycles induced through
\chdesc\ $C$'s \befores\ exist when $C$ is
created\todo{Change this phrasing? ``Once created, a \chdesc\ will not
gain any \befores\ that induce block-level cycles.''}.}
%
\Kudos\ ensures this invariant by restricting \before\ additions to
\chdesc\ creation, \noop\ \chdescs\ with no \afters, or when the invariant
is statically proven to hold.

To avoid a costly dependency traversal to determine whether a new
\chdesc\ will need to be rolled back, \Kudos\ conservatively identifies
a new \chdesc\ as \nrb\ only if the block has no \chdescs\
with external (on a different block\todo{Descriptive enough? Mention
\noop\ \chdesc\ \after\ recursion?}) \afters. Each block tracks the number of
external \afters\ through incremental updates as \afters\ are added and
removed.
% }}}

% {{{ overlap merging
\subsubsection{\ChDesc\ Merging}
\Kudos\ drastically reduces the number of \chdescs\ created to
describe a system of changes by (conservatively) identifying when a
second \chdesc\ may safely be written at the same time as an existing
\chdesc\ and, instead of creating the second \chdesc, updating the
existing \chdesc's disk change and dependencies; in effect, merging
the two \chdescs.
%
In this section we describe overlapping \chdesc\ merging; after
introducing \nrb\ \chdescs\ in the next section we describe
two additional merge opportunties.
%
All three merge rules build on invariant~\ref{cdinvar:add-before}
and use fast, conservative checks during \chdesc\ creation to identify
\chdescs\ that will be possible to write together;
%
the merge rules differ in their conservatively applicable conditions.

Bitmap blocks and inode size fields accumulate many nearby and
overlapping mergeable \chdescs\ as data is appended to a file.
%
Many of these and similar \chdescs\ are mergeable and have
dependencies that allow simple (and fast) reasoning to identify many
of the mergeable pairs: two \chdescs\ that overlap no other \chdescs\
and which have no dependency path from the new to the existing \chdesc\
will not induce a block-level cycle and so are writeable together.
We know that \textit{later} changes will not cause them to induce a block-level cycle due to
invariant~\ref{cdinvar:add-before}.
%
While path existance testing is expensive, testing only whether the new
\chdesc\ has a \before\ with a \before\ identifies most mergeable
\chdescs. \ldots

This section's key points:
Rule: exactly one overlap and new \before\ does not depend on overlap.
Overlapping makes it easy (but could extend chdescs so that they do overlap).
Gain new \before\ (if not the overlap).
% }}}

% {{{ nrb merging
\subsubsection{\Nrb\ \ChDesc\ Merging}
\label{sec:chdescs:optimizations:nrb-merge}
Notice that two \nrb\ \chdescs\ on a block must be committed
in the same revision slice; neither can (or will need to) be rolled
back. This illustrates the underlying reason why two \nrb\
\chdescs\ can be merged into a single \nrb\ \chdesc.
%
While no block-level dependency cycles can be induced by a merge,
without sufficient care a merge could induce \chdesc-level
dependency cycles. A trivial example is merging \nrbof{B} into \nrbof{A}
when \nrbof{B} has an explicit dependency on \nrbof{A}; the combined
\nrbof{(A+B)} should not and need not depend on itself. The dependency
addition and \nrb\ \chdesc\ creation rules restrict the
possible dependencies involving \nrbof{A} and \nrbof{B} to \textit{only}
those shown in Figure~\ref{fig:nrb-merge}\todo{Should we give these
deductions or a flavor?}. From these possible dependencies follows
an algorithm that recurses \nrbof{B}'s \before\ dependency chains until an
external \chdesc\ is encountered and that for each \ncd{C} along the
chain with a \before\ path to \nrbof{A}, moves all of \ncd{C}'s \befores\
without \before\ paths to be \befores\ of \nrbof{A}\todo{This could be more
lucid.} This graph manipulation preserves the system's \chdesc\
dependencies.

\Nrb\ \chdescs, \Rb\ \chdescs, and ready lists:
%
all post-NRB created \chdescs\ depend on NRB because of overlaps.
%
no NRB-prior created \chdescs\ exist (RB->NRB).
%
single NRB.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \nrbof{B} into \nrbof{A}.}
  \label{fig:nrb-merge}
\end{figure}

TODO: talk about why \nrb\ \chdescs\ slow down revision slice creation or talk
about how we detect RB$\rightarrow$NRB changes and then do \nrb\ \chdesc\ merges
to avoid this slowdown.

Say something along the lines:
%
The dynamic optimizations facilitated through \nrb\
\chdescs\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we include memory/performance improvement numbers?}
\todo{Should we talk about why we allow NRBs to be disabled? (Debugging
simplicity and depend add to \noop\ \chdescs\ with \afters\ bug catching.)}

\cdinvar{extern-after}{Each block tracks the total number of
external \afters\ for \chdescs\ on that block.}

\cdinvar{one-nrb}{Each block has at most one \nrb\ \chdesc.}
% }}}
% }}}

% {{{ sec:chdescs:discussion
\subsection{Discussion}
\label{sec:chdescs:discussion}

\subsubsection{Unnecessary \ChDesc\ Dependencies}
Even with \Kudos\ dynamically optimizing \chdesc\ graphs, there is only so much
that can be done while preserving the semantics of the dependencies specified by
the \module\ which created the \chdescs. It is obvious that having too few
dependencies compromises the correctness of the system; it is perhaps less
obvious but no less true that having too many dependencies can nontrivially
degrade the performance of the system.

In Figure~\ref{fig:chdescarrange}, we have two possible arrangements for three
byte \chdescs. The \noop\ \chdesc\ represents a root node that can reach all
other \chdescs. In the parallel arrangement on the right, \Kudos\ has the
freedom to write \chdescs\ $C_1$, $C_2$, and $C_3$ to disk in any order. In the
serial arrangement on the left, there exists only one valid write ordering.
Depending on the arrangement of other \chdescs, \Kudos\ may have to perform
additional rollbacks and write some blocks more times than would otherwise be
necessary in order to write these \chdescs\ to disk. Even if that is not
necessary, \Kudos\ will still have less flexibility in choosing an order to
write the blocks, potentially increasing disk seek times due to suboptimal
ordering.

\begin{figure}[htb]
  \centering
  \includegraphics[width=192pt]{fig/figures_6}
  \caption{\label{fig:chdescarrange} \Chdesc\ dependencies, when
  not strictly needed, restrict the possible choices for write ordering.
  This results in suboptimal write ordering and more scans through the
  \chdescs\ for \Kudos. On the right, \chdescs\ C1, C2, and C3 can be written
  in any order. Only one ordering is possible on the left.}
\end{figure}

Even when no unnecessary dependencies are explicitly created, they can still be
created implicitly and care must be taken to avoid them. When \chdescs\ overlap,
the later \chdesc\ is made to depend on the first so that it cannot precede the
change it is changing further to disk. As a result, however, unnecessary
dependencies may result if the \chdescs\ are larger than the data they are
actually changing. In Figure~\ref{fig:overlap}, to update a field in an inode
structure on disk, a \chdesc\ spanning the entire inode could be created even
though only a single field changed. A later change to a different field would
appear to overlap the first, creating an unnecessary dependency. Creating
\chdescs\ which correspond more precisely to the changes being made avoids this
problem, so a utility function is provided by \Kudos\ to make this operation as
convenient as creating a single \chdesc\ for an entire large structure.

\begin{figure}[htb]
  \centering
  \includegraphics[width=64pt]{fig/figures_5}
  \caption{\label{fig:overlap} On inode 17, the gray regions represent
  modified fields that do not overlap. If \chdesc\ A and \chdesc\ B are
  exactly the size of the gray regions, then there is no implicit dependency.
  However, making \chdescs\ for the entire inode data structure will make
  one \chdesc\ depend on the other because they overlap.}
\end{figure}
% }}}
