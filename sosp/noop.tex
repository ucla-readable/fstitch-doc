% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{\Kudos\ Interface and \Noop\ \Patches}
\label{sec:patch:noop}

\def\_{{\ttfamily\char`\_}}

\Kudos\ \modules\ create \patches\ with functions like \texttt{patch\_\-create\_\-byte}.
%
Arguments to these functions include the relevant block ($\PBlock{p}$), any
direct dependencies ($\PDDepset{p}$), and the new data represented by the
\patch.
%
Most \patches\ specify the new data as a contiguous byte range, including an
offset into the block and the \patch\ length in bytes.
%
The rollback data for very small \patches\ (4 bytes or less) is stored in the
\patch\ structure itself; for larger \patches, rollback data is stored in
separately allocated memory.
%
As a useful special case, \patches\ that flip one or more bits in a word (for
instance, in a free block bitmap) are represented specially.


The \Kudos\ core automatically detects one special type of dependency.
%
If two \patches\ $p$ and $q$ affect the same block and have overlapping data
ranges, and $p$ was created before $q$, then \Kudos\ adds an \emph{overlap
dependency} $q \PDDepend p$ to ensure that $p$ is written before $q$.
%
There's no need for file system modules to detect and enforce such
dependencies themselves.


For each block $b$, \Kudos\ maintains a list of all \patches\ with
$\PBlock{p} = b$.
%
However, the implementation does not keep track of on-disk \patches; when
\patch\ $p$ commits, \Kudos\ destroys $p$'s data structure and removes all
dependencies $q \PDDepend p$.
%
The resulting behavior follows our model.
%
For each \patch\ $p$, \Kudos\ maintains lists of its direct dependencies (all
$q$ where $p \PDDepend q$) and its direct ``reverse dependencies'' (that
is, all $q$ where $q \PDDepend p$).


\Kudos\ also supports \emph{\noop} \patches, which have
 no associated data or block.
%
\Noop\ \patches\ are useful for representing sets of dependencies and for
 preventing other \patches\ from being written.
%
For example, while a journal transaction is being populated in a journaling
 file system, many changes to the main body of the disk should depend on a
 journal commit record that has not yet been created.
%
\Kudos\ therefore makes these \patches\ depend on a ``managed'' \noop\ \patch\
 that is explicitly held in memory.
%
Once the commit record is created, the \noop\ \patch\ is updated to depend on
 the actual commit record and then released.
%
Once the commit record is written, the \noop\ \patch\ is automatically
 ``written'' as well, which allows the main file system changes to follow.
%
Some aspects of our model would have to change to handle \noop\
 \patches; for example, the in-flight safety property would change to:
%
\[ \PDepset{\PInf[b]} \subseteq \PInf[b] \cup \PDisk \cup \PEmpty. \]
%
We call a \patch\ \emph{true} if it is not \noop.


\Noop\ \patches\ both aid and hurt performance.
%
On the one hand, \noop\ \patches\ can represent quadratic sets of dependencies
 with a linear number of edges: if all $m$ \patches\ in $P$ must depend on
 all $n$ \patches\ in $Q$, one could 
 %% add $mn$ direct dependencies $p_i \PDDepend q_j$ or
 add an \noop\ \patch\ $x$ and $m+n$ direct dependencies
 $p_i \PDDepend x \PDDepend q_j$.
%
(This is useful for \patchgroups, described in \S\ref{sec:patchgroup}.)
%
On the other hand, some functions may have to traverse trees of \noop\
 \patches\ to determine true dependencies.


\begin{comment}
To solve this problem, we introduce an additional type of \patch. The
prototypical \patch\ corresponds to some change on disk, but \Kudos\ also
supports \aemphnoop\ \patch\ type, which doesn't change the disk at all.
\Noop\ \patches\ can have \befores, like other \patches, but they don't need to
be written to disk: they are trivially satisfied when all of their \befores\ are
satisfied. Thus, they can be used to ``stand for'' entire sets of other changes.
%
This capability is extremely useful, and is used by most operations on disk
structures so that a single \patch\ can be returned that depends on the whole
change. Likewise, \anoop\ \patch\ can be passed in as a parameter to a disk
operation to make the whole operation depend on a set of other changes. \Noop\
\patches\ allow dependencies between sets with only a linear number of
dependency edges in the \patch\ graph, and without having to pass around arrays
of \patches.
%
The cost is that some functions may have to traverse trees of \noop\ \patches\
to determine true dependencies.
\end{comment}
