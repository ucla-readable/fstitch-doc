% -*- mode: latex; tex-main-file: "paper.tex" -*-

\paragraph{Soft updates}
\label{sec:using:softupdate}

\begin{comment}
% This paragraph is basically replicated in sec:patch:examples
%% Generally, a file system image is consistent if a program like \emph{fsck}
%% would report no errors -- that is, all the structures are in a completely
%% correct organization.  
%
Soft updates enforces orderings between disk writes that maintain
a ``relatively consistent'' file system state at all times, speeding
reboot by avoiding \emph{fsck}.
%
Not all invariants can be preserved, so soft updates relaxes the least
critical: a crash or sudden reboot can leak blocks or other disk
structures, but will never create inconsistencies that could lead to
metadata corruption.
%
%% It is not generally possible to maintain this invariant,
%% so in the ``soft updates''~\cite{ganger00soft} system this definition is
%% relaxed slightly by allowing some structures (like inodes or disk blocks) to be
%% marked as allocated even though there are no references to them. The key
%% observation is that this will not cause any harm beyond making the structures
%% unusable until they are discovered and reclaimed, which can be done safely in
%% the background while the file system is in use.
%
%% This relaxed consistency invariant can be implemented by carefully ordering the
%% writes to the disk. A simple set of rules governing the order for writes,
%% mostly consisting of the idea that a structure should never be marked free
%% while a reference to a structure still exists on the disk, accomplishes this
%% easily. 
%
\end{comment}
In the BSD UFS implementation of soft updates, each UFS operation is
represented in memory by a structure encapsulating the disk changes
necessary to implement that operation. As a result, many
specialized data structures represent the different possible file system
operations. These structures, their relationships to one another, and their uses
for tracking and enforcing dependencies are quite
complex~\cite{mckusick99soft}.

\Kudos, in contrast, represents all dependencies by \patches\ and relies on
general optimizations to reduce memory usage.
%
The resulting system is not as optimized as the BSD implementation, but
much simpler to specify and easier for other modules to manipulate.
%
The \patches\ that make up a file system operation are connected to specify
the order in which the changes must be written to disk.
%
For instance, most file systems require at least two \patches\ to remove
a block from a file, one ($p$) to clear the block reference from the file's
block list and one ($q$) to mark the block as free; adding the $q \PDDepend
p$ dependency straightforwardly implements soft updates semantics.
%
Another example is given in Section~\ref{sec:patch:examples}.

\begin{comment}
Figure~\ref{fig:softupdate} shows another example, the \patches\ generated in
UFS when a file is extended by one block.\footnote{The dependencies differ
from the ext2 dependencies for a similar operation in Figure~\ref{f:opt}
because of a difference in file system semantics.}

\begin{figure}[t]
  \centering
  \includegraphics[width=92pt]{fig/figures_3}
  \caption{\label{fig:softupdate} Soft updates \patches\
  for extending a UFS inode by one block.
  Attaching the block pointer to the inode depends on
  initializing the block (Clear) and updating the free block map (Alloc).
  Updating the inode's size depends on writing the block
  pointer.}
\end{figure}
\end{comment}

%% The difference between soft updates and \Kudos\ is that soft updates tracks
%% these updates to the disk image at the level of file system operations, which
%% are specific to the file system in use (which, in practice, is FFS), while
%% \Kudos\ represents the changes in a file system independent way.

\begin{comment}
The \Kudos\ approach can take more memory than the BSD soft updates approach,
which limits the state required by any individual file system operation; we do
not yet address the issue of memory exhaustion.
%
However, \Kudos\ separates dependency enforcement from dependency
specification. This makes the actual implementation easier to read, and allows
the dependency structure to be examined and modified by other \modules\ of the
system that may not have any idea what the changes are actually doing.
\end{comment}
