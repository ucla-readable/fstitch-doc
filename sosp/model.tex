\subsection{Notation}
\label{sec:chdescs:notation}

It will be convenient to introduce some notation for dealing with \chdescs.
First we will define a set \ChAll\ of all \chdescs. Although in the actual
implementation we destroy \chdescs\ when they are no longer necessary (i.e. when
they have successfully been written to the disk), \ChAll\ contains all \chdescs,
written to disk or not. We also define sets \ChMem\ and \ChDisk, which contain
all \chdescs\ only in memory or already on the disk, respectively. Next, we
define a set \ChInf\ which contains all \chdescs\ that are currently ``in
flight'' to the disk: block data reflecting their contents has been sent to the
disk controller but has not yet been written to the disk media itself. Finally,
we will also write \ChAllB{B}, \ChMemB{B}, \ChDiskB{B}, and \ChInfB{B} to
succinctly represent the subsets of these four sets specifically associated with
disk block $B$.

If we have some \chdesc\ \p{p}, we can also refer to its block or state using a
``member'' notation as in many programming languages: \p{p}.block is the block
modified by \p{p}, and \p{p}.state is its state (one of \statenone, \stateinf,
or \statedisk). We write \depends{\p{p}}{\p{q}} if \p{q} is listed as a \before\
of \p{p} (that is, if \p{p} directly depends on \p{q}), and
\indirdepends{\p{p}}{\p{q}} if there is some path of \befores\ from \p{p} to
\p{q} (that is, if \p{p} indirectly depends on \p{q}).

The last bit of notation we'll need is for representing sets of \chdescs\
related by the dependency graph. We'll write \Before{p} to represent the set of
all \chdescs\ \p{q} such that \depends{p}{q}, and \BeforeS{p} for the set of all
\chdescs\ \p{q} such that \indirdepends{p}{q}. Likewise, \After{p} is the set of
all \chdescs\ \p{q} such that \depends{q}{p}, and \AfterS{p} is the set of all
\chdescs\ \p{q} such that \indirdepends{q}{p}. These four operators can also be
applied to sets of \chdescs: in that case, the resulting set is the union of the
results of applying the same operator to each element of the operand set.

\subsection{Formal Model}
\label{sec:chdescs:model}

We can model the interaction between the disk (and its controller) and the
software maintaining the \chdesc\ graph by a set of randomly occurring events
that change the state of \chdescs\ according to simple rules. By stipulating
that each event may occur at any time when its preconditions are met, we can
reason about all possible hardware behavior and all possible software
algorithms. Here are the three possible events:

\paragraph{Create new \chdesc}
For some \chdesc\ \p{p} $\not\in$ \ChAll\: \\
Let \p{p}.state $:=$ \statenone \\
Let \depends{\p{p}}{\p{q}} for all \p{q} $\in Q$ where $Q \subseteq$ \ChAll %\\
% Let \ChAll\ $:=$ \ChAll\ $\cup$ \{\p{p}\}

\paragraph{Write block to disk controller}
For some block $B$: \\
Let $P \subseteq$ \ChMemB{B} such that \BeforeS{P} $\subseteq$ \ChDisk\ $\cup\ P$ \\
Let \p{p}.state $:=$ \stateinf\ for all \p{p} $\in$ $P$

\paragraph{Disk writes block to media}
For some block $B$: \\
Let \p{p}.state $:=$ \statedisk\ for all \p{p} $\in$ \ChInfB{B}

\paragraph{} It is not difficult to prove based on the events above that a
fundamentally important safety property is maintained, namely that
\BeforeS{\ChDisk} $\subseteq$ \ChDisk. In essence, the system honors the
dependency information correctly. A second, and related, safety property is that
\BeforeS{\ChInfB{B_1}} $\cap$ \ChInfB{B_2} $= \emptyset$ for all $B_1 \neq B_2$.
This means that none of the currently in-flight blocks depend on any of the
other currently in-flight blocks, so the disk, disk controller, and disk driver
are all free to reorder them any way they see fit.

A third property of the events above is that if at some point we never see the
first event again, eventually we can get to a state where \ChDisk\ $=$ \ChAll.
This is a liveness property; namely, that eventually all the \chdescs\ will make
it to disk.

\Kudos\ controls when the first two events occur, but is notified of the third
event by the disk driver when it occurs. Depending on the hardware
configuration, the third event may actually represent one of two real-world
situations: first, the data may merely be in the volatile disk cache, so that a
power outage may cause it to be lost. This can be a catastrophic disaster, as
shown in~\cite{nightingale06rethink}. The second possible situation is that the
data is truly on the disk media, which can be arranged by disabling the drive's
write-back cache or by using hardware features like SCSI tagged command queueing
(TCQ) or SATA native command queueing (NCQ) together with their ``force unit
access'' (FUA) setting. In these configurations, \Kudos\ is notified of command
success only when the data has actually been written to the disk media. (Though
a small patch to the Linux kernel is required to support using FUA.) \Kudos\ can
be run in any of these four configurations, including the first, though
obviously the safety of the system is compromised in that case.
