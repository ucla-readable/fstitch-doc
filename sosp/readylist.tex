% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Ready \Patch\ Lists}
\label{sec:patch:readylist}

\newcommand{\PReady}[1]{\ensuremath{#1.\textit{ready}}}

Another important optimization greatly reduces CPU time spent in the
\Kudos\ buffer cache.
%
The buffer cache's main task is to choose sets of \patches\ $P$ that
satisfy the in-flight safety property $\PDepset{P} \subseteq P \cup
\PDisk$.
%
A naive implementation would simply traverse the dependency graph starting
at these patches, looking for problematic dependencies.
%
Patch merging can reduce the size of these traversals by combining patches
together.
%
Unfortunately, even modest traversals become painfully slow when executed
on every block in a large buffer cache, and in our initial implementation
these traversals were a performance bottleneck for even modest cache
sizes.
% 
\Featherstitch\ therefore precomputes much of the information
required for the buffer cache to choose a set of \patches\ to write.

\Kudos\ explicitly tracks, for each \patch, how many of its
direct dependencies remain uncommitted or in flight.
%
These counts are incremented as \patches\ are added to the system, and
decremented as the system receives commit notifications from the disk.
%
When both counts reach zero, the \patch\ is safe to write, and it is moved
into a \emph{ready list} on its containing block.
%
\begin{comment}
(\Noop\ \patches\ automatically commit when all their dependencies commit.)
\end{comment}
%
The buffer cache, then, can immediately tell whether any of a block's
patches are writable by examining its ready list.

To write a block $\PB$, the buffer cache initially populates the set $P$ with the
contents of the ready list.
%
While moving a patch $p$ into $P$, \Kudos\ checks whether there exist
dependencies $q \PDDepend p$ where $q$ is also on block $\PB$.
%
The system can potentially write $q$ at the same time as $p$, so $q$'s
counts are updated as if $p$ has already committed.
%
This may make $q$ ready, after which it in turn is added to $P$.
%
(This premature accounting is safe because the system won't try to write
$\PB$ again until $p$ actually commits.)


On-line maintenance of the ready counts adds some cost to several \patch\
manipulations, but since it saves so much duplicate work in the buffer
cache the resulting system is more efficient by multiple orders of
magnitude---and in particular, CPU time no longer scales superlinearly with
the size of the cache.


\begin{comment}
For a \module\ like the write-back cache to forward \patches\ in a
dependency-preserving order, the \module\ must find \patches\ whose \befores\
are all ``closer to the disk'' (or are also being forwarded as part of the same
block write). We say that such \patches\ are \emph{ready}. 


Each \patch\ has a count of the number of \befores\ it has at block device
modules just as close to the disk as it currently is, and a count of the number
of \befores\ it has which are in flight. When these counts are both zero, it is
ready. A \patch's \before\ counts are incrementally updated as \befores\ are
added and removed and as \beforing\ \patches\ are moved closer to the disk.

Because \Kudos\ makes sure that the \befores\ of a \patch\ are at least as
close to the disk as it is, only directly reachable \beforing\ \patches\ need to
be included in a \patch's \before\ counts. \Noop\ \patches, with the exception
of managed \noop\ \patches\ (which have an explicit owning block device), add a
wrinkle to this simplifying rule, however. They are considered to be as close to
the disk as their \before\ which is the farthest from the disk, in effect,
propagating the distance to the disk metric through them.

When a \before\ count update changes whether a \patch\ is ready to write, the
\patch's inclusion in its block's ready list is updated. To write a block, a
\module\ thus iterates through the block's ready list, sending \patches\ to the
target block device, until the list is empty. Thus instead of having to
repeatedly traverse \patch\ graphs to determine readiness on demand, we have
this information maintained automatically as it changes. This automatic
maintenance adds some cost to forwarding \patches\ and changing the graph
structure, but since it saves so much duplicate work\footnote{The amount of
duplicate work saved is actually superlinear in the size of the write-back
cache.} it is much more efficient.
\end{comment}
