% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section{\Patch\ Model}
\label{sec:patch}

\makeatletter
\let\emptyset\varnothing
%\newcommand{\PState}[1]{\ensuremath{#1.\textit{state}}}
%\newcommand{\PBlock}[1]{\ensuremath{#1.\textit{block}}}
%\newcommand{\PBlock}[1]{\ensuremath{B_{#1}}}
%\newcommand{\PBlock}[1]{\ensuremath{B[{#1}]}}
\newcommand{\PBlock}[1]{\ensuremath{\textit{blk}[{#1}]}}
%\newcommand{\PMemst}{\ensuremath{\textit{mem}}}
%\newcommand{\PInfst}{\ensuremath{\textit{flight}}}
%\newcommand{\PDiskst}{\ensuremath{\textit{disk}}}
\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else_{\@next}\fi}
%\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else\cap\@next\fi}
\newcommand{\PMem}[1][]{\ensuremath{\mathpatchset{U}\PSetlim{#1}}}
\newcommand{\PInf}[1][]{\ensuremath{\mathpatchset{F}\PSetlim{#1}}}
\newcommand{\PDisk}[1][]{\ensuremath{\mathpatchset{C}\PSetlim{#1}}}
\newcommand{\PHard}[1][]{\ensuremath{\textit{\Nrb}\PSetlim{#1}}}
\newcommand{\PSoft}[1][]{\ensuremath{\textit{\Rb}\PSetlim{#1}}}
\newcommand{\PEmpty}[1][]{\ensuremath{\textit{\Noop}\PSetlim{#1}}}
%\newcommand{\PDDepset}[1]{\ensuremath{\def\@next{#1}\ifx\@next\@empty\else\@next.\fi\textit{ddeps}}}
\newcommand{\PDDepset}[1]{\ensuremath{\textit{dep}_1[#1]}}
\newcommand{\PDepend}{\ensuremath{\leadsto}}
\newcommand{\PDDepend}{\ensuremath{\rightarrow}}
%\newcommand{\PDepset}[1]{\ensuremath{\textit{dep}[#1]}}
\newcommand{\PDepset}[1]{\ensuremath{\textit{dep}[#1]}}
\newcommand{\PRDepset}[1]{\ensuremath{\textit{RDep}[#1]}}
\makeatother

Every change to stable storage in a \Kudos\ system is represented by a
\emph{\patch}.
%
This section describes the basic \patch\ abstraction
 and describes our implementation of that abstraction.

\begin{comment}
%
%% Although the \patch\ idea would apply to any stable medium, to network file
%% systems, or to multiple disks, we use terms like ``the disk'' and ``the
%% disk controller'' throughout to simplify our terminology.
%
Each \patch\ $p$ encapsulates four important pieces of information: its
 \emph{block}, its \emph{state}, a set of \emph{direct dependencies}, and
 some \emph{undo data}.
\end{comment}

\subsection{Disk Behavior}

We first describe how disks behave in our model, and
 especially how disks commit patches to stable storage.
%
Although our terminology originates in conventional disk-based file systems
 with uniformly-sized blocks, the model would apply with small changes to
 file systems with non-uniform blocks and to other media, including RAID
 and network storage.

We assume data is committed to stable storage in units called
 \textbf{blocks}.
%
All writes affect one or more blocks, and it is impossible to selectively
 write part of a block.

A \textbf{patch} models any change to block data.
%
Each patch applies to exactly one block, so a file system change that
 affects $n$ blocks requires at least $n$ patches to represent.
%
Each \patch\ is either
 \textbf{committed}, meaning written to disk;
 \textbf{uncommitted}, meaning not written to disk;
 or \textbf{in flight}, meaning in the process of being written to disk.
%
The intermediate in-flight state models caching, reordering, and delay in
 the storage layer: blocks written by an operating system may be
 committed in any order, possibly
 after disk scheduling and a period in the on-disk cache.
%
Patches are created as uncommitted.
%
The operating system moves uncommitted \patches\ to the in-flight state
 by writing their blocks to the disk controller.  Some
 time later, the disk writes these blocks
 to stable storage and reports success; when the processor receives this
 acknowledgment, it commits the relevant patches.
%
Committed patches stay committed permanently, although their effects can
 be undone by subsequent patches.
%
The sets $\PDisk$, $\PMem$, and $\PInf$ represent all committed,
 uncommitted, and in-flight patches, respectively.
%
%% $p$'s state is written $\PState{p} \in \{\PMemst, \PInfst,
%% \PDiskst\}$.  
%
%% The sets \PMem, \PInf, and \PDisk\ are defined to contain all \patches\ with
%%  the given state, and 
%% The notation $\PMem[b]$ represents the subset of $\PMem$ with the given
%%  block $b$.

Patch $p$'s block is written $\PBlock{p}$.
%
Given a block $B$, we write $\PDisk[B]$ for the set of committed
 patches with block $B$, or in notation $\PDisk[B] = \{p\in\PDisk\mid\PBlock{p}=B\}$.
%
$\PInf[B]$ and $\PMem[B]$ are defined similarly.

%%  is represented as a set containing
%%  all patches that affect that block, including $p$ itself.
%% %
%% Thus, $\PBlock{p} \cap \PDisk$ is the set of committed patches on
%%  $p$'s block, and the block is dirty if and only if $\PBlock{p} \cap \PDisk
%%  \neq \PBlock{p}$.

We can now model disk controllers' behavior: they write in-flight patches one
 block at a time, as follows.
%
\begin{tabbing}
\qquad \quad 1. Pick some block $B$ with $\PInf[B] \neq \emptyset$. \\
\qquad \quad 2. Commit and acknowledge each patch in $\PInf[B]$.
\end{tabbing}
%
\noindent
%
Disks perform better when allowed to reorder requests, so operating systems
 try to keep many blocks in flight.
%
%% , as constrained by write-before
%% relationships.  (For instance, in-flight blocks cannot depend on each
%% other.)
%
Although file systems will generally write all of a block's uncommitted
 patches when they write the block, they may, if they choose, write a
 \emph{subset} of those patches---and, as we will see, this is sometimes
 required to preserve write-before relationships.
%% %
%% The effects of any unwritten patches must be
%%  temporarily undone during a block write.


We intentionally do not specify whether the storage system writes blocks
 atomically.
%
Some file system designs, such as soft updates, rely on block write
 atomicity:
%% Careful control over write-before relationships is \emph{necessary} to
%%  ensure consistency, but for some file system designs, such as soft
%%  updates, it \emph{suffices} only if the underlying storage system
%%  writes blocks atomically.
%
soft updates expects that if the disk fails while a block $B$ is
 in flight, then $B$'s value on recovery must equal either the old value or
 the new value.
%
Most journal designs do not require this, and include recovery procedures
 that handle in-flight block corruption---for instance, because the memory
 holding the new value of the block lost coherence before the disk stopped
 writing.
%
Since patches model the write-before relationships used to build these
 journal designs, patches do not provide block atomicity themselves, and
%% , for instance by buffering blocks in non-volatile memory before writing them to disk.
%
a patch-based file system with soft updates-like dependencies
 should only be used in conjunction with a storage layer providing block
 atomicity.  (This is no different from other soft updates
 implementations.)


\begin{comment}
This model does not completely define the disk's behavior on system crash,
 in particular with respect to in-flight blocks.
%
%
Most journal designs do not rely on this assumption, and can recover
 properly even if in-flight blocks are corrupted---for instance,
 because the memory holding the new value of the block lost its coherence
 before the disk stopped writing~\cite{nightingale06rethink}.
%
However, some disks may actually provide an atomicity guarantee, for
 instance by using non-volatile memory to store blocks before they make it
 onto disk.
%
The \Kudos\ core makes no assumptions about block atomicity, instead relying
 on software above it to implement a consistency protocol that makes sense
 for the given disk.
\end{comment}


\begin{figure}[t]
\centering
\begin{small}
\begin{tabular}{@{}l@{~~~}l@{}}
$p$     & a patch \\
$\PBlock{p}$ & patch $p$'s block \\
% $\PState{p}$ & $p$'s state, $\in \{\PMemst, \PInfst, \PDiskst\}$ \\
\noalign{\vskip3pt}
$\PDisk, \PMem, \PInf$ & the sets of all committed, uncommitted, and in-flight \\
        & \patches, respectively \\
$\PDisk[B], \PMem[B], \PInf[B]$ & committed/uncommitted/in-flight patches on block $B$ \\
\noalign{\vskip3pt}
$q \PDepend p$ & $q$ depends on $p$ ($p$ must be written before $q$) \\
$\PDepset{p}$ & $p$'s dependencies: $\{ x \mid p \PDepend x \}$ \\
\noalign{\vskip3pt}
$q \PDDepend p$ & $q$ directly depends on $p$ \\
	& ($q\PDepend p$ means either $q\PDDepend p$ or $\exists x : q \PDepend x \PDDepend p$.) \\
$\PDDepset{p}$ & $p$'s direct dependencies: $\{ x \mid p \PDDepend x \}$ \\
\end{tabular}
\end{small}

\caption{\Patch\ notation.}
\label{fig:patchnot}
\end{figure}


\subsection{Dependencies}

A patch-based storage system implementation represents write-before
 relationships using an explicit \textbf{dependency} relation.
%
The disk controller and lower layers don't understand dependencies; instead,
 the system
 maintains dependencies and passes blocks to the controller in an
 order that preserves dependency semantics.
%
Patch $q$ \emph{depends on} patch $p$, written $q \PDepend p$,
 when the storage system must commit $p$ before $q$.
%
(As a special case, if $p$ and $q$ are on the same block, they may be
 committed at the same time.)
%
The file system creates dependencies that express its desired consistency
 semantics.
%
For example, a file system with asynchronous writes (and no durability
 guarantees) might create \patches\ with no dependencies at all;
%
a file system wishing to strictly order writes might set
 $p_n \PDepend p_{n-1} \PDepend \cdots \PDepend p_1$.
%
%% In practice, an upper \Kudos\ layer defines an initial set of
%%  dependencies;
%% %
%% intermediate layers mostly preserve this initial set, but can modify
%%  it as necessary to change dependency semantics;
%
%% and finally, the buffer cache obeys the constraints thus defined.
%
Circular dependencies among patches cannot be resolved and are therefore
 errors;  for example, neither $p$ nor $q$ could be written before the
 other if $p \PDepend q \PDepend p$.
%
(Although a circular dependency chain entirely within a single block avoids
 this problem, \Kudos\ treats all circular chains as errors.)
%
\Patch\ $p$'s \emph{set} of dependencies, written $\PDepset{p}$, consists
 of all patches on which $p$ depends;
%
\( \PDepset{p} = \{ x \mid p \PDepend x \}. \)
%
Given a set of \patches\ $P$, we write $\PDepset{P}$ to mean the
 combined dependency set $\bigcup_{p\in P} \PDepset{p}$. 


The \textbf{disk safety property} formalizes dependency requirements by
 stating that the dependencies of all committed \patches\ must have been
 committed:
%
\[ \PDepset{\PDisk} \subseteq \PDisk. \]
%
Thus, no matter when the system crashes, the disk is consistent in terms of
dependencies.
%
%% The file system's job is to set up dependencies so that the disk safety
%% property implies file system correctness.
%
\begin{comment}
 However, \Kudos\ can only control when \patches\ are handed to the disk
 controller, not when they are written to disk.
 %
 Disk controller behavior is encapsulated in the following atomic action:

 \begin{tabbing}
 \textit{Commit block:} \\
 \quad Pick some block $b$ with $\PInf[b] \neq \emptyset$. \\
 \quad Move each $p \in \PInf[b]$ to $\PDisk$ (committed).
 \end{tabbing}
\end{comment}
%
Since, as described above, the disk controller can write blocks in any
 order, a \Kudos\ storage system must also ensure
that in-flight blocks are independent.  This is precisely stated
by the \textbf{in-flight safety property:}
%
\[ \text{For any block $B$,~~} \PDepset{\PInf[B]} \subseteq \PDisk \cup \PInf[B] . \]
%
\begin{comment}
%% Do we need this comment?
(The union with $\PInf[B]$ is necessary for the case of multiple in-flight
\patches\ on the same block.)
\end{comment}
%
Given this, $\PDepset{\PInf[B]} \cap \PDepset{\PInf[B']} \subseteq \PDisk$ for
 any $B' \neq B$, and the disk controller can write in-flight blocks
 in any order and still preserve disk safety.
%
Finally, to uphold the in-flight safety property, the buffer cache must
 write blocks as follows:
%
\begin{tabbing}
\quad \quad Pick some block $B$ with $\PMem[B] \neq \emptyset$ and $\PInf[B] =
\emptyset$. \\
\quad \quad Pick some $P \subseteq \PMem[B]$ with $\PDepset{P} \subseteq P \cup
\PDisk$. \\
\quad \quad Move each $p \in P$ to $\PInf$ (in-flight).
\end{tabbing}
%
\noindent
%
We require that $\PInf[B] = \emptyset$ to ensure that at most one version of
 a block is in flight at any time.

In summary, the main \Featherstitch\ implementation challenge is to design
 data structures that make it easy to create patches, quick to manipulate
 patches, and that help the buffer cache write blocks and patches in line
 with the above procedure.
%
(The buffer cache is also expected to write all blocks eventually, a
 liveness property.)


\subsection{Dependency Implementation}



\begin{figure*}[t]
\centering
\begin{tabular}{@{}cc@{\qquad\qquad}c@{}}
\includegraphics[scale=0.78]{fig/examplesb_3}
& \includegraphics[scale=0.78]{fig/examplesb_4}
& \includegraphics[scale=0.78]{fig/examplesb_2} \\
\textbf{a)} Adding a block (soft updates)
& \textbf{b)} \dots plus removing a file
& \textbf{c)} Adding a block (journal) \\
\end{tabular}
\caption{Example patch arrangements for an ext2-like file system.
 Circles represent patches, shaded boxes represent disk blocks, and arrows
 represent dependencies.
 \textbf{a)} A soft updates order for appending a zeroed-out block to
 a file.  \textbf{b)} A different file on the same inode block is removed
 before the previous changes commit, inducing a circular block dependency.
 \textbf{c)} A journal order for appending a zeroed-out block to a
 file.}
\label{f:ex}
\end{figure*}


The write-before relationship is transitive, so if $r \PDepend q$ and $q
 \PDepend p$, there is no need to explicitly store an $r \PDepend p$
 dependency.
%
To reduce storage requirements, a \Kudos\ implementation maintains only a
 subset of dependencies called the \emph{direct dependencies}.
%
Each patch $p$ has a corresponding set of direct dependencies
 $\PDDepset{p}$; 
%
we say $q$ \emph{directly depends on} $p$, and write $q \PDDepend p$, when
 $p \in \PDDepset{q}$.
%
The dependency relation $q \PDepend p$ simply means that either $q
 \PDDepend p$ or $q \PDepend x \PDDepend p$ for some patch $x$.


\begin{comment}
\paragraph{Undo data}
%
When a \patch\ is created, the buffer cache's copy of the block data
is modified in-place to reflect the change. However,
%
some arrangements of \patches\ may require that the buffer cache
%\emph{not} write one or more \patches\ on some block.
first write a block with only some \patches\ applied, and then write a
different block before being able to write the remaining \patches.
%
(An example of this is given in Section~\ref{sec:patch:examples}.)
\end{comment}



Another implementation choice defines how the buffer cache can
 write a subset of a block's patches.
%
We maintain each block in its dirty state, including the
 effects of all uncommitted patches, but
%
each patch carries \textbf{undo data}: the 
 previous version of the block data altered by the \patch.
%
If a \patch\ $p$ is not written with its containing block, the buffer cache
 \emph{reverts} the \patch, which swaps the new data on the buffered block
 and the previous version in the undo data.
%
Once the block is written, the system will re-apply the \patch\ and, when
 allowed, write the block again, this time including the \patch.
%
Undo information adds greatly to memory and CPU utilization, but it can
 often be optimized away, as we show in Section~\ref{sec:patch:optimizations}.

Figure~\ref{fig:patchnot} summarizes our patch notation.

\label{sec:patch:dependencies}

\begin{comment}
\paragraph{Example}
%
Suppose a \Kudos\ system contains the \patches\ in Figure~\ref{f:ex}c,
where the journal entry patches $d_\textrm{J}$, $i_\textrm{J}$, and
 $b_\textrm{J}$ have committed and all other patches have not.
%
The buffer cache cannot write blocks $\PBlock{b}$, $\PBlock{i}$, or $\PBlock{d}$,
since $\{b$, $i$, $i'$, $d\} \PDDepend \PXcmt$ and $\PXcmt \not\in \PDisk$.
%
Its only option is to write $\PBlock{\PXcmt}$ with $P = \{\PXcmt\}$, since
 $\PDepset{\PXcmt} = \{d_\textrm{J}$, $i_\textrm{J}$, $b_\textrm{J}\}
 \subseteq \PDisk$.
%
Since $\PXcmp$ has unmet dependencies on other blocks, it must be undone
 before the write and is excluded from $P$.
%
Later, when $\PXcmt$ commits, the buffer cache has the option to
write any of $\PBlock{b}$, $\PBlock{i}$, or $\PBlock{d}$.
\end{comment}


\subsection{Examples}
\label{sec:patch:examples}

This section illustrates how \patches\ can implement two widely-used
 file system consistency mechanisms, soft updates and journaling.
%
Our basic example extends an existing file by a single block---perhaps an
 application calls \texttt{ftruncate} to append 1024 zero bytes to an
 empty file.
%
The file system is based on ext2, an FFS-like file system with inodes and
 a free block bitmap.
%
In such a file system, this operation requires (1) allocating a block by
 marking the corresponding bit as ``allocated'' in the free block bitmap,
 (2) attaching the block to the file's inode, (3) setting the inode's size,
 and (4) clearing the allocated data block.
%
These operations affect three blocks---a free block bitmap block, an inode
 block, and a data block---and correspond to four patches: $b$ (allocate),
 $i$ (attach), $i'$ (size), and $d$ (clear).


\paragraph{Soft updates}
%
Early file systems aimed to avoid post-crash disk inconsistencies by
 writing some, or all, blocks synchronously.
%
For example, the write system call might block until all metadata writes
 have completed---clearly bad for performance.
%
Soft updates, in contrast, provides post-crash consistency without
 synchronous writes by tracking and obeying necessary dependencies among
 writes~\cite{ganger00soft}.
%
A soft updates file system orders its writes to enforce three simple rules
 for metadata consistency~\cite{ganger00soft}:

\begin{compactenumerate}
\item \label{rule:pointer} ``Never write a pointer to a structure until it
 has been initialized (e.g., an inode must be initialized before a
 directory entry references it).''
\item \label{rule:reuse} ``Never reuse a resource before nullifying all
 previous pointers to it''.
\item \label{rule:overwrite} ``Never reset the last pointer to a live
 resource before a new pointer has been set''.
\end{compactenumerate}

\noindent
By following these rules, a file system limits the possible inconsistencies
present on the disk at any time to leaked resources, such as blocks or inodes
marked as in use but unreferenced. The file system can be used immediately
 on reboot; a background scan can locate and recover the leaked resources
 while the system is in use.

These rules map directly to \Featherstitch.
%
Figure~\ref{f:ex}a shows a set of soft updates-like patches and dependencies for
 our block-append operation.
%
%% Each circle represents a single \patch. The shaded boxes indicate disk blocks.
%
%% The arrows between \patches\ represent the dependency relationship \PDDepend.
%
%% For example, appending a block to an empty file in an FFS-like file system
%% requires allocating a block by writing a bit to the block bitmap ($b$),
%% initializing the block by writing zeroes to it ($d$), writing the block number
%% to the inode for the file ($i$), and updating the file's size ($i'$).
%
Rule~\ref{rule:pointer} requires that $i \PDDepend b$.
%
Rule~\ref{rule:reuse} requires that $d$ depend on previous pointers to the
 block being nullified;
%
a simple, though more restrictive, way to accomplish this is to let $d
 \PDDepend b$, where $b$ depends on any such nullifications
 (there are none here).
%
The dependencies $i \PDDepend d$ and $i' \PDDepend d$ provide an
 additional guarantee above and beyond metadata consistency, namely
 that no file ever contains accessible uninitialized data.
%
A similar dependency would make inode updates depend on actual data
 writes.
%
In contrast, the BSD UFS soft updates implementation represents each UFS
 operation by a different specialized structure encapsulating
 all of that operation's disk changes and dependencies.
%% As a result, many specialized data structures
%% represent the different possible file system operations. 
These structures, their
relationships, and their uses %% for tracking and enforcing dependencies 
are quite complex~\cite{mckusick99soft}.

\begin{comment}
\begin{figure}[htb]
  \centering
  \includegraphics[width=92pt]{fig/examplesb_3}
  \caption{\label{fig:softupdate} Soft updates \patches\
  for appending one block to an empty file in an FFS-like file system.}
\end{figure}
\end{comment}

Figure~\ref{f:ex}b shows how an additional file system operation can induce
 a circular dependency among blocks.
%
Before the changes in Figure~\ref{f:ex}a are written, the user deletes a
 one-block file whose data block and inode happen to lie on the same bitmap
 and inode blocks used by the previous operation.
%
Rule~\ref{rule:reuse} requires the dependency $b_2 \PDDepend i_2$; but
 given this dependency and the previous $i \PDDepend b$, neither the bitmap
 block nor the inode block can be written first!
%
A solution is to roll back patch $b_2$ by undoing its effects.
 The resulting bitmap block, which contains only
 $b$, is safe to write.  Once this write commits, all of $i$, $i'$, and
 $i_2$ are safe to write.  When these in turn commit, the system can write
 the bitmap block again, this time including $b_2$.


\paragraph{Journal transactions}
%
A journaling file system ensures post-crash consistency using
 a write-ahead log.
%
%Each transaction leaves the disk in a consistent state, thus avoiding the need
%to check the file system when recovering from a failure.
%
All changes in a transaction are first copied into an on-disk journal.
%
Once these copies commit, a \emph{commit record} is written
 to the journal, signaling that the transaction is complete and all
 its changes are valid.
%
Once the commit record is written, the original changes can be written to the
file system in any order, since after a crash the system can replay the
 journal transaction to recover.
%% the journal later and recopy the data back out into the file system.
%
Finally, once all the changes have been written to the file system, the commit
record can be erased, allowing that portion of the journal to be reused.

\begin{comment}
\begin{figure}[htb]
  \centering
  \includegraphics[width=.8\hsize]{fig/examplesb_2}
  \caption{\label{fig:journal} An example journal transaction using \patches.}
\end{figure}
\end{comment}

\def\PXcmt{\textit{cmt}}
\def\PXcmp{\textit{cmp}}

This process also maps directly to patch dependencies, as shown in
 Figure~\ref{f:ex}c.
%
Copies of the affected blocks are written into the journal area using
 \patches\ $d_\textrm{J}$, $i_\textrm{J}$, and $b_\textrm{J}$, each on its
 own block.
%
Patch $\PXcmt$ creates the commit record on a fourth block in the journal
 area; it depends on $d_\textrm{J}$,
$i_\textrm{J}$, and $b_\textrm{J}$.
%
The changes to the main file system all depend on $\PXcmt$.
%
Finally, \patch\ $\PXcmp$, which depends on the main file system changes,
 overwrites the commit record with a completion record.
%
Again, a circular block dependency requires the system to roll back a
 patch, namely $\PXcmp$, and write the commit/completion block twice.

\begin{comment}
This arrangement of dependencies ensures that the commit record is not written
to disk until all the journal data is present there, that the updates to the
file system itself are not written until the commit record is present on disk,
and that the completion record is not written until the entire transaction is
complete.

This example also contains an instance of a \patch\ which will need to be
reverted: $cmp$, which overwrites the commit record written by $cmt$ (and
thus $\PBlock{cmp} = \PBlock{cmt}$), cannot be written with $cmt$ since
$cmp \PDDepend \{b$, $i$, $i'$, $d\} \PDDepend cmt$.
%
So, we must revert $cmp$ and write $\PBlock{cmp}$ with only $cmt$ applied,
then write $b$, $i$, $i'$, and $d$, and finally write $\PBlock{cmp}$
again in order to write $cmp$.
\end{comment}



\input{noop}


\subsection{Discussion}

The patch abstraction seems general enough to suit many forms of
 dependency tracking.
%
Only one property of the model depends on the conventional file system context,
 namely that circular dependency chains are errors.
%
This restriction is required because \Kudos\ assumes a lower layer that
 commits one block at a time.
%
Disks certainly behave this way, but a dependency tracker built above a
 more advanced lower layer---such as a journal---could resolve many
 circular dependency chains by forcing the relevant blocks into a single
 transaction or transaction equivalent.
%
\Featherstitch's journal module could potentially implement this, allowing
 upper layers to create (size-limited) circular dependency chains, but we
 leave the implementation for future work.

Patches model write-before relationships, but one might instead build a
 generalized file system dependency system that modeled abstract
 transactions.
%
We chose write-before relationships as our foundation since they minimally
 constrain file system disk layout; nevertheless, it would be interesting
 to consider whether a transaction abstraction could model, say, soft
 updates-like dependencies.
