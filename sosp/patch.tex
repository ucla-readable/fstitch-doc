% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section{\Patch\ Model}
\label{sec:patch}

\makeatletter
\let\emptyset\varnothing
\newcommand{\PState}[1]{\ensuremath{#1.\textit{state}}}
\newcommand{\PBlock}[1]{\ensuremath{#1.\textit{block}}}
\newcommand{\PMemst}{\ensuremath{\textit{mem}}}
\newcommand{\PInfst}{\ensuremath{\textit{flight}}}
\newcommand{\PDiskst}{\ensuremath{\textit{disk}}}
\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else[\@next]\fi}
\newcommand{\PMem}[1][]{\ensuremath{\textit{Mem}\PSetlim{#1}}}
\newcommand{\PInf}[1][]{\ensuremath{\textit{Flight}\PSetlim{#1}}}
\newcommand{\PDisk}[1][]{\ensuremath{\textit{Disk}\PSetlim{#1}}}
\newcommand{\PHard}[1][]{\ensuremath{\textit{\Nrb}\PSetlim{#1}}}
\newcommand{\PSoft}[1][]{\ensuremath{\textit{\Rb}\PSetlim{#1}}}
\newcommand{\PEmpty}[1][]{\ensuremath{\textit{\Noop}\PSetlim{#1}}}
\newcommand{\PDDepset}[1]{\ensuremath{\def\@next{#1}\ifx\@next\@empty\else\@next.\fi\textit{ddeps}}}
\newcommand{\PDepend}{\ensuremath{\leadsto}}
\newcommand{\PDDepend}{\ensuremath{\rightarrow}}
\newcommand{\PDepset}[1]{\ensuremath{\textit{Dep}[#1]}}
\newcommand{\PRDepset}[1]{\ensuremath{\textit{RDep}[#1]}}
\makeatother

Every change to stable storage in a \Kudos\ system is represented by a
\emph{\patch}.
%
This section describes the basic \patch\ abstraction using a semi-formal
notation that will be useful for analyzing our optimizations later.
%
Although the \patch\ idea would apply to any stable medium, to network file
systems, or to multiple disks, we use terms like ``the disk'' and ``the
disk controller'' throughout to simplify our terminology.


Each \patch\ $p$ encapsulates four important pieces of information: its
 \emph{block}, its \emph{state}, a set of \emph{direct dependencies}, and
 some \emph{undo data}.

\Patch\ $p$'s \textbf{block}, written $\PBlock{p}$, is the unit of disk data
 to which $p$ applies.  The disk controller is assumed to execute writes one
 block at a time (although not necessarily atomically; see below).  A file system
 change that affects $n$ blocks must be represented using at least $n$
 \patches, since a \patch\ by definition can touch only one block.

Each \patch\ is in one of three \textbf{states}: \emph{in memory}; \emph{in
 flight} to the disk controller, but not yet committed to disk; or
 \emph{on disk}.  The intermediate in-flight state is necessary because
 operating system software loses control of a \patch\ upon writing its block
 to disk.  $p$'s state is written $\PState{p} \in \{\PMemst, \PInfst,
 \PDiskst\}$.  The operating system changes a \patch's state from
 \PMemst\ to \PInfst\ by writing its block to the disk controller.  Some
 time later---after possible controller-level disk scheduling, transit over
 the system bus, and a period in the disk's cache---the disk writes the block
 to stable storage and reports success.  When the processor receives this
 notification, it changes the \patch's state to \PDiskst.
%
The sets \PMem, \PInf, and \PDisk\ are defined to contain all \patches\ with
 the given state, and the sets $\PMem[b]$, $\PInf[b]$, and $\PDisk[b]$ are
 defined to contain all \patches\ with the given state \emph{on the given
 block} $b$.

\Patch\ $p$'s \textbf{direct dependencies}, written $\PDDepset{p}$, is a set of
 other \patches\ on which $p$ ``depends''.
%
That is, every \patch\ in $\PDDepset{p}$ should be committed to disk either
 before $p$, or atomically with $p$ (i.e. $p$ and $q$ are on the same block).
%
Dependencies are set by the file system based on the consistency
 semantics it wants to ensure.
%
For example, a file system with asynchronous writes (and no durability
 guarantees) might write all \patches\ with $\PDDepset{p} = \emptyset$;
%
a file system wishing to impose strictly ordered writes might set
 $\PDDepset{p_n} = \{p_{n-1}\}$.
%
In summary, an upper file system layer defines an initial set of
 dependencies;
%
the rest of \Kudos\ generally preserves this initial set, but can modify
 it as necessary to change dependency semantics;
%
and finally, the buffer cache obeys the constraints thus defined.


We say $p$ \emph{directly depends on} $q$, and write $p \PDDepend q$, when
 $q \in \PDDepset{p}$.
%
We say $p$ \emph{depends on} $q$, and write $p \PDepend q$, when there
 exists a dependency chain from $p$ to $q$: that is, either $p \PDDepend q$
 or, for some \patch\ $x$, $p \PDepend x \PDDepend q$.
%
\Patch\ $p$'s set of \emph{dependencies} is written $\PDepset{p} = \{ q \mid
 p \PDepend q \}$; this is of course a superset of its direct dependencies.
%
Given a \emph{set} of \patches\ $P$, we write $\PDepset{P}$ to mean the set's
 combined dependencies $\bigcup_{p\in P} \PDepset{p}$. Our \patch\ notation
 is summarized in Figure~\ref{fig:patchnot}.


\textbf{Undo data.}
%
When a \patch\ is created, the buffer cache's copy of the block data
is modified in-place to reflect the change. However,
%
some arrangements of \patches\ may require that the buffer cache
%\emph{not} write one or more \patches\ on some block.
first write a block with only some \patches\ applied, and then write a
different block before being able to write the remaining \patches.
%
(An example of this is given in Section~\ref{sec:patch:examples}.)


For this reason, each \patch\ carries \emph{undo} information that gives
the previous version of the range of block data altered by the \patch.
%
If a \patch\ $p$ is not written with its containing block, the system
\emph{reverts} the \patch, which swaps the new data and the previous
version on the (single) copy of the block in the buffer cache.
%
Once the block is written, the system will re-apply the \patch\ and, when
allowed, write the block again, this time including the \patch.
%
Undo information adds greatly to memory and CPU utilization, but it can
often be optimized away, as we show below.

\begin{figure}[t]
\begin{small}
\begin{tabular}{@{}ll@{}}
$\PBlock{p} = b$ & $p$'s block \\
$\PState{p}$ & $p$'s state, $\in \{\PMemst, \PInfst, \PDiskst\}$ \\
$\PDDepset{p}$ & $p$'s direct dependencies: \patches\ that must go to disk \\
	& before $p$ \\
\noalign{\vskip3pt}
$\PMem$ & all in-memory \patches: $\{p \mid \PState{p} = \PMemst\}$ \\
$\PMem[b]$ & $\{p \mid \PState{p} = \PMemst \text{ and } \PBlock{p} = b
 \}$ \\
$\PInf, \PDisk$ & similarly for in-flight and on-disk \patches\ \\
\noalign{\vskip3pt}
$p \PDDepend q$ & $p$ directly depends on $q$: $q \in \PDDepset{p}$ \\
$p \PDepend q$ & $p$ depends on $q$: either $p \PDDepend q$ or there exists \\
       & a \patch\ $x$ so that $p \PDepend x \PDDepend q$ \\
$\PDepset{p}$ & $p$'s dependencies: $\{ q \mid p \PDepend q \}$ \\
\end{tabular}
\end{small}

\caption{\Patch\ notation.}
\label{fig:patchnot}
\end{figure}


\subsection{Examples}
\label{sec:patch:examples}

\textbf{Journal transactions.}
%
In a journaling file system, changes to the file system are grouped into
\emph{transactions} that commit atomically.
%
Each transaction leaves the disk in a consistent state, thus avoiding the need
to check the file system when recovering from a failure.
%
All changes in a transaction are first copied into an on-disk log (called the
\emph{journal}) before any of them are allowed to be written to the file
system itself.
%
After writing the journal, a small \emph{commit record} is written atomically,
which signals that the transaction is complete and that all its changes should
be considered valid.
%
Once the commit record is written, the original changes can be written to the
file system in any order, since if the system is interrupted it can consult
the journal later and copy the data back out into the file system.
%
Finally, once all the changes have been written to the file system, the commit
record can be erased, and that portion of the journal may be reused.

Patches implementing a journal transaction could be arranged as follows:
%
a \patch\ $c$ writing the commit record would have $c \PDDepend \{d_{1\dots n}\}$,
where each $d_i$ writes a copy of an updated file system block into the journal.
%
Then the file system updates would each have $u_i \PDDepend c$, and a \patch\ $e$
erasing the commit record would have $e \PDDepend \{u_{1\dots m}\}$.
%
A journal transaction containing four disk blocks is depicted in
Figure~\ref{fig:journal}.
%
Each circle represents a single \patch. The shaded boxes indicate disk blocks.
%
The arrows between \patches\ represent the dependency relationship \PDDepend.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\hsize]{fig/figures_2}
  \caption{\label{fig:journal} An example journal transaction using \patches.}
\end{figure}

This arrangement of dependencies ensures that the commit record is not written
to disk until all the journal data is present there, that the updates to the
file system itself are not written until the commit record is present on disk,
and that the commit record is not erased until the entire transaction is
complete.

This example also contains an instance of a \patch\ which will need to be
reverted: $e$, which overwrites the commit record written by $c$ (and thus
$\PBlock{c} = \PBlock{e}$), cannot be written with $c$ since $e \PDDepend
\{u_{1\dots m}\} \PDDepend c$.
%
So, we must revert $e$ and write $\PBlock{e}$ with only $c$ applied, then
write each $u_i$, and finally write $\PBlock{e}$ again in order to write $e$.

\textbf{Soft updates.}
%
A file system using soft updates aims to prevent most kinds of inconsistencies
from ever being present on the disk at all, by carefully ordering its writes
according to three simple rules~\cite{ganger00soft}:

\begin{enumerate}
\item \label{rule:pointer} Never write a pointer to a structure until it has been initialized
\item \label{rule:reuse} Never reuse such structures until all previous pointers to them have been overwritten
\item \label{rule:overwrite} Never overwrite the last pointer to a live structure before a new pointer to it has been written
\end{enumerate}

\noindent
By following these rules, a file system limits the possible inconsistencies
present on the disk at any time to only leaked resources (e.g. blocks or inodes
marked as in use but unreferenced). The file system can be used immediately,
and a background scan can locate and recover the leaked resources while the
system is in use.

The soft updates rules map directly to \patch\ dependencies.
%
For example, appending a block to an empty file in an FFS-like file system
requires allocating a block by writing a bit to the block bitmap ($a$),
initializing the block by writing zeroes to it ($z$), writing the block number
to the inode for the file ($n$), and updating the file's size ($s$).
%
By rule \ref{rule:pointer}, we need $n \PDDepend a$ and $n \PDDepend z$, since
$a$ and $z$ together initialize the new block.
%
By rule \ref{rule:reuse} we also need to make sure that $z$ depends on any
previous deallocation of the same block, so that it is not overwritten while
it is still in use.
%
A simple way to accomplish this is to let $z \PDDepend a$.
%
Finally, we can let $s \PDDepend z$ so that no file ever contains accessible
uninitialized data.
%
Figure~\ref{fig:softupdate} depicts this arrangement.

\begin{figure}[htb]
  \centering
  \includegraphics[width=92pt]{fig/figures_3}
  \caption{\label{fig:softupdate} Soft updates \patches\
  for appending one block to an empty file in an FFS-like file system.}
\end{figure}


\subsection{Obeying Dependencies}
\label{sec:patch:dependencies}

\Kudos\ must ensure the \textbf{disk safety property}, which states that
 the dependencies of all \patches\ on disk are also on disk:
%
\[ \PDepset{\PDisk} \subseteq \PDisk. \]
%
Thus, no matter when the system crashes, the disk is consistent in terms of
dependencies.
%
The file system's job is to set up dependencies so that the disk safety
property implies file system correctness.

However, \Kudos\ can only control when \patches\ are handed to the disk
 controller, not when they are written to disk.
%
Disk controller behavior is encapsulated in the following atomic action:

\begin{tabbing}
\textit{Commit block:} \\
\quad Pick some block $b$ with $\PInf[b] \neq \emptyset$. \\
\quad For each $p \in \PInf[b]$, set $\PState{p} \gets \PDiskst$.
\end{tabbing}

\noindent
%
Since the controller can write blocks in any order, \Kudos\ must ensure
that in-flight blocks are mutually independent.  This is precisely stated
by the \textbf{in-flight safety property:}
%
\[ \text{For all blocks $b$,~~} \PDepset{\PInf[b]} \subseteq \PInf[b] \cup \PDisk . \]
%
This ensures that for any $b' \neq b$, $\PDepset{\PInf[b]} \cap
 \PDepset{\PInf[b']} \subseteq \PDisk$; the disk controller can safely
 write in-flight blocks in any order and still preserve disk safety.
%
(The union with $\PInf[b]$ is necessary for the case of multiple in-flight
\patches\ on the same block.)


The buffer cache must thus behave according to the following atomic action:

\begin{tabbing}
\textit{Write block:} \\
\quad Pick some block $b$ with $\PMem[b] \neq \emptyset$ and $\PInf[b] =
\emptyset$. \\
\quad Pick some $P \subseteq \PMem[b]$ with $\PDepset{P} \subseteq P \cup
\PDisk$. \\
\quad For each $p \in P$, set $\PState{p} \gets \PInfst$.
\end{tabbing}

\noindent
%
We require that $\PInf[b] = \emptyset$ since the disk controller can write
in-flight blocks in any order, and thus at most one version of a block can
be in flight at any time.
%
The buffer cache is also expected to write all blocks eventually, a
 liveness property.

\textbf{Example.}
%
Suppose the buffer cache has \patches\ arranged as in the previous journal
example, and that $\{j_i\} \subseteq \PDisk$, i.e., the journal entries have
already been written to disk.
%
The buffer cache cannot write block $\PBlock{u_i}$ for any $i$, since $u_i
\PDDepend c$ and $\PState{c} \neq \PDiskst$.
%
Its only option is to write $\PBlock{c}$ since $\PDepset{c} = \{j_i\}
\subseteq \PDisk$.
%
So, via the action above, it sets $\PState{c} \gets \PDiskst$.
%
Later, when notification is received that $\PBlock{c}$ has been written to disk,
$\PState{c}$ is set to $\PDiskst$ and the buffer cache then has the option to
write any of $\PBlock{u_i}$.

This model does not completely define the disk's behavior on system crash,
 in particular with respect to in-flight blocks.
%
Soft updates inherently assumes that blocks are written
\emph{atomically}, except in the case of catastrophic media error:
%
if the disk fails while a block $b$ is in flight, then $b$'s
value on recovery must equal either the old value or the new value.
%
Most journal designs do not rely on this assumption, and can recover
 properly even if in-flight blocks are corrupted---for instance,
 because the memory holding the new value of the block lost its coherence
 before the disk stopped writing~\cite{nightingale06rethink}.
%
However, some disks may actually provide an atomicity guarantee, for
 instance by using non-volatile memory to store blocks before they make it
 onto disk.
%
The \Kudos\ core makes no assumptions about block atomicity, instead relying
 on software above it to implement a consistency protocol that makes sense
 for the given disk.


The buffer cache can't handle cross-block \patch\ dependency cycles since
it must write data in units of blocks.
%
Thus, if $p \PDepend q \PDepend p$, then $p$ and $q$ must be on the same
block; otherwise, neither $p$ nor $q$ could ever get written.
%
Whenever upper layers might generate cross-block dependency cycles,
intervening layers must break those cycles somehow before they reach the
cache.
%
For instance, a journal layer might detect dependency cycles and put the
corresponding \patches\ into a single transaction, but the
\emph{implementation} of that transaction could not contain cross-block
cycles.
%
In practice, the \Kudos\ implementation currently disallows any dependency
cycles, including cycles within a single block; this simplifies many graph
traversals used to determine when optimizations may be applied, and has not
yet caused any difficulty in implementing different consistency policies.


\input{noop}
