% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section{\Patch\ Model}
\label{sec:patch}

\makeatletter
\let\emptyset\varnothing
%\newcommand{\PState}[1]{\ensuremath{#1.\textit{state}}}
%\newcommand{\PBlock}[1]{\ensuremath{#1.\textit{block}}}
\newcommand{\PBlock}[1]{\ensuremath{B_{#1}}}
%\newcommand{\PMemst}{\ensuremath{\textit{mem}}}
%\newcommand{\PInfst}{\ensuremath{\textit{flight}}}
%\newcommand{\PDiskst}{\ensuremath{\textit{disk}}}
\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else_{\@next}\fi}
%\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else\cap\@next\fi}
\newcommand{\PMem}[1][]{\ensuremath{\mathbf{U}\PSetlim{#1}}}
\newcommand{\PInf}[1][]{\ensuremath{\mathbf{F}\PSetlim{#1}}}
\newcommand{\PDisk}[1][]{\ensuremath{\mathbf{C}\PSetlim{#1}}}
\newcommand{\PHard}[1][]{\ensuremath{\textit{\Nrb}\PSetlim{#1}}}
\newcommand{\PSoft}[1][]{\ensuremath{\textit{\Rb}\PSetlim{#1}}}
\newcommand{\PEmpty}[1][]{\ensuremath{\textit{\Noop}\PSetlim{#1}}}
%\newcommand{\PDDepset}[1]{\ensuremath{\def\@next{#1}\ifx\@next\@empty\else\@next.\fi\textit{ddeps}}}
\newcommand{\PDDepset}[1]{\ensuremath{\textit{Dep}_1[#1]}}
\newcommand{\PDepend}{\ensuremath{\leadsto}}
\newcommand{\PDDepend}{\ensuremath{\rightarrow}}
%\newcommand{\PDepset}[1]{\ensuremath{\textit{Dep}[#1]}}
\newcommand{\PDepset}[1]{\ensuremath{\textit{Dep}[#1]}}
\newcommand{\PRDepset}[1]{\ensuremath{\textit{RDep}[#1]}}
\makeatother

Every change to stable storage in a \Kudos\ system is represented by a
\emph{\patch}.
%
This section describes the basic \patch\ abstraction using a semi-formal
 notation, and presents our kernel implementation's version of the
 abstraction.

\begin{comment}
%
%% Although the \patch\ idea would apply to any stable medium, to network file
%% systems, or to multiple disks, we use terms like ``the disk'' and ``the
%% disk controller'' throughout to simplify our terminology.
%
Each \patch\ $p$ encapsulates four important pieces of information: its
 \emph{block}, its \emph{state}, a set of \emph{direct dependencies}, and
 some \emph{undo data}.
\end{comment}

\subsection{Disk Behavior}

A \Kudos\ system's storage layer commits data in units called
 \textbf{blocks}.
%
All writes affect one or more blocks, and it is impossible to selectively
 write part of a block.
%
This models a conventional disk file system with uniformly-sized blocks,
 but also models non-uniform blocks and other media, such as RAID or
 network storage.
%
(Nevertheless, we frequently use terms like ``the disk'' and ``the disk
 controller'' to simplify our terminology.)

\Kudos\ represents each change to stable storage as a \textbf{patch}.
%
Each patch applies to exactly one block; thus, a file system change that
 affects $n$ blocks requires at least $n$ patches to represent.
%
Each \patch\ is either
 \textbf{committed}, meaning written to disk;
 \textbf{uncommitted}, meaning not written to disk;
 or \textbf{in flight}, meaning committed by upper layers, but not
 necessarily by lower layers.
%
The intermediate in-flight state is necessary because
 operating system software loses control of a block upon writing it
 to disk: the disk controller may commit in-flight \patches\ in any order.
%
The sets $\PDisk$, $\PMem$, and $\PInf$ represent all committed,
 uncommitted, and in-flight patches, respectively.
%
Patches begin their lives as uncommitted.
%
The operating system sends uncommitted \patches\ in flight
 by writing their blocks to the disk controller.  Some
 time later---after possible controller-level disk scheduling, transit over
 the system bus, and a period in the disk's cache---the disk writes these blocks
 to stable storage and reports success.  When the processor receives this
 acknowledgement, it commits the relevant patches, moving them into $\PDisk$.
%
Each committed patch stays committed permanently, although its effects can
 be undone by subsequent patches on the same block.
%
%% $p$'s state is written $\PState{p} \in \{\PMemst, \PInfst,
%% \PDiskst\}$.  
%
%% The sets \PMem, \PInf, and \PDisk\ are defined to contain all \patches\ with
%%  the given state, and 
%% The notation $\PMem[b]$ represents the subset of $\PMem$ with the given
%%  block $b$.

Patch $p$'s block is written $\PBlock{p}$.
%
Given a block $B$, we write $\PDisk[B]$ for the set of committed
 patches with block $B$, or in notation $\PDisk[B] = \{p\in\PDisk\mid\PBlock{p}=B\}$.
%
$\PInf[B]$ and $\PMem[B]$ are defined similarly.

%%  is represented as a set containing
%%  all patches that affect that block, including $p$ itself.
%% %
%% Thus, $\PBlock{p} \cap \PDisk$ is the set of committed patches on
%%  $p$'s block, and the block is dirty if and only if $\PBlock{p} \cap \PDisk
%%  \neq \PBlock{p}$.

Disk controllers act by writing in-flight patches one block at a time; or,
 in notation:

\begin{tabbing}
\qquad \textit{Commit block:} \\
\qquad \quad Pick some block $B$ with $\PInf[B] \neq \emptyset$. \\
\qquad \quad Commit and acknowledge each patch in $\PInf[B]$.
\end{tabbing}

\noindent
%
Disks perform better when allowed to reorder requests, so operating systems
 try to keep many blocks in flight, as constrained by write-before
 relationships.  (For instance, in-flight blocks cannot depend on each
 other.)
%
Although file systems will generally write all of a block's uncommitted
 patches when they write the block, they may, if they choose, write a
 \emph{subset} of those patches---and, as we will see, this is sometimes
 required to preserve write-before relationships.
%
During such a write, the effects of any unwritten patches must be
 temporarily undone.


Careful control over write-before relationships is \emph{necessary} to
 ensure consistency, but for some file system designs, such as soft
 updates, it \emph{suffices} only if the underlying storage system
 writes blocks atomically.
%
That is, soft updates requires that if the disk fails while a block $B$ is
 in flight, then $B$'s value on recovery must equal either the old value or
 the new value.
%
Most journal designs do not require this, and can recover even if
 in-flight blocks are corrupted---for instance, because the memory holding
 the new value of the block lost coherence before the disk stopped
 writing.
%
For systems that provide an atomicity guarantee at upper or lower layers,
 however, an additional journal might introduce overhead.
 %% , for instance by buffering blocks in non-volatile memory before writing them to disk.
%
\Kudos\ patches can capture all possible write ordering requirements,
 including those necessary to implement a journal, but \Kudos\ itself does
 not provide block atomicity.
%
Instead, layers using \Kudos\ should choose a file system design suitable
 for a given disk.


\begin{comment}
This model does not completely define the disk's behavior on system crash,
 in particular with respect to in-flight blocks.
%
%
Most journal designs do not rely on this assumption, and can recover
 properly even if in-flight blocks are corrupted---for instance,
 because the memory holding the new value of the block lost its coherence
 before the disk stopped writing~\cite{nightingale06rethink}.
%
However, some disks may actually provide an atomicity guarantee, for
 instance by using non-volatile memory to store blocks before they make it
 onto disk.
%
The \Kudos\ core makes no assumptions about block atomicity, instead relying
 on software above it to implement a consistency protocol that makes sense
 for the given disk.
\end{comment}


\begin{figure}[t]
\centering
\begin{small}
\begin{tabular}{@{}l@{~~~}l@{}}
$p$     & a patch \\
$\PBlock{p}$ & $p$'s block \\
% $\PState{p}$ & $p$'s state, $\in \{\PMemst, \PInfst, \PDiskst\}$ \\
\noalign{\vskip3pt}
$\PDisk, \PMem, \PInf$ & the sets of all committed, uncommitted, and in-flight \\
        & \patches, respectively \\
$\PDisk[B], \PMem[B], \PInf[B]$ & committed/uncommitted/in-flight patches on block $B$ \\
\noalign{\vskip3pt}
$p \PDDepend q$ & $p$ directly depends on $q$ ($p$ must be written before $q$) \\
$p \PDepend q$ & $p$ depends on $q$: either $p \PDDepend q$ or there exists a patch \\
       & $x$ so that $p \PDepend x \PDDepend q$ \\
$\PDDepset{p}$ & $p$'s direct dependencies: $\{ q \mid p \PDDepend q \}$ \\
$\PDepset{p}$ & $p$'s dependencies: $\{ q \mid p \PDepend q \}$ \\
\end{tabular}
\end{small}

\caption{\Patch\ notation.}
\label{fig:patchnot}
\end{figure}


\subsection{Dependencies}

Two additional \patch\ properties are required to model write-before
 relationships, \emph{dependencies} and \emph{undo data}.
%
Dependencies define ordering requirements among patches, and undo data
 allows a patch to be reverted if its block must be written without
 it.

Each \patch\ $p$ has a set of \textbf{direct dependencies}
 $\PDDepset{p}$.
%
Every \patch\ in $\PDDepset{p}$ must be committed to disk either before
 $p$, or at the same time as $p$ (this is only possible if $p$ and $q$ are
 on the same block).
%
The file system arranges dependencies based on the consistency
 semantics it wants to ensure.
%
For example, a file system with asynchronous writes (and no durability
 guarantees) might write all \patches\ with $\PDDepset{p} = \emptyset$;
%
a file system wishing to impose strictly ordered writes might set
 $\PDDepset{p_n} = \{p_{n-1}\}$.
%
In practice, an upper \Kudos\ layer defines an initial set of
 dependencies;
%
intermediate layers mostly preserve this initial set, but can modify
 it as necessary to change dependency semantics;
%
and finally, the buffer cache obeys the constraints thus defined.


We say $p$ \emph{directly depends on} $q$, and write $p \PDDepend q$, when
 $q \in \PDDepset{p}$.
%
We say $p$ \emph{depends on} $q$, and write $p \PDepend q$, when there
 exists a dependency chain from $p$ to $q$: that is, either $p \PDDepend q$
 or, for some \patch\ $x$, $p \PDepend x \PDDepend q$.
%
\Patch\ $p$'s set of \emph{dependencies} is written $\PDepset{p} = \{ q \mid
 p \PDepend q \}$; this is of course a superset of its direct dependencies.
%
Circular dependencies among patches cannot be resolved and are therefore
 errors.  For example, neither $p$ nor $q$ could be written before the
 other if $p \PDepend q \PDepend p$.
%
(Although a circular dependency chain entirely within a single block avoids
 this problem, in practice \Kudos\ treats all circular chains as errors.)
%
Given a \emph{set} of \patches\ $P$, we write $\PDepset{P}$ to mean the set's
 combined dependencies $\bigcup_{p\in P} \PDepset{p}$. 

\begin{comment}
\paragraph{Undo data}
%
When a \patch\ is created, the buffer cache's copy of the block data
is modified in-place to reflect the change. However,
%
some arrangements of \patches\ may require that the buffer cache
%\emph{not} write one or more \patches\ on some block.
first write a block with only some \patches\ applied, and then write a
different block before being able to write the remaining \patches.
%
(An example of this is given in Section~\ref{sec:patch:examples}.)
\end{comment}

Each patch also carries \textbf{undo data} consisting of the 
 previous version of the block data altered by the \patch.
%
If a \patch\ $p$ is not written with its containing block, the system
 \emph{reverts} the \patch, which swaps the new data and the previous
 version on the (single) copy of the block in the buffer cache.
%
Once the block is written, the system will re-apply the \patch\ and, when
 allowed, write the block again, this time including the \patch.
%
Undo information adds greatly to memory and CPU utilization, but it can
 often be optimized away, as we show in Section~\ref{sec:patch:optimizations}.

Our \patch\ notation is summarized in Figure~\ref{fig:patchnot}.

\begin{figure*}[t]
\centering
\begin{tabular}{@{}cc@{\qquad\qquad}c@{}}
\includegraphics[scale=0.78]{fig/examplesb_3}
& \includegraphics[scale=0.78]{fig/examplesb_4}
& \includegraphics[scale=0.78]{fig/examplesb_2} \\
\textbf{a)} Adding a block (soft updates)
& \textbf{b)} \dots plus removing a file
& \textbf{c)} Adding a block (journal) \\
\end{tabular}
\caption{Example patch arrangements for an ext2-like file system.
 Circles represent patches, shaded boxes represent disk blocks, and arrows
 represent dependencies.
 \textbf{a)} A soft updates order for appending a zeroed-out block to
 a file.  \textbf{b)} A different file on the same inode block is removed
 before the previous changes commit, inducing a circular block dependency.
 \textbf{c)} A journal order for appending a zeroed-out block to a
 file.}
\label{f:ex}
\end{figure*}


\subsection{Examples}
\label{sec:patch:examples}

This section illustrates how \patches\ can implement two widely-used
 file system consistency models, soft updates and journaling.
%
Our basic example extends an existing file by a single block---perhaps an
 application has used \texttt{ftruncate} to append 1024 zero bytes to an
 empty file.
%
The file system is based on ext2, an FFS-like file system with inodes and
 a free block bitmap.
%
In such a file system, this operation requires (1) allocating a block by
 marking the corresponding bit as ``allocated'' in the free block bitmap,
 (2) attaching the block to the file's inode, (3) setting the inode's size,
 and (4) clearing the allocated data block.
%
These operations affect three blocks---a free block bitmap block, an inode
 block, and a data block---and correspond to four patches: $b$ (allocate),
 $i$ (attach), $i'$ (size), and $d$ (clear).


\paragraph{Soft updates}
%
Early file systems aimed to avoid post-crash disk inconsistencies by
 writing some, or all, blocks synchronously.
%
For example, the write system call might block until all metadata writes
 had completed---clearly bad for performance.
%
Soft updates, in contrast, provides post-crash consistency without
 synchronous writes by tracking and obeying necessary dependencies among
 writes~\cite{ganger00soft}.
%
A soft updates file system orders its writes to enforce three simple rules
 for metadata consistency~\cite{ganger00soft}:

\begin{compactenumerate}
\item \label{rule:pointer} ``Never write a pointer to a structure until it
 has been initialized (e.g., an inode must be initialized before a
 directory entry references it).''
\item \label{rule:reuse} ``Never reuse a resource before nullifying all
 previous pointers to it''.
\item \label{rule:overwrite} ``Never reset the last pointer to a live
 resource before a new pointer has been set''.
\end{compactenumerate}

\noindent
By following these rules, a file system limits the possible inconsistencies
present on the disk at any time to leaked resources only, such as blocks or inodes
marked as in use but unreferenced. The file system can be used immediately
 on reboot; a background scan can locate and recover the leaked resources
 while the system is in use.

These rules map directly to \Featherstitch.
%
Figure~\ref{f:ex}a shows a set of soft updates-like patches and dependencies for
 our block-append operation.
%
%% Each circle represents a single \patch. The shaded boxes indicate disk blocks.
%
%% The arrows between \patches\ represent the dependency relationship \PDDepend.
%
%% For example, appending a block to an empty file in an FFS-like file system
%% requires allocating a block by writing a bit to the block bitmap ($b$),
%% initializing the block by writing zeroes to it ($d$), writing the block number
%% to the inode for the file ($i$), and updating the file's size ($i'$).
%
Rule~\ref{rule:pointer} requires that $i \PDDepend b$.
%
Rule~\ref{rule:reuse} requires that $d$ depend on previous pointers to the
 block being nullified;
%
a simple, though more restrictive, way to accomplish this is to let $d
 \PDDepend b$, where $b$ depends on any such nullifications
 (there are none here).
%
The dependencies $i \PDDepend d$ and $i' \PDDepend d$ provide an
 additional guarantee above and beyond metadata consistency, namely
 that no file ever contains accessible uninitialized data.
%
A similar dependency would make inode updates depend on actual data
 writes.
%
In contrast, the BSD UFS soft updates implementation represents each UFS
 operation by a different specialized structure encapsulating
 all that operation's disk changes and dependencies.
%% As a result, many specialized data structures
%% represent the different possible file system operations. 
These structures, their
relationships, and their uses for tracking and enforcing
dependencies are quite complex~\cite{mckusick99soft}.

\begin{comment}
\begin{figure}[htb]
  \centering
  \includegraphics[width=92pt]{fig/examplesb_3}
  \caption{\label{fig:softupdate} Soft updates \patches\
  for appending one block to an empty file in an FFS-like file system.}
\end{figure}
\end{comment}

Figure~\ref{f:ex}b shows how an additional file system operation can induce
 a circular dependency among blocks.
%
Before the changes in Figure~\ref{f:ex}a are written, the user deletes a
 one-block file whose data block and inode happen to lie on the same bitmap
 and inode blocks used by the previous operation.
%
Rule~\ref{rule:reuse} requires the dependency $b_2 \PDDepend i_2$; but
 given this dependency and the previous $i \PDDepend b$, neither the bitmap
 block nor the inode block can be written first!
%
A solution is to roll back patch $b_2$ by undoing its effects.
 The resulting bitmap block, which contains only
 $b$, is safe to write.  Once this write commits, all of $i$, $i'$, and
 $i_2$ are safe to write.  When these in turn commit, the system can write
 the bitmap block again, this time including $b_2$.


\paragraph{Journal transactions}
%
A journaling file system ensures post-crash consistency using
 a write-ahead log.
%
%Each transaction leaves the disk in a consistent state, thus avoiding the need
%to check the file system when recovering from a failure.
%
All changes in a transaction are first copied into an on-disk journal.
%
Once these copies commit, a \emph{commit record} is written
 to the journal, signaling that the transaction is complete and all
 its changes are valid.
%
Once the commit record is written, the original changes can be written to the
file system in any order, since after a crash the system can replay the
 journal transaction to recover.
%% the journal later and recopy the data back out into the file system.
%
Finally, once all the changes have been written to the file system, the commit
record can be erased, allowing that portion of the journal to be reused.

\begin{comment}
\begin{figure}[htb]
  \centering
  \includegraphics[width=.8\hsize]{fig/examplesb_2}
  \caption{\label{fig:journal} An example journal transaction using \patches.}
\end{figure}
\end{comment}

\def\PXcmt{\textit{cmt}}
\def\PXcmp{\textit{cmp}}

This process also maps directly to patch dependencies, as shown in
 Figure~\ref{f:ex}c.
%
Copies of the affected blocks are written into the journal area using
 \patches\ $d_\textrm{J}$, $i_\textrm{J}$, and $b_\textrm{J}$, each on its
 own block.
%
Patch $\PXcmt$ creates the commit record on a fourth block in the journal
 area; it depends on $d_\textrm{J}$,
$i_\textrm{J}$, and $b_\textrm{J}$.
%
The changes to the main file system all depend on $\PXcmt$.
%
Finally, \patch\ $\PXcmp$, which depends on the main file system changes,
 overwrites the commit record with a completion record.
%
Again, a circular block dependency requires the system to roll back a
 patch, namely $\PXcmp$, and write the commit/completion block twice.

\begin{comment}
This arrangement of dependencies ensures that the commit record is not written
to disk until all the journal data is present there, that the updates to the
file system itself are not written until the commit record is present on disk,
and that the completion record is not written until the entire transaction is
complete.

This example also contains an instance of a \patch\ which will need to be
reverted: $cmp$, which overwrites the commit record written by $cmt$ (and
thus $\PBlock{cmp} = \PBlock{cmt}$), cannot be written with $cmt$ since
$cmp \PDDepend \{b$, $i$, $i'$, $d\} \PDDepend cmt$.
%
So, we must revert $cmp$ and write $\PBlock{cmp}$ with only $cmt$ applied,
then write $b$, $i$, $i'$, and $d$, and finally write $\PBlock{cmp}$
again in order to write $cmp$.
\end{comment}


\subsection{Obeying Dependencies}
\label{sec:patch:dependencies}

The \textbf{disk safety property} states that
 the dependencies of all committed \patches\ must also be committed:
%
\[ \PDepset{\PDisk} \subseteq \PDisk. \]
%
Thus, no matter when the system crashes, the disk is consistent in terms of
dependencies.
%
The file system's job is to set up dependencies so that the disk safety
property implies file system correctness.

\begin{comment}
 However, \Kudos\ can only control when \patches\ are handed to the disk
 controller, not when they are written to disk.
 %
 Disk controller behavior is encapsulated in the following atomic action:

 \begin{tabbing}
 \textit{Commit block:} \\
 \quad Pick some block $b$ with $\PInf[b] \neq \emptyset$. \\
 \quad Move each $p \in \PInf[b]$ to $\PDisk$ (committed).
 \end{tabbing}
\end{comment}

Since the disk controller can write blocks in any order, a \Kudos\ file
 system must also ensure
that in-flight blocks are independent.  This is precisely stated
by the \textbf{in-flight safety property:}
%
\[ \text{For any block $B$,~~} \PDepset{\PInf[B]} \subseteq \PDisk \cup \PInf[B] . \]
%
\begin{comment}
%% Do we need this comment?
(The union with $\PInf[B]$ is necessary for the case of multiple in-flight
\patches\ on the same block.)
\end{comment}
%
Thus, $\PDepset{\PInf[B]} \cap \PDepset{\PInf[B']} \subseteq \PDisk$ for
 any $B' \neq B$, and the disk controller can safely write in-flight blocks
 in any order and still preserve disk safety.


Consequently, the buffer cache must write blocks as follows:

\begin{tabbing}
\quad \textit{Write block:} \\
\quad \quad Pick some block $B$ with $\PMem[B] \neq \emptyset$ and $\PInf[B] =
\emptyset$. \\
\quad \quad Pick some $P \subseteq \PMem[B]$ with $\PDepset{P} \subseteq P \cup
\PDisk$. \\
\quad \quad Move each $p \in P$ to $\PInf$ (in-flight).
\end{tabbing}

\noindent
%
We require that $\PInf[b] = \emptyset$ since the disk controller can write
in-flight blocks in any order, and thus at most one version of a block can
be in flight at any time.
%
The buffer cache is also expected to write all blocks eventually, a
 liveness property.

\paragraph{Example}
%
Suppose a \Kudos\ system contains the \patches\ in Figure~\ref{f:ex}c,
where the journal entry patches $d_\textrm{J}$, $i_\textrm{J}$, and
 $b_\textrm{J}$ have committed and all other patches have not.
%
The buffer cache cannot write blocks $\PBlock{b}$, $\PBlock{i}$, or $\PBlock{d}$,
since $\{b$, $i$, $i'$, $d\} \PDDepend \PXcmt$ and $\PXcmt \not\in \PDisk$.
%
Its only option is to write $\PBlock{\PXcmt}$ with $P = \{\PXcmt\}$, since
 $\PDepset{\PXcmt} = \{d_\textrm{J}$, $i_\textrm{J}$, $b_\textrm{J}\}
 \subseteq \PDisk$.
%
Since $\PXcmp$ has unmet dependencies on other blocks, it must be undone
 before the write and is excluded from $P$.
%
Later, when $\PXcmt$ commits, the buffer cache has the option to
write any of $\PBlock{b}$, $\PBlock{i}$, or $\PBlock{d}$.



\input{noop}


\subsection{Discussion}

The patch abstraction seems general enough to suit many forms of
 dependency tracking.
%
Only one property of the model seems specific to conventional file systems,
 namely that circular dependency chains are errors.
%
This restriction is required because \Kudos\ assumes a lower layer that
 commits one patch at a time (or one block at a time).
%
Disks certainly behave this way, but a dependency tracker built above a
 more advanced lower layer---such as a journal---could resolve many
 circular dependency chains by forcing the relevant blocks into a single
 transaction or transaction equivalent.
%
\Featherstitch's journal module could potentially implement this, allowing
 upper layers to create (size-limited) circular dependency chains, but we
 leave this for future work.

Patches model write-before relationships, but one might instead build a
 generalized file system dependency system that modeled abstract
 transactions.
%
We chose write-before relationships as our foundation since they minimally
 constrain file system disk layout; nevertheless, it would be interesting
 to consider whether a transaction abstraction could model, say, soft
 updates-like dependencies.
