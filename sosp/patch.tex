% -*- mode: latex; tex-main-file: "paper.tex" -*-

\section{\Patch\ Model}
\label{sec:patch}

\makeatletter
\let\emptyset\varnothing
\newcommand{\PState}[1]{\ensuremath{#1.\textit{state}}}
\newcommand{\PBlock}[1]{\ensuremath{#1.\textit{block}}}
\newcommand{\PMemst}{\ensuremath{\textit{mem}}}
\newcommand{\PInfst}{\ensuremath{\textit{flight}}}
\newcommand{\PDiskst}{\ensuremath{\textit{disk}}}
\newcommand{\PSetlim}[1]{\def\@next{#1}\ifx\@next\@empty\else[\@next]\fi}
\newcommand{\PMem}[1][]{\ensuremath{\textit{Mem}\PSetlim{#1}}}
\newcommand{\PInf}[1][]{\ensuremath{\textit{Flight}\PSetlim{#1}}}
\newcommand{\PDisk}[1][]{\ensuremath{\textit{Disk}\PSetlim{#1}}}
\newcommand{\PHard}[1][]{\ensuremath{\textit{\Nrb}\PSetlim{#1}}}
\newcommand{\PSoft}[1][]{\ensuremath{\textit{\Rb}\PSetlim{#1}}}
\newcommand{\PEmpty}[1][]{\ensuremath{\textit{\Noop}\PSetlim{#1}}}
\newcommand{\PDDepset}[1]{\ensuremath{\def\@next{#1}\ifx\@next\@empty\else\@next.\fi\textit{ddeps}}}
\newcommand{\PDepend}{\ensuremath{\leadsto}}
\newcommand{\PDDepend}{\ensuremath{\rightarrow}}
\newcommand{\PDepset}[1]{\ensuremath{\textit{Dep}[#1]}}
\newcommand{\PRDepset}[1]{\ensuremath{\textit{RDep}[#1]}}
\makeatother

Every change to stable storage in a \Kudos\ system is represented by a
\emph{\patch}.
%
This section describes the basic \patch\ abstraction using a semi-formal
notation that will be useful for analyzing our optimizations later.
%
Although the \patch\ idea would apply to any stable medium, to network file
systems, or to multiple disks, we use terms like ``the disk'' and ``the
disk controller'' throughout to simplify our terminology.


Each \patch\ $p$ encapsulates four important pieces of information: its
 \emph{block}, its \emph{state}, a set of \emph{direct dependencies}, and
 some \emph{rollback data}.

\Patch\ $p$'s \textbf{block}, written $\PBlock{p}$, is the unit of disk data
 to which $p$ applies.  The disk controller is assumed to execute writes a
 block at a time (although not necessarily atomically; see below).  A file system
 change that affects $n$ blocks must be represented using at least $n$
 \patches, since a \patch\ by definition can touch only one block.

Each \patch\ is in one of three \textbf{states}: \emph{in memory}; \emph{in
 flight} to the disk controller, but not yet committed to disk; and
 \emph{on disk}.  The intermediate in-flight state is necessary because
 operating system software loses control of a \patch\ upon writing its block
 to disk.  $p$'s state is written $\PState{p} \in \{\PMemst, \PInfst,
 \PDiskst\}$.  The operating system changes a \patch's state from
 \PMemst\ to \PInfst\ by writing its block to the disk controller.  Some
 time later---after possible controller-level disk scheduling, transit over
 the system bus, and a period in the disk's cache---the disk writes the block
 to stable storage and reports success.  When the processor receives this
 notification, it changes the \patch's state to \PDiskst.
%
The sets \PMem, \PInf, and \PDisk\ are defined to contain all \patches\ with
 the given state, and the sets $\PMem[b]$, $\PInf[b]$, and $\PDisk[b]$ are
 defined to contain all \patches\ with the given state \emph{on the given
 block} $b$.

\Patch\ $p$'s \textbf{direct dependencies}, written $\PDDepset{p}$, is a set of
 other \patches\ on which $p$ ``depends''.
%
That is, every \patch\ in $\PDDepset{p}$ should be committed to disk either
 before, or at the same time as, $p$ itself.
%
(Note that \patches\ $p$ and $q$ can only be committed at the same time if
 they are on the same block.)
%
Dependencies are set by the file system based on the consistency
 semantics it wants to ensure.
%
For example, a file system with asynchronous writes (and no durability
 guarantees) might write all \patches\ with $\PDDepset{p} = \emptyset$;
%
a file system implementing soft updates would arrange the dependencies
 accordingly;
%
and a file system implementing journaling would write a different set of
 dependencies, where the journal commit record would depend on the journal
 data and the writes to the main body of the file system would in turn
 depend on the commit record.
%
In summary, an upper file system layer defines an initial set of
 dependencies;
%
the rest of \Kudos\ generally preserves this initial set, but can modify
 it as necessary to change dependency semantics;
%
and finally, the buffer cache obeys the constraints thus defined.


We say $p$ \emph{directly depends on} $q$, and write $p \PDDepend q$, when
 $q \in \PDDepset{p}$.
%
We say $p$ \emph{depends on} $q$, and write $p \PDepend q$, when there
 exists a dependency chain from $p$ to $q$: that is, either $p \PDDepend q$
 or, for some \patch\ $x$, $p \PDepend x \PDDepend q$.
%
\Patch\ $p$'s set of \emph{dependencies} is written $\PDepset{p} = \{ q \mid
 p \PDepend q \}$; this is of course a superset of its direct dependencies.
%
Given a \emph{set} of \patches\ $P$, we write $\PDepset{P}$ to mean the set's
 combined dependencies $\bigcup_{p\in P} \PDepset{p}$.



\textbf{Rollback data.}
%
When a \patch\ is created, the buffer cache's copy of the block data
is modified in-place to reflect the specified change. However,
%
some arrangements of \patches\ may require that the buffer cache
\emph{not} write one or more \patches\ on some block.
%
In particular, a series of file system operations may create dependencies
that enforce a circular order among blocks, even though the dependencies
themselves do not form a cycle~\cite{ganger00soft}.
%
For instance, a \patch\ writing the directory entry for a new file \texttt{f1}
may depend on a \patch\ allocating an inode for it, and a \patch\ deleting the
entry \texttt{f2} from the same directory may be depended upon by a \patch\
freeing the inode for \texttt{f2}.
%
If the two inodes are stored in the same block, and the two directory entries
are in the same block as well, each block will have a \patch\ depending on the
other block.
%
This is problematic since blocks with circular dependencies can never be
written: no block can be written first since each block depends on another.

For this reason, each \patch\ carries \emph{rollback} information that gives
the previous version of the range of block data altered by the \patch.
%
If a \patch\ $p$ is not written with its containing block, the system rolls
back the \patch, which swaps the new data and the previous version on
the (single) copy of the block in the buffer cache.
%
Once the block is written, the system will roll the \patch\ forward and, when
allowed, write the block again, this time including the \patch.
%
Rollback information adds greatly to memory and CPU utilization, but it can
often be optimized away, as we show below.

%
Our \patch\ notation is summarized in Figure~\ref{fig:patchnot}.

\begin{figure}[t]
\begin{small}
\begin{tabular}{@{}ll@{}}
$\PBlock{p} = b$ & $p$'s block \\
$\PState{p}$ & $p$'s state, $\in \{\PMemst, \PInfst, \PDiskst\}$ \\
$\PDDepset{p}$ & $p$'s direct dependencies: \patches\ that must go to disk \\
	& before $p$ \\
\noalign{\vskip3pt}
$\PMem$ & all in-memory \patches: $\{p \mid \PState{p} = \PMemst\}$ \\
$\PMem[b]$ & $\{p \mid \PState{p} = \PMemst \text{ and } \PBlock{p} = b
 \}$ \\
$\PInf, \PDisk$ & similarly for in-flight and on-disk \patches\ \\
\noalign{\vskip3pt}
$p \PDDepend q$ & $p$ directly depends on $q$: $q \in \PDDepset{p}$ \\
$p \PDepend q$ & $p$ depends on $q$: either $p \PDDepend q$ or there exists \\
       & a \patch\ $x$ so that $p \PDepend x \PDDepend q$ \\
$\PDepset{p}$ & $p$'s dependencies: $\{ q \mid p \PDepend q \}$ \\
\end{tabular}
\end{small}

\caption{\Patch\ notation.}
\label{fig:patchnot}
\end{figure}


\subsection{Obeying Dependencies}
\label{sec:patch:dependencies}

\Kudos\ must ensure the \textbf{disk safety property}, which states that
 the dependencies of all \patches\ on disk are also on disk:
%
\[ \PDepset{\PDisk} \subseteq \PDisk. \]
%
Thus, no matter when the system crashes, the disk is consistent in terms of
dependencies.
%
The file system's job is to set up dependencies so that the disk safety
property implies file system correctness.

However, \Kudos\ can only control when \patches\ are handed to the disk
 controller, not when they are written to disk.
%
Disk controller behavior is encapsulated in the following atomic action:

\begin{tabbing}
\textit{Commit block:} \\
\quad Pick some block $b$ with $\PInf[b] \neq \emptyset$. \\
\quad For each $p \in \PInf[b]$, set $\PState{p} \gets \PDiskst$.
\end{tabbing}

\noindent
%
Since the controller can write blocks in any order, \Kudos\ must ensure
that in-flight blocks are mutually independent.  This is precisely stated
by the \textbf{in-flight safety property:}
%
\[ \text{For all blocks $b$,~~} \PDepset{\PInf[b]} \subseteq \PInf[b] \cup \PDisk . \]
%
This ensures that for any $b' \neq b$, $\PDepset{\PInf[b]} \cap
 \PDepset{\PInf[b']} \subseteq \PDisk$; the disk controller can safely
 write in-flight blocks in any order and still preserve disk safety.
%
(The union with $\PInf[b]$ is necessary for the case of multiple in-flight
\patches\ on the same block.)


The buffer cache must thus behave according to the following atomic action:

\begin{tabbing}
\textit{Write block:} \\
\quad Pick some block $b$ with $\PMem[b] \neq \emptyset$. \\
\quad Pick some $P \subseteq \PMem[b]$ with $\PDepset{P} \subseteq P \cup
\PDisk$. \\
\quad For each $p \in P$, set $\PState{p} \gets \PInfst$. \\
\quad For each $p \in \PMem[b]-P$, set $\PDDepset{p} \gets \PDDepset{p}
\cup P$.
\end{tabbing}

\noindent
%
Since the disk controller can write in-flight blocks in any order, at most
one version of a block can be in flight at any time.
%
Thus, the last step above forces any rolled-back \patches\ to wait in
memory at least until the in-flight version of the block is written.
%
Likewise, any \patch\ created on a block with in-flight \patches\ must depend
on those \patches.
%
(These dependencies are implicit in our implementation.)
%
The buffer cache is also expected to write all blocks eventually, a
 liveness property.


This model does not completely define the disk's behavior on system crash,
 in particular with respect to in-flight blocks.
%
Soft updates inherently assumes that blocks are written
\emph{atomically}, except in the case of catastrophic media error:
%
if the disk fails while a block $b$ is in flight, then $b$'s
value on recovery must equal either the old value or the new value.
%
Most journal designs do not rely on this assumption, and can recover
 properly even if in-flight blocks are corrupted---for instance,
 because the memory holding the new value of the block lost its coherence
 before the disk stopped writing~\cite{nightingale06rethink}.
%
However, some disks may actually provide an atomicity guarantee, for
 instance by using non-volatile memory to store blocks before they make it
 onto disk.
%
The \Kudos\ core makes no assumptions about block atomicity, instead relying
 on software above it to implement a consistency protocol that makes sense
 for the given disk.


The buffer cache can't handle cross-block dependency cycles since it must
write data in units of blocks.
%
Thus, if $p \PDepend q \PDepend p$, then $p$ and $q$ must be on the same
block; otherwise, neither $p$ nor $q$ could ever get written.
%
Whenever upper layers might generate cross-block dependency cycles,
intervening layers must break those cycles somehow before they reach the
cache.
%
For instance, a journal layer might detect dependency cycles and put the
corresponding \patches\ into a single transaction, but the
\emph{implementation} of that transaction could not contain cross-block
cycles.
%
In practice, the \Kudos\ implementation currently disallows any dependency
cycles, including cycles within a single block; this simplifies many graph
traversals.


\input{noop}


\section{\Patch\ Optimizations}
\label{sec:patch:optimizations}

A naive implementation of this model has all the properties we want except
good performance.
%
File system modules can define their own consistency protocols, other
modules can modify them,
%
applications can affect consistency orderings, and it is all relatively
easy thanks to the \patch\ abstraction.
%
Unfortunately, this abstraction is extremely expensive.


Consider an unoptimized version of \Kudos\ running an ext2 file system with
dependencies arranged according to the soft updates rules (i.e., never write a
pointer to a structure until it has been initialized, never reuse such
structures until all previous pointers to them have been overwritten, and
never overwrite the last pointer to a live structure before a new pointer to
it has been written).
%
Figure~\ref{fig:opt}a shows the \patches\ generated when an application appends
16~kB of data to an existing empty file.
%
Each circle represents a single \patch. The shaded boxes indicate disk blocks.
%
The arrows between \patches\ represent the dependency relationship \PDDepend.

This change requires allocating four new 4~kB blocks (\patches\ $b_1$-$b_4$),
writing data to them ($d_1$-$d_4$), attaching them to the file's inode (right
$i_1$-$i_4$), changing the inode's file size and modification time (left
$i_1$-$i_4$ and $i$), and updating the ``group descriptor'' and superblock to
account for the allocated blocks ($g$ and $s$).
%
The operation is broken into four one-block appends; the numeric subscripts in
the \patch\ labels indicate with which each \patch\ is associated.
%
All of the one-block appends update the inode; note, for example, how overlap
dependencies force each modification of the inode's size to depend on the
previous one.

A total of eight blocks are written during the operation.
%
\Kudos, however, represents the operation with 23 \patches\ and roughly 33000
(!) bytes of rollback data.
%
The \patches\ slow down the buffer cache system by making graph traversals
more expensive.
%
The 4096 bytes of rollback data per \patch\ stored for ``clear data'' and
``write data'' \patches, which initialize and write data blocks, is
particularly painful since in this example, data blocks \emph{never}
need to be rolled back!


This section shows how the actual \Kudos\ system uses generic \patch\
properties and dependency analysis to reduce the 23 \patches\ and 33000 bytes
of rollback data in Figure~\ref{fig:opt}a to the 8 \patches\ and 0 bytes of
rollback data in Figure~\ref{fig:opt}d.
%
These optimizations apply transparently to any \Kudos\ file system.


\begin{comment}

Challenges in a \patch-based file system implementation include:

\textbf{Buffer cache graph traversal.}
%
In order to evict and write a block, the buffer cache must choose a block
$b$,
%
and then find a set of \patches\ $P_b \subseteq \PMem[b]$ whose dependencies
satisfy a graph property, namely that $\PDepset{P_b} \subseteq P_b \cup
\PDisk$.
%
It usually makes sense to define $P_b$ maximally---that is, as the
\emph{largest} corresponding set of \patches.
%
In the ideal (and common) case $P_b = \PMem[b]$, which lets the cache reuse
$b$'s memory once $P_b$ is committed to disk.  However, in some cases there
may be no block for which $P_b = \PMem[b]$.
%
It would also be nice if the blocks chosen for writing also maximized the
disk's commit rate, by minimizing seeks and so forth.

A naive implementation might calculate, for each in-memory block $b$, the
largest set of \patches\ $P_b \subseteq \PMem[b]$ with $\PDepset{P_b}
\subseteq P_b \cup \PDisk$, then evict some block close to previously
written blocks and with few rolled-back \patches\ (where $\PMem[b] - P_b$
is small).
%
This, however, would be extraordinarily expensive.
%
Finding $P_b$ requires traversing a dependency graph which might contain
thousands and thousands of nodes.
%
Doing so for each block, once per eviction, would take huge amounts of CPU
time.


\textbf{Rollback memory usage.}
%
Only a small fraction of \patches\ will ever need to be rolled back.
%
For example, most data writes never need to be rolled back in any file
system.
%
If a \patch\ won't be rolled back under any circumstances, the memory and
CPU time spent to preserve the old version is wasted.


\textbf{\Patch\ memory usage.}
%
\Patches\ themselves take up memory and require time to allocate, free, and
traverse.
%
If two \patches\ have redundant dependencies, it would be faster to combine
them.


%% \textbf{Dependency memory usage.}
%% %
%% The $\PDDepset{}$ sets are stored as doubly linked lists; each individual
%% dependency takes up memory.
%% %
%% Important and common dependency relations require many dependencies to
%% express; for example, if \patches\ $p_1,\dots,p_n$ depend, as a group, on
%% \patches\ $q_1,\dots,q_n$, expressing this constraint would require $n^2$
%% total dependencies.


The next section tackles all of these challenges.
\end{comment}


\begin{figure}
\centering

\includegraphics[scale=0.62]{fig/opt_1}

\textbf{a)} Naive implementation

\vskip.5\baselineskip

\includegraphics[scale=0.62]{fig/opt_2}

\textbf{b)} With \nrb\ \patches\ \dots

\vskip.5\baselineskip

\includegraphics[scale=0.62]{fig/opt_3}

\textbf{c)} \dots plus \nrb\ \patch\ merging \dots

\vskip.5\baselineskip

\includegraphics[scale=0.62]{fig/opt_4}

\textbf{d)} \dots plus overlap merging

\caption{\Patches\ required to append 4 blocks to an existing file, without
and with optimization.  \Nrb\ \patches\ are shown with heavy borders.}
\label{fig:opt}
\label{f:opt} % EDDIE: OK
\end{figure}

\input{nrb}
\input{merge}
\input{readylist}
\input{misc}
