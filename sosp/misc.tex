% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Other Optimizations}
\label{sec:patch:misc}

Even with these optimizations, there is only so much
that can be done with bad sets of dependencies.
%
Just as having too few dependencies can compromise system correctness,
having too many dependencies, or the wrong dependencies, can non-trivially
degrade the system performance.
%
For example, in both the following \patch\ arrangements, $p$ depends on all
of $q$, $r$, and $s$, but the left-hand arrangement gives the system more
freedom to reorder block writes:

\begin{figure}[htb]
\centering
\begin{tabular}{@{}p{.45\hsize}p{.45\hsize}@{}}
\centering \includegraphics[width=.5\hsize]{fig/figures_4} &
\centering \includegraphics[width=.5\hsize]{fig/figures_6}
\end{tabular}
\vskip-\baselineskip
\end{figure}

\noindent%
For example, if $q$, $r$, and $s$ are adjacent on disk, the left-hand
arrangement can be satisfied with two disk requests while the right-hand
one will require four.
%
Although the arrangements have similar coding difficulty, in several cases
we discovered that one of our file system implementations was performing
slowly because it created an arrangement like the one on the right.

Care must also be taken to avoid unnecessary \emph{implicit} dependencies,
and in particular overlap dependencies.
%
For instance, inode blocks contain multiple inodes, and changes to two
inodes should generally be independent; a similar statement holds for
directories and even sometimes for different fields in a summary block like
the superblock.
%
The best results can be obtained from \emph{minimal} \patches\ that change
one independent field at a time; \Kudos\ will merge these \patches\ when
appropriate, but if they cannot be merged, minimal \patches\ will lead to
fewer \patch\ revert operations and more flexibility in write ordering.


%% the changes to update a field in an inode structure
%% on disk, a \patch\ spanning the entire inode could be created even though
%% only a single field changed. A later change to a different field in the
%% same inode would appear to overlap the first, possibly creating an
%% unnecessary dependency. Creating \patches\ that correspond more precisely
%% to the changes being made avoids this problem, so a utility function is
%% provided by \Kudos\ to make this operation as convenient as creating a
%% single \patch\ for an entire large structure.

%% \subsubsection{\Patch\ List Ordering}

The buffer cache and a few other \modules\ perform better in the
common case that the \patches\ on a block are listed in order of creation
time.
%
This improves their performance from $O(n^2)$ to $O(n)$ in the number of
\patches.
%% in the common case that this order is preserved.

Finally, block allocation policies can have a dramatic effect on the number of
I/O requests required to write changes to the disk. For instance, with
dependencies implementing soft updates, indirect block data cannot be written
until the referenced blocks have been at least initialized. By allocating an
indirect block in the middle of a range of data blocks for a file, the data
blocks must be written as two smaller I/O requests since the indirect block
cannot be written at the same time. Allocating the indirect block somewhere
else allows the data blocks to be written in one larger I/O request.


\begin{comment}
Several functions in \Kudos\ iterate over lists of \patches\ looking for either
a single \patch\ or set of \patches\ satisfying some property, or trying to
process all the \patches\ in the list in some order determined by the dependency
graph. It is generally the case that the \patches\ satisfying the property or
the order in which the \patches\ should be processed can be determined very
quickly by keeping the lists sorted. For instance, the library function which
reverts \patches\ needs to perform the revert operations essentially in inverse
creation order, so that reverting a \patch\ which has since been overwritten
by a later \patch\ does the right thing. Keeping the list of all \patches\ on a
block sorted in creation order (which is very easy) makes this an efficient
operation, while it might otherwise take $O(n^2)$ time to execute. Similarly,
many \patch\ merging functions need to find for a given block some \patch\
which has no \befores\ on the same block, and the oldest \patch\ on a block
always satisfies this requirement.
\end{comment}
