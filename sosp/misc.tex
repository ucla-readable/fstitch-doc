% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Other Optimizations}
\label{sec:patch:misc}

Even with these optimizations, there is only so much
that can be done with bad sets of dependencies.
%
Just as having too few dependencies can compromise system correctness,
having too many dependencies, or the wrong dependencies, can non-trivially
degrade the system performance.
%
For example, in both the following patch arrangements, $p$ depends on all
of $q$, $r$, and $s$, but the left-hand arrangement gives \Kudos\ much more
freedom to choose a better-performing order for block writes:

\begin{figure}[htb]
\centering
\begin{tabular}{@{}p{.45\hsize}p{.45\hsize}@{}}
\centering \includegraphics[width=.5\hsize]{fig/figures_4} &
\centering \includegraphics[width=.5\hsize]{fig/figures_6}
\end{tabular}
\vskip-\baselineskip
\end{figure}

\noindent%
For example, if $q$, $r$, and $s$ are adjacent on disk, the left-hand
arrangement can be satisfied with two disk requests while the right-hand
one will require four.
%
Although the arrangements have similar coding difficulty, in several cases
we discovered that one of our file system implementation was performing
slowly because it created an arrangement like the one on the right.

Care must also be taken to avoid unnecessary \emph{implicit} dependencies,
and in particular overlap dependencies.
%
For instance, inode blocks contain multiple inodes, and changes to two
inodes should generally be independent; a similar statement holds for
directories and even sometimes for different fields in a summary block like
the superblock.
%
The best results can be obtained from \emph{minimal} patches that change
one independent field at a time; \Kudos\ will merge these patches when
appropriate, but if they cannot be merged, minimal patches will lead to
fewer rollbacks and more flexibility in write ordering.


%% the changes to update a field in an inode structure
%% on disk, a \chdesc\ spanning the entire inode could be created even though
%% only a single field changed. A later change to a different field in the
%% same inode would appear to overlap the first, possibly creating an
%% unnecessary dependency. Creating \chdescs\ that correspond more precisely
%% to the changes being made avoids this problem, so a utility function is
%% provided by \Kudos\ to make this operation as convenient as creating a
%% single \chdesc\ for an entire large structure.

%% \subsubsection{\ChDesc\ List Ordering}

Finally, the buffer cache and a few other modules perform better in the
common case that the \patches\ on a block are listed in order of creation
time.
%
This improves their performance from $O(n^2)$ to $O(n)$ in the number of
patches.
%% in the common case that this order is preserved.


\begin{comment}
Several functions in \Kudos\ iterate over lists of \chdescs\ looking for either
a single \chdesc\ or set of \chdescs\ satisfying some property, or trying to
process all the \chdescs\ in the list in some order determined by the dependency
graph. It is generally the case that the \chdescs\ satisfying the property or
the order in which the \chdescs\ should be processed can be determined very
quickly by keeping the lists sorted. For instance, the library function which
rolls \chdescs\ back needs to perform the rollbacks essentially in inverse
creation order, so that rolling back a \chdesc\ which has since been overwritten
by a later \chdesc\ does the right thing. Keeping the list of all \chdescs\ on a
block sorted in creation order (which is very easy) makes this an efficient
operation, while it might otherwise take $O(n^2)$ time to execute. Similarly,
many \chdesc\ merging functions need to find for a given block some \chdesc\
which has no \befores\ on the same block, and the oldest \chdesc\ on a block
always satisfies this requirement.
\end{comment}
