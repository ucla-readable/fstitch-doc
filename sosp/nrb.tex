% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{\Nrb\ \Patches}
\label{sec:patch:nrb}

The first optimization reduces space overhead by
eliminating undo data.
%
When a \patch\ $p$ is created, \Kudos\ conservatively detects whether $p$
 might ever need to be reverted.
%
That is, \Kudos\ detects whether future patches and dependencies could ever
 create a state where the only way the buffer cache could make progress is
 by undoing $p$.
%
If this is impossible---if no future patches and dependencies could force
 $p$'s reversion---then $p$ does not need undo data, and we call $p$ a
 \emph{\nrb\ \patch}: its data can be applied to the in-memory copy of the
 block without saving the previous version.


Only \patches\ in a block-level dependency cycle might need to be reverted.
%
However, some of the \patches\ in a cycle may be \nrb; only the crucial
\patch\ that creates the cycle must be \rb, for that is the \patch\ that
must be reverted to create a valid write order.
%
Thus, \patch\ $p$ may be \nrb\ if it will \emph{never} be the head of a
block-level cycle: that is, if there will never exist true \patches\ $q$
and $p'$ with $p \PDepend q \PDepend p'$ and $\PBlock{p} = \PBlock{p'}
\neq \PBlock{q}$.
%
In other words, if the only cycle between $\PBlock{p}$ and $\PBlock{q}$ is $p
\PDDepend q \PDDepend p'$, then $q$ and $p'$ may be \nrb, but $p$ may
not.
%
As a result, the set of all \nrb\ \patches\ in memory will never contain
a block-level cycle, and the system can always find a valid order to
write \nrb\ \patches\ to disk.
%
This assumes that the dependency structure correctly represents
dependencies among \patches\ on the same block.
%
Specifically, all \nrb\ \patches\ on a block depend on each other (since
they can't be written independently), and any \rb\ \patch\ on a block
depends on that block's \nrb\ \patches, if any (since it cannot be written
without them).


When \patch\ $p$ is created, \Kudos\ must decide whether any future
\patch\ or dependency could create a block-level cycle with $p$ at the
head.
%
This decision is simplified by an API property: \emph{All of a \patch's
direct dependencies are specified at creation time};
%
no new dependencies $p \PDDepend q$ may be introduced after $p$ is
created.\footnote{The actual rule is somewhat more flexible: modules may add
  new direct dependencies if they guarantee that those dependencies
  don't introduce any new block-level cycles.  As one example, if no
  \patch\ depends on some \noop\ \patch\ $p$, then adding a new $p
  \PDDepend q$ dependency can't introduce a cycle.}
%
Since every \patch\ follows this rule, all possible block-level cycles $p
\PDepend q \PDepend p'$ are visible at creation time.


Traversing the dependency graph to check for a block-level cycle
proved to be quite expensive.
%
\Kudos\ thus implements a conservative approximation: \patch\ $p$ is
created as \nrb\ if \emph{no} other block depends on the in-memory
version of $\PBlock{p}$.
%
That is, for all dependencies $q \PDepend p'$ with $p' \in
\PMem[\PBlock{p}]$, either $\PBlock{q} = \PBlock{p}$ or $q$ is \anoop\
\patch.
%
If no other block depends on $p$'s block, then $p$ can never initiate a
block-level cycle no matter its dependencies.
%
Determining this property is less expensive than a full graph
traversal, and works well in practice.


\Kudos\ further ensures that the dependency structure correctly
represents dependencies on the same block through overlap
dependencies: since \nrb\ \patches\ are considered to cover the entire
block, every succeeding \patch\ will overlap at least one \nrb\ \patch,
and \Kudos\ will automatically add a dependency.
%
(Some cases are handled by other optimizations.)


The buffer cache's ``write block'' behavior must account for \nrb\
\patches, as it \emph{must} write any \nrb\ \patches\ that exist on a
block.
%
Let $\PHard[b]$ be the set of \nrb\ \patches\ on block $b$.
%
Then to write block $b$, the buffer cache must choose some $P \subseteq
\PMem[b]$ with
%
\[ \PDepset{P} \subseteq P \cup \PDisk \text{ and } \PHard[b] \cap \PMem
\subseteq P. \]
%
If no such $P$ exists, then the cache must write a different block.


Applying \nrb\ \patch\ rules to our example makes 14 of the 23 \patches\ \nrb\
(Figure~\ref{fig:opt}b),
%
reducing the undo data required by slightly more than half.


\begin{comment}
%
To avoid this overhead, \Kudos\ identifies \patches\ that will never
need to be reverted and omits their undo data. We call these \emph{\nrb}
\patches. (The opposite naturally being a \emph{\rb} \patch, when
necessary to differentiate them.)
%
Since a \nrb\ \patch\ cannot be reverted, a write of any \patches\
on block $B$ must include all \nrb\ \patches\ on $B$. To accordingly
update our formal model we define a new set of \patches, \PHard, which
contains all \nrb\ \patches. We write \PHard[B] to restrict the set
to block $B$\todo{Introduce \PSoft\ and \PSoft[B].}:

\begin{tabbing}
\textbf{Write block.} \\
\quad Pick some block $b$ with $\PMem[b] \neq \emptyset$. \\
\quad Pick some $P \subseteq \PMem[b]$ with $\PDepset{P} \subseteq P \cup
\PDisk$ and $\PHard[B] \subseteq P$. \\
\quad Move each $p \in P$ to $\PInf$ (in-flight). \\
\quad For each $p \in \PMem[b]-P$, set $\PDDepset{p} \gets \PDDepset{p}
\cup P$.
\end{tabbing}

\paragraph{}
To avoid (expensive) dependency traversals to determine whether a new
\patch\ will need to be reverted,
%
\Kudos\ conservatively identifies \nrb\ \patches\ using only local
dependency information.
%
\Kudos\ detects that a new \patch\ on block $b$ may need to be reverted if:
\todo{Which form is easier to read? Can we write \(\PMem - \PMem[b] - \PEmpty\) more concisely?}
%
\todo{Actually, our implementation also uses in flight \patches. Can we make
it not?}
%
\[ \PRDepset{\PMem[b]} \cap (\PMem - \PMem[b] - \PEmpty) \ne \emptyset \]
\[ \exists \inset{p}{\PMem[b]}\!:\
   \exists c\!:\ \exists \inset{q}{\PMem[c]}\!:\
   \indirdepends{q}{p} \]
%
This is both a safe and useful indicator because
%
the presence of an external \after\ is a necessary condition for a new
\patch's \before\ to induce a block-level cycle
%
and many blocks have no \patches\ with external \afters\ (e.g. most
file data blocks).

While this algorithm detects whether a \patch\ may need to be reverted,
\Kudos\ must also be sure that no future dependency manipulation
will cause the \patch\ to require being reverted.
%
We introduce Invariant~\ref{cdinvar:add-before} to support such reasoning:
%
\cdinvar{add-before}{All block-level cycles induced through
\patch\ \p{p}'s \befores\ exist when \p{p} is
created\todo{Change this phrasing? ``Once created, a \patch\ will not
gain any \befores\ that induce block-level cycles.''}.}
%
\noindent \Kudos\ ensures this invariant by restricting \before\
additions to \patch\ creation, \noop\ \patches\ with no \afters, or
when the invariant is statically proven to hold for the affected
\patches.
\end{comment}
