\subsection{\Nrb\ \ChDescs}
\label{sec:chdescs:nrb}

The first optimization reduces the space overhead of rollback data by
detecting when rollback data will never be necessary.
%
When a patch $p$ is created, \Kudos\ conservatively detects whether $p$
will ever need to be rolled back.
%
If it will not, $p$ is a \emph{hard patch}: its data can be applied
directly to the in-memory copy of the block without saving rollback data
for the previous version.


Only patches that are part of a block-level dependency cycle might need to
be rolled back.
%
Thus, patch $p$ may be hard iff it cannot be part of a block-level
dependency cycle: that is, there will \emph{never} exist patches $q$ and
$r$ with $\PBlock{p} = \PBlock{r} \neq \PBlock{q}$ and $p \PDepend q
\PDepend r$.


To create a hard patch, then, \Kudos\ must conservatively decide whether
any future patch or dependency could create a block-level cycle.
%
This decision is simplified by an API property: \emph{All of a patch's
direct dependencies are specified at creation time};
%
no new dependencies $p \PDDepend q$ may be introduced after $p$ is
created.\footnote{The actual rule is somewhat looser: modules may add new
direct dependencies if they can guarantee that those dependencies won't
introduce any new block-level cycles.  For instance, if an empty patch $p$
is not depended on by any other patch, adding a new $p \PDDepend q$
dependency cannot cause a cycle.}
%
Since every patch follows this rule, all possible block-level cycles $p
\PDepend q \PDepend r$ are visible at creation time.


However, traversing the dependency graph to exactly determine the
possibility of a block-level cycle could explode in complexity.
%
Thus, \Kudos\ implements a conservative approximation: patch $p$ may be
hard if no other block depends on the current state of $\PBlock{p}$.
%
That is, for all dependencies $q \PDepend r$, either $\PState{r} \neq
\PMemst$, $\PBlock{r} \neq \PBlock{p}$, or $\PBlock{q} = \PBlock{p}$.


\begin{compactitemize}
\item 
\end{compactitemize}


%
To avoid this overhead, \Kudos\ identifies \chdescs\ that will never
need to be rolled back and omits their previous data copies. We call
these \emph{\nrb} \chdescs. (The opposite naturally being a \emph{\rb}
\chdesc, when necessary to differentiate them.)
%
Since a \nrb\ \chdesc\ cannot be rolled back, a write of any \chdescs\
on block $B$ must include all \nrb\ \chdescs\ on $B$. To accordingly
update our formal model we define a new set of \chdescs, \PHard, which
contains all \nrb\ \chdescs. We write \PHard[B] to restrict the set
to block $B$\todo{Introduce \PSoft\ and \PSoft[B].}:

\begin{tabbing}
\textbf{Write block.} \\
\quad Pick some block $b$ with $\PMem[b] \neq \emptyset$. \\
\quad Pick some $P \subseteq \PMem[b]$ with $\PDepset{P} \subseteq P \cup
\PDisk$ and $\PHard[B] \subseteq P$. \\
\quad For each $p \in P$, set $\PState{p} \gets \PInfst$. \\
\quad For each $p \in \PMem[b]-P$, set $\PDDepset{p} \gets \PDDepset{p}
\cup P$.
\end{tabbing}

\paragraph{}
To avoid (expensive) dependency traversals to determine whether a new
\chdesc\ will need to be rolled back,
%
\Kudos\ conservatively identifies \nrb\ \chdescs\ using only local
dependency information.
%
\Kudos\ detects that a new \chdesc\ on block $b$ may need to be rolled back if:
\todo{Which form is easier to read? Can we write \(\PMem - \PMem[b] - \PEmpty\) more concisely?}
%
\todo{Actually, our implementation also uses in flight \chdescs. Can we make
it not?}
%
\[ \PRDepset{\PMem[b]} \cap (\PMem - \PMem[b] - \PEmpty) \ne \emptyset \]
\[ \exists \inset{p}{\PMem[b]}\!:\
   \exists c\!:\ \exists \inset{q}{\PMem[c]}\!:\
   \indirdepends{q}{p} \]
%
This is both a safe and useful indicator because
%
the presence of an external \after\ is a necessary condition for a new
\chdesc's \before\ to induce a block-level cycle
%
and many blocks have no \chdescs\ with external \afters\ (e.g. most
file data blocks).

While this algorithm detects whether a \chdesc\ may need to be rolled
back, \Kudos\ must also be sure that no future dependency manipulation
will cause the \chdesc\ to require a rollback.
%
We introduce Invariant~\ref{cdinvar:add-before} to support such reasoning:
%
\cdinvar{add-before}{All block-level cycles induced through
\chdesc\ \p{p}'s \befores\ exist when \p{p} is
created\todo{Change this phrasing? ``Once created, a \chdesc\ will not
gain any \befores\ that induce block-level cycles.''}.}
%
\noindent \Kudos\ ensures this invariant by restricting \before\
additions to \chdesc\ creation, \noop\ \chdescs\ with no \afters, or
when the invariant is statically proven to hold for the affected
\chdescs.
