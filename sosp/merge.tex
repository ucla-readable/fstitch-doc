% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{\Nrb\ \Patch\ Merging}
\label{sec:patch:merge}

File operations such as block allocations, inode updates, and directory updates
create many distinct \patches. Keeping track of these
\patches\ and their dependencies requires a significant amount of memory and
CPU time.
%
\Kudos\ therefore \emph{merges} \patches\ when possible, drastically reducing
the \patch\ counts and memory usage, by conservatively identifying when a
new \patch\ could always be written at the same time as an existing \patch.
%
Rather than creating a new \patch\ in this case, \Kudos\ updates the data
and dependencies so as to merge the new \patch\ into the existing one.


The first type of merging is trivial to explain:
%
since all of a block's \nrb\ \patches\ must be written at the same time, there
is no need to maintain more than one \nrb\ \patch\ per block.
%
All other \nrb\ \patches\ can safely be merged into the first,
%
and in fact \Kudos\ ensures that each block contains at most one \nrb\
\patch.


Assume some module attempts to create a \patch\ $p$ on a block that already
has a \nrb\ \patch\ $h$, and \Kudos\ determines that $p$ may be \nrb.
%
Then the implementation merges $p$ into $h$ at creation time by applying
$p$'s data to the block and setting $\PDDepset{h} \gets \PDDepset{h} \cup
\PDDepset{p}$.
%
Although this changes $h$'s direct dependency set, that change cannot
introduce any new block-level cycles or $p$ could not have been \nrb\ in the
first place.
%
The existing \nrb\ \patch\ $h$ is returned to the caller.


Unfortunately, the merge can create \emph{intra}-block cycles.
%
If some \noop\ \patch\ $x$ exists with $p \PDepend x \PDepend h$, then after
the merge $h \PDepend x \PDepend h$.
%
The merge algorithm uses a graph traversal to prune these cyclic
dependencies as it merges $p$'s dependencies into $h$.


\Nrb\ \patch\ merging is able to eliminate 8 of the \patches\ in our running
example, as shown in Figure~\ref{fig:opt}c.


\paragraph{\Rb-to-\Nrb\ Conversion}

A new \nrb\ \patch\ might also be created on a block
that has existing \emph{\rb} \patches\ in memory.
%
For example, Figure~\ref{f:soft2hard}a shows a block with both \nrb\ and
\rb\ \patches: $p_1$ must be \rb\ since it initiates a block-level cycle
$p_1 \PDepend q_h \PDepend p_h$, and similarly for $p_2$ and $p_3$.
%
To write these blocks, the buffer cache must revert $p_1$, $p_2$, and
$p_3$ and write $p_h$ on its own.
%
Once $p_h$ reaches disk, the \patches\ in memory reach the state in
Figure~\ref{f:soft2hard}b.
%
Now that $p_h$ has moved to \PDisk, it is irrelevant for cycle detection,
and in fact there are no block-level dependency cycles in the diagram: it
would be safe to transform $p_1$, $p_2$, and $p_3$ into \nrb\ \patches.
%
However, \Kudos\ delays this and performs the conversion only later when
adding a new \nrb\ \patch\ to the $p$ block. 


Consider a new \nrb\ \patch\ $p_h$ that is added to a block that contains some
\rb\ \patch\ $p$.
%
Since $p_h$ overlaps $p$, \Kudos\ adds a direct dependency $p_h \PDDepend p$.
%
Since $p_h$ could be \nrb, we know there are no block-level dependency cycles
$p_h \PDepend q \PDepend p'$.
%
But as a result, we know that there are no block-level dependency cycles
with the existing \emph{\rb} \patch\ as head, since such a cycle would imply
a $p_h$-headed cycle $p_h \PDDepend p \PDepend q \PDepend p'$.
%
Thus, $p$ can be transformed into a \nrb\ \patch\ and then merged into $p_h$
using \nrb\ \patch\ merging.
%
Figure~\ref{f:soft2hard}c shows the resulting configuration when a new \nrb\
\patch\ $p_h'$ is added.


\begin{figure}
\centering
\begin{small}
\begin{tabular}{@{}p{.32\hsize}@{~~}p{.32\hsize}@{~~}p{.32\hsize}@{}}
\includegraphics[width=\hsize]{fig/softhard_1} &
\includegraphics[width=\hsize]{fig/softhard_2} &
\includegraphics[width=\hsize]{fig/softhard_3} \\
\centering \textbf{a)} Initial state &
\centering \textbf{b)} After $p_h$ reaches~disk &
\centering \textbf{c)} \Rb-to-\nrb\ conversion
\end{tabular}
\end{small}
\caption{\Rb-to-\nrb\ conversion. (Note that $q_h$ is on a different block.)}
\label{f:soft2hard}
\end{figure}



\begin{comment}

\Kudos\ includes three distinct \patch\ merge algorithms.
%
All three use Invariant~\ref{cdinvar:add-before} to reason about future
graph changes and use fast, conservative checks during \patch\ creation;
they differ in their applicable conditions.


\subsubsection{\Nrb\ \Patch\ Merging}
\label{sec:patches:merge:nrb}

Recall from Section~\ref{sec:patches:nrb} that a write of any \patches\ on
block $b$ must include all \nrb\ \patches\ on $b$.
%
This additional requirement is in fact an exquisite optimization
opportunity; it implies that all \nrb\ \patches\ on a given block can
be merged.
%
Further, merging can remove the need for the \nrb\ \patch\ implicit
dependency rules by ensuring that
%
there is at most one \nrb\ \patch\ per block (\nrb-\nrb\ merging)
%
and that all \rb\ \patches\ on a given block depend on the \nrb\ \patch\
(\nrb-\rb\ merging).
%
We describe these two \patch\ merging algorithms and how they
preserve dependency semantics in this section.

\paragraph{\Nrb-\Nrb\ \Patch\ Merging}
\label{sec:patches:merge:nrb:hard-hard}

\emph{\Nrb-\nrb\ \patch\ merging} merges a new \nrb\ \patch\ \p{q}
into an existing \nrb\ \patch\ \p{p} instead of creating \p{q}.
%
Any two \nrb\ \patches\ on the same block may be (and are) merged.
%
Merging all \nrb\ \patches\ ensures:
%
\cdinvar{one-nrb}{\(\forall\! b\!: |\PHard[b]| \leq 1\)}
%
\noindent
%
Invariant~\ref{cdinvar:one-nrb} simplifies \nrb\ \patch\ handling by
%
removing the implicit dependencies that ensure all \nrb\ \patches\
are written together
%
and by removing the need to scan for an existing \nrb\ \patch\ when
\nrb-\nrb\ \patch\ merging.
%
% Although merging two \patches\ will not induce block-level dependency
% cycles, without sufficient care merging could induce \patch-level
% dependency cycles.  A trivial example is merging \p{q} into \p{p} when
% \p{q} has an explicit dependency on \p{p}; the combined \p{(p+q)}
% should not and need not depend on itself.
%
To preserve dependency semantics, the merged \p{(p+q)} must depend on
the union of \p{p} and \p{q}'s transitive \befores. Additionally, while the
\patches\ can be merged without forming a \patch-level dependency cycle,
the merge must ensure that it does not introduce a needless cycle, e.g.
through \anoop\ \patch\ \p{e} in \depends{q}{\depends{e}{p}}
\todo{Is cycle avoidance worth mentioning? Is this a good way to mention it?}.

From Invariant~\ref{cdinvar:add-before} and the \nrb\ \patch\
creation condition (no external \afters), the only possible
dependencies involving \p{p} and \p{q} are those shown in
Figure~\ref{fig:nrb-merge}\todo{Should we give these deductions or a
  flavor?}.
%
Notice, for example, that any \p{r} such that
\indirdepends{q}{\indirdepends{r}{p}} is \anoop\ \patch\todo{This is
  a strong statement. Expand on its implications?}.
%
Our algorithm to transform dependencies for \nrb-\nrb\ \patch\ merges
(Figure~\ref{algo:merge:hard-hard}) follows from these possible
dependencies.
%
It updates \p{p}'s transitive \befores\ to ensure
\(\PDepset{q}\todo{Incorrect! Only the true \patches.} \subseteq
\PDepset{p}\)\todo{Note that Invariant~\ref{cdinvar:add-before}
  ensures that \noop\ \patches\ reachable from \p{q} will not gain
  data \patch\ \befores?}\todo{Note that it only needs to move dependencies?}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \nrb\ \patch\ \p{q}
    into existing \nrb\ \patch\ \p{p}.}
  \label{fig:nrb-merge}
\end{figure}

\noindent Algorithm called on \p{q} and \p{p}:\\
Input: \patch\ \p{a} and existing \nrb\ \patch\ \p{p}.\\
Returns: whether \indirdepends{a}{p} exists. \(\forall\! \p{b}\!: \indirdepends{a}{b}\) and \notindirdepends{b}{p}, creates \indirdepends{p}{b}.

\begin{itemize}
\item If \p{a} is external, return ``no path to \p{p}.''
\item If \p{a} equals \p{p}, return ``path to \p{p}.''
\item Call self on \p{a} and \p{p}.
\item If \p{a} has no path to \p{p}, return ``no path to \p{p}.''
\item For each \p{a} \before\ \p{b}:
  \begin{itemize}
  \item If \p{b} has no path to \p{p}:
    \begin{itemize}
    \item Move \p{b} from a \before\ of \p{a} to a \before\ of \p{p}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\paragraph{\Nrb-\Rb\ \Patch\ Merging}
\label{sec:patches:merge:nrb:hard-soft}

When creating the first \nrb\ \patch\ on a block, \emph{\nrb-\rb\
  \patch\ merging} merges all existing (\rb) \patches\ into the new
\nrb\ \patch.
%
Such an arrangement can arise through a combination of \patch\ creates
and block writes; 
%
for example, the block may first obtain an initial (\nrb{}) \patch,
%
then gain external \afters\ on its \patch,
%
accumulate additional (\rb{}) \patches,
%
write the subset of its \patches\ with external \afters\ (leaving some
\rb\ \patches\ on the block),
%
and then gain a \nrb\ \patch.
%
In addition to reducing the number of data \patches, \nrb-\rb\
\patch\ merging removes the second implicit \nrb\ \patch\
dependency, that \rb\ \patches\ not explicitly dependent on the
block's \nrb\ \patch\ implicitly depend on it.
%
As in \nrb-\nrb\ \patch\ merging, \Kudos\ merges such \patches\ to
avoid the complications of their implicit dependencies.

\Nrb-\rb\ \patch\ merging's implementation first merges all \rb\ \patches\
into a \nrb\ \patch\ and then \nrb-\nrb\ \patch\ merges the new \nrb\
\patch\ into the now-existing \nrb\ \patch.
%
Our algorithm to transform the dependencies for \nrb-\rb\ \patch\
merges (Figure~\ref{algo:merge:hard-soft}) for block $b$
%
chooses a \patch\ \p{p} such that
\(\notexists \inset{q}{\PMem[b]}\!: \indirdepends{p}{q}\)
%
and updates its transitive \befores\ to ensure
\(\PDepset{\PSoft[b]} \subseteq \PDepset{p}\).
%
Because any \(\inset{q}{\PMem[b] - p}\) may have \afters, to
preserve dependencies we convert such a \p{q} into \anoop\ \patch\
and ensure \depends{q}{p}.

\noindent Algorithm:
\begin{itemize}
\item Choose a \(\inset{p}{\PMem[b]}\!:\
\notexists\! \inset{q}{\PMem[b]}\!:\ \indirdepends{p}{q}\).
\item For each \inset{q}{\PMem[b] - p}:
  \begin{itemize}
  \item Call the \nrb-\nrb\ \before\ move algorithm on \p{q} and \p{p}.
  \item Convert \p{q} into \anoop\ \patch.
  \end{itemize}
\item Convert \p{p} into a \nrb\ \patch\ (free it's previous data copy).
\end{itemize}

\todo{Note that \nrb-\rb\ merging is rare? Note why it is helpful even though
it is rare?}
\todo{Explain why this preserves dependency semantics? Show possible
dependencies? For the paper, free \patches\ instead of convert them
into \noop{}s? (Must modify \nrb-\nrb\ algo usage.)}

\end{comment}


\subsection{Overlap Merging}
\label{sec:patches:merge:overlap}

The final type of merging merges \rb\ \patches\ with other \patches,
\nrb\ or \rb, when they overlap.
%
Bitmap blocks and inodes accumulate many nearby and overlapping \patches\
as data is appended to or truncated from a file.
%
Figure~\ref{fig:opt} shows how even data blocks can collect overlapping
dependencies: actual data writes $d'_j$ overlap, and therefore depend on,
block initialization writes $d_j$, but cannot be made \nrb\ since when they
are created another block (the inode) already depends on the data block.
%
Luckily, simple reasoning can identify many mergeable pairs,
further reducing the number of \patches\ and the amount of undo data
required.


Two overlapping \patches\ $p_1$ and $p_2$, with $p_1 \PDepend p_2$, may be
merged iff it would always be possible to write them at the same time.
%
Here we may reuse the reasoning developed for \nrb\ \patches\ above: it is
always possible to write these \patches\ simultaneously if, assuming that
$p_2$ were \nrb, $p_1$ could also be made \nrb---that is, if $p_1$ will
never be the head of a block-level cycle terminating at $p_2$.
%
The same properties that simplified the creation of \nrb\ \patches\ also help
us check this property: that is, if no block-level cycle $p_1 \PDepend x
\PDepend p_2$ exists when $p_1$ is created, then no such block-level cycle
will ever exist.



As with \nrb\ \patch\ creation, the \Kudos\ implementation checks a simpler
property that requires less graph traversal.
%
It checks that every path starting at $p_1$ fits at least one of the
following cases:

\begin{xcompactitemize}
\item $p_1 \PDDepend q$, where $q \not\in \PMem$.
\item $p_1 \PDDepend p_2$.
\item $p_1 \PDDepend h$, where $h$ is the \nrb\ \patch\ on $\PBlock{p_1}$.
\item $p_1 \PDDepend q$, where $q$ depends on no other \patch.
\item $p_1 \PDDepend q \PDDepend r$, where $r$ depends on no other \patch,
  $q$ depends on nothing but $r$, and $\PBlock{r} \neq \PBlock{p_1}$.
\end{xcompactitemize}

\noindent
%
If all paths fit, then there are no block-level cycles from $p_1$
to $p_2$, $p_1$ and $p_2$ can have the same lifetime, and $p_1$ can be
merged into $p_2$ where they overlap.
%
(This may require growing $p_2$ to cover $p_1$'s data range.)
%
We initially began with a simpler check, namely that $p_1$ \emph{only}
depended on $p_2$, but extending the check to length-2 non-branching paths
allowed much more merging (further extensions did not).
%
It also simplifies the implementation somewhat to limit overlap merging to
the case when neither $p_1$ nor $p_2$ overlaps with any other \patch.



In our running example, overlap merging is able to combine all remaining
\rb\ \patches\ with their \nrb\ counterparts, reducing the number of \patches\
to the minimum of 8 and the amount of undo data to the minimum of 0.
%
In our experiments, we observe that \nrb\ \patches\ and our \patch\ merging
optimizations reduce the amount of memory allocated for undo data in
soft updates orderings by up to 99.73\%.
\todo{Give a figure for journaling also!}


\begin{comment}
%
If the only dependency between $p_1$ and $p_2$ is direct---that is, no path
$p_1 \PDepend x \PDepend p_2$ exists for any $x \not\in \{p_1,
p_2\}$---then it will always be possible to write $p_1$ and $p_2$ at the
same time.
%
Specifically, it is possible to write $p_1$ 


Many of these and similar \patches\ are mergeable and have
dependencies that allow simple (and fast) reasoning to identify many
of the mergeable pairs: two \patches\ on block $b$ that overlap no other \patches\ in \PMem[b]
and which have no dependency path from the new to the existing \patch\
will not induce a block-level cycle and so are writable together.
We know that \textit{later} changes will not cause them to induce a block-level cycle due to
invariant~\ref{cdinvar:add-before} and by not merging if the new \patch\
has a before and the before is marked as allowed to violate
invariant~\ref{cdinvar:add-before}.
%
While path existence testing is expensive, a conservative path test
of only a depth of two identifies most mergeable \patches. If the new
\patch\ has an explicit \before\ that is not the existing \patch\ and
this \before\ has a \before, then there may be a path to the existing
\patch.
%
To merge two such overlapping \patches, add the new \patch's explicit
before to the existing \patch\ (if any and if not the existing \patch).


%%

At the end of \patch\ optimizations, say something along the lines:
%
The dynamic optimizations facilitated through \nrb\
\patches\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we talk about why we allow NRBs and merging to be
  disabled? (Debugging simplicity and depend add to \noop\ \patches\
  with \afters\ bug catching.)}
\end{comment}
