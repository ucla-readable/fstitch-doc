% -*- mode: latex; tex-main-file: "paper.tex" -*-

\subsection{Hard \ChDesc\ Merging}
\label{sec:patch:merge}

File operations such as block allocations, inode updates, and directory updates
create many distinct \chdescs. Keeping track of these
\chdescs\ and their dependencies requires significant amounts of memory and
CPU time.
%
\Kudos\ therefore \emph{merges} patches when possible, drastically reducing
the \chdesc\ counts and memory usage, by conservatively identifying when a
new \patch\ could always be written at the same time as an existing \patch.
%
Rather than creating a new \chdesc\ in this case, \Kudos\ updates the data
and dependencies so as to merge the new \patch\ into the existing one.


The first type of merging is trivial to explain:
%
since all of a block's hard patches must be written at the same time, there
is no need to maintain more than one hard patch per block.
%
All other hard patches can safely be merged into the first,
%
and in fact \Kudos\ ensures that each block contains at most one hard
patch.


Assume some module attempts to create a patch $p$ on a block that already
has a hard patch $h$, and \Kudos\ determines that $p$ may be hard.
%
Then the implementation merges $p$ into $h$ at creation time by applying
$p$'s data to the block and setting $\PDDepset{h} \gets \PDDepset{h} \cup
\PDDepset{p}$.
%
Although this changes $h$'s direct dependency set, that change cannot
introduce any new block-level cycles or $p$ would not have been hard in the
first place.
%
The existing hard patch $h$ is returned to the caller.


Unfortunately, the merge can create \emph{intra}-block cycles.
%
If some empty patch $x$ exists with $p \PDepend x \PDepend h$, then after
the merge $h \PDepend x \PDepend h$.
%
The merge algorithm uses a graph traversal to prune these cyclic
dependencies as it merges $p$'s dependencies into $h$.


Hard patch merging is able to eliminate 8 of the patches in our running
example, as shown in Figure~\ref{f:opt}c.


\paragraph{Soft-to-Hard Conversion}

A similar optimization occurs when a new hard patch is created on a block
that has existing \emph{soft} patches in memory.
%
This can happen once hard patches are written to disk.
%
For example, Figure~\ref{f:soft2hard}a shows a block with both hard and
soft patches: $p_1$ must be soft since it initiates a block-level cycle
$p_1 \PDepend q_h \PDepend p_h$, and similarly for $p_2$ and $p_3$.
%
To write these blocks, the buffer cache must roll back $p_1$, $p_2$, and
$p_3$ and write $p_h$ on its own.
%
Once $p_h$ reaches disk, the patches in memory reach the state in
Figure~\ref{f:soft2hard}b.
%
Now that $p_h$ has moved to \PDisk, it is irrelevant for cycle detection,
and in fact there are no block-level dependency cycles in the diagram: it
would be safe to transform $p_1$, $p_2$, and $p_3$ into hard patches.
%
However, \Kudos\ delays this and performs the conversion only later when
adding a new hard patch to the $p$ block. 


Consider a new hard patch $h$ that is added to a block that contains some
soft patch $p$.
%
Since $h$ overlaps $p$, \Kudos\ adds a direct dependency $h \PDDepend p$.
%
Since $h$ could be hard, we know there are no block-level dependency cycles
$h \PDepend q \PDepend p'$.
%
But as a result, we know that there are no block-level dependency cycles
with the existing \emph{soft} patch as head, since such a cycle would imply
an $h$-headed cycle $h \PDDepend p \PDepend q \PDepend p'$.
%
Thus, $p$ can be transformed into a hard patch and then merged into $h$.
%
Figure~\ref{f:soft2hard}c shows the result for our example.


Like hard patch merging, soft-to-hard conversion requires that the
implementation filter dependencies to avoid introducing cycles.
%
Unlike hard patch merging, soft-to-hard conversion is complicated by the
fact that other patches may already depend on the soft patches that are
being merged.
%
Rather than shift these dependencies, \Kudos\ simply changes the existing
soft patches into empty patches in place.


\begin{figure}
\centering
\begin{small}
\begin{tabular}{@{}p{.32\hsize}@{~~}p{.32\hsize}@{~~}p{.32\hsize}@{}}
\includegraphics[width=\hsize]{fig/softhard_1} &
\includegraphics[width=\hsize]{fig/softhard_2} &
\includegraphics[width=\hsize]{fig/softhard_3} \\
\centering \textbf{a)} Initial state &
\centering \textbf{b)} After $p_h$ reaches~disk &
\centering \textbf{c)} Soft-to-hard conversion
\end{tabular}
\end{small}
\caption{Soft-to-hard conversion.}
\label{f:soft2hard}
\end{figure}



\begin{comment}

\Kudos\ includes three distinct \chdesc\ merge algorithms.
%
All three use Invariant~\ref{cdinvar:add-before} to reason about future
graph changes and use fast, conservative checks during \chdesc\ creation;
they differ in their applicable conditions.


\subsubsection{\Nrb\ \ChDesc\ Merging}
\label{sec:chdescs:merge:nrb}

Recall from section~\ref{sec:chdescs:nrb} that a write of any \chdescs\ on
block $b$ must include all \nrb\ \chdescs\ on $b$.
%
This additional requirement is in fact an exquisite optimization
opportunity; it implies that all \nrb\ \chdescs\ on a given block can
be merged.
%
Further, merging can remove the need for the \nrb\ \chdesc\ implicit
dependency rules by ensuring that
%
there is at most one \nrb\ \chdesc\ per block (\nrb-\nrb\ merging)
%
and that all \rb\ \chdescs\ on a given block depend on the \nrb\ \chdesc\
(\nrb-\rb\ merging).
%
We describe these two \chdesc\ merging algorithms and how they
preserve dependency semantics in this section.

\paragraph{\Nrb-\Nrb\ \ChDesc\ Merging}
\label{sec:chdescs:merge:nrb:hard-hard}

\emph{\Nrb-\nrb\ \chdesc\ merging} merges a new \nrb\ \chdesc\ \p{q}
into an existing \nrb\ \chdesc\ \p{p} instead of creating \p{q}.
%
Any two \nrb\ \chdescs\ on the same block may be (and are) merged.
%
Merging all \nrb\ \chdescs\ ensures:
%
\cdinvar{one-nrb}{\(\forall\! b\!: |\PHard[b]| \leq 1\)}
%
\noindent
%
Invariant~\ref{cdinvar:one-nrb} simplifies \nrb\ \chdesc\ handling by
%
removing the implicit dependencies that ensure all \nrb\ \chdescs\
are written together
%
and by removing the need to scan for an existing \nrb\ \chdesc\ when
\nrb-\nrb\ \chdesc\ merging.
%
% Although merging two \chdescs\ will not induce block-level dependency
% cycles, without sufficient care merging could induce \chdesc-level
% dependency cycles.  A trivial example is merging \p{q} into \p{p} when
% \p{q} has an explicit dependency on \p{p}; the combined \p{(p+q)}
% should not and need not depend on itself.
%
To preserve dependency semantics, the merged \p{(p+q)} must depend on
the union of \p{p} and \p{q}'s transitive \befores. Additionally, while the
\chdescs\ can be merged without forming a \chdesc-level dependency cycle,
the merge must ensure that it does not introduce a needless cycle, e.g.
through \anoop\ \chdesc\ \p{e} in \depends{q}{\depends{e}{p}}
\todo{Is cycle avoidance worth mentioning? Is this a good way to mention it?}.

From Invariant~\ref{cdinvar:add-before} and the \nrb\ \chdesc\
creation condition (no external \afters), the only possible
dependencies involving \p{p} and \p{q} are those shown in
Figure~\ref{fig:nrb-merge}\todo{Should we give these deductions or a
  flavor?}.
%
Notice, for example, that any \p{r} such that
\indirdepends{q}{\indirdepends{r}{p}} is \anoop\ \chdesc\todo{This is
  a strong statement. Expand on its implications?}.
%
Our algorithm to transform dependencies for \nrb-\nrb\ \chdesc\ merges
(Figure~\ref{algo:merge:hard-hard}) follows from these possible
dependencies.
%
It updates \p{p}'s transitive \befores\ to ensure
\(\PDepset{q}\todo{Incorrect! Only the non-\noop{}s.} \subseteq
\PDepset{p}\)\todo{Note that Invariant~\ref{cdinvar:add-before}
  ensures that \noop\ \chdescs\ reachable from \p{q} will not gain
  data \chdesc\ \befores?}\todo{Note that it only needs to move dependencies?}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{nrb_merge}
  \caption{Possible dependencies when merging \nrb\ \chdesc\ \p{q}
    into existing \nrb\ \chdesc\ \p{p}.}
  \label{fig:nrb-merge}
\end{figure}

\noindent Algorithm called on \p{q} and \p{p}:\\
Input: \chdesc\ \p{a} and existing \nrb\ \chdesc\ \p{p}.\\
Returns: whether \indirdepends{a}{p} exists. \(\forall\! \p{b}\!: \indirdepends{a}{b}\) and \notindirdepends{b}{p}, creates \indirdepends{p}{b}.

\begin{itemize}
\item If \p{a} is external, return ``no path to \p{p}.''
\item If \p{a} equals \p{p}, return ``path to \p{p}.''
\item Call self on \p{a} and \p{p}.
\item If \p{a} has no path to \p{p}, return ``no path to \p{p}.''
\item For each \p{a} \before\ \p{b}:
  \begin{itemize}
  \item If \p{b} has no path to \p{p}:
    \begin{itemize}
    \item Move \p{b} from a \before\ of \p{a} to a \before\ of \p{p}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\paragraph{\Nrb-\Rb\ \ChDesc\ Merging}
\label{sec:chdescs:merge:nrb:hard-soft}

When creating the first \nrb\ \chdesc\ on a block, \emph{\nrb-\rb\
  \chdesc\ merging} merges all existing (\rb) \chdescs\ into the new
\nrb\ \chdesc.
%
Such an arrangement can arise through a combination of \chdesc\ creates
and block writes; 
%
for example, the block may first obtain an initial (\nrb{}) \chdesc,
%
then gain external \afters\ on its \chdesc,
%
accumulate additional (\rb{}) \chdescs,
%
write the subset of its \chdescs\ with external \afters\ (leaving some
\rb\ \chdescs\ on the block),
%
and then gain a \nrb\ \chdesc.
%
In addition to reducing the number of data \chdescs, \nrb-\rb\
\chdesc\ merging removes the second implicit \nrb\ \chdesc\
dependency, that \rb\ \chdescs\ not explicitly dependent on the
block's \nrb\ \chdesc\ implicitly depend on it.
%
As in \nrb-\nrb\ \chdesc\ merging, \Kudos\ merges such \chdescs\ to
avoid the complications of their implicit dependencies.

\Nrb-\rb\ \chdesc\ merging's implementation first merges all \rb\ \chdescs\
into a \nrb\ \chdesc\ and then \nrb-\nrb\ \chdesc\ merges the new \nrb\
\chdesc\ into the now-existing \nrb\ \chdesc.
%
Our algorithm to transform the dependencies for \nrb-\rb\ \chdesc\
merges (Figure~\ref{algo:merge:hard-soft}) for block $b$
%
chooses a \chdesc\ \p{p} such that
\(\notexists \inset{q}{\PMem[b]}\!: \indirdepends{p}{q}\)
%
and updates its transitive \befores\ to ensure
\(\PDepset{\PSoft[b]} \subseteq \PDepset{p}\).
%
Because any \(\inset{q}{\PMem[b] - p}\) may have \afters, to
preserve dependencies we convert such a \p{q} into \anoop\ \chdesc\
and ensure \depends{q}{p}.

\noindent Algorithm:
\begin{itemize}
\item Choose a \(\inset{p}{\PMem[b]}\!:\
\notexists\! \inset{q}{\PMem[b]}\!:\ \indirdepends{p}{q}\).
\item For each \inset{q}{\PMem[b] - p}:
  \begin{itemize}
  \item Call the \nrb-\nrb\ \before\ move algorithm on \p{q} and \p{p}.
  \item Convert \p{q} into \anoop\ \chdesc.
  \end{itemize}
\item Convert \p{p} into a \nrb\ \chdesc\ (free it's previous data copy).
\end{itemize}

\todo{Note that \nrb-\rb\ merging is rare? Note why it is helpful even though
it is rare?}
\todo{Explain why this preserves dependency semantics? Show possible
dependencies? For the paper, free \chdescs\ instead of convert them
into \noop{}s? (Must modify \nrb-\nrb\ algo usage.)}

\end{comment}


\subsection{Overlap Merging}
\label{sec:chdescs:merge:overlap}
\todo{Note as useful when new may need to be rolled back.}
Bitmap blocks and inode size fields accumulate many nearby and
overlapping mergeable \chdescs\ as data is appended to or truncated
from a file.
%
Many of these and similar \chdescs\ are mergeable and have
dependencies that allow simple (and fast) reasoning to identify many
of the mergeable pairs: two \chdescs\ on block $b$ that overlap no other \chdescs\ in \PMem[b]
and which have no dependency path from the new to the existing \chdesc\
will not induce a block-level cycle and so are writable together.
We know that \textit{later} changes will not cause them to induce a block-level cycle due to
invariant~\ref{cdinvar:add-before} and by not merging if the new \chdesc\
has a before and the before is marked as allowed to violate
invariant~\ref{cdinvar:add-before}.
%
While path existence testing is expensive, a conservative path test
of only a depth of two identifies most mergeable \chdescs. If the new
\chdesc\ has an explicit \before\ that is not the existing \chdesc\ and
this \before\ has a \before, then there may be a path to the existing
\chdesc.
%
To merge two such overlapping \chdescs, add the new \chdesc's explicit
before to the existing \chdesc\ (if any and if not the existing \chdesc).


%%

At the end of \chdesc\ optimizations, say something along the lines:
%
The dynamic optimizations facilitated through \nrb\
\chdescs\ implement the efficiency in systems using soft updates or
journaling\todo{Actually do this for journaling} while expressing
changes modularly through structural descriptions rather than through
internal and semantic file system descriptions.

\todo{Should we talk about why we allow NRBs and merging to be
  disabled? (Debugging simplicity and depend add to \noop\ \chdescs\
  with \afters\ bug catching.)}
