\section{\Opgroups}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{patch\-group\_create()}}
\newcommand{\opgroupSync}{\texttt{patch\-group\_sync()}}
\newcommand{\opgroupAddDepend}{\texttt{patch\-group\_add\_depend()}}
\newcommand{\opgroupEngage}{\texttt{patch\-group\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{patch\-group\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{patch\-group\_release()}}
\newcommand{\opgroupAbandon}{\texttt{patch\-group\_abandon()}}

\Kudos\ \modules\ use \chdescs\ to express internal file system
consistency protocols, such as soft updates and journaling
(\S\ref{sec:using}).
%
Applications also implement consistency protocols; for example, CVS
clients synchronize local files with the server, and IMAP servers
must commit mailbox changes to disk. In this section we discuss the
extension of \chdescs\ from \Kudos\ to user applications to support
custom application-level consistency protocols. We discuss the
\opgroup\ interface and implementation and a case study of \opgroups\
in the UW IMAP server.

\begin{comment}
Old:
Many file systems strive to maintain internal file system consistency
across system and hardware failures; \chdescs\ can express such write
ordering requirements. But file systems are by no means the sole
players to benefit from robustness to system and hardware failures.
User applications often manipulate persistent data in manners subject
to data corruption or loss. Applications often protect user data using
interfaces like Unix's \texttt{sync()} and \texttt{fsync()} system
calls in combination with write ordering. \Opgroups\ provide finer
grained and less restrictive write ordering control so that
applications can express \textit{minimal} ordering requirements to
implement custom consistency semantics and make custom performance
requirement tradeoffs. In this section we present the \opgroup\
interface and implementation and a case study of \opgroups\ in the
UW IMAP server.
\end{comment}

\subsection{Interface}
\label{sec:opgroup:interface}

Our current interface allows applications to
specify orderings among file system operations.  \Anopgroup\
corresponds to the group of \chdescs\ generated by a file system
operation; applications can specify ordering requirements among these
groups. Figure~\ref{fig:opgroup-interface} shows the \opgroup\
interface functions.

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.22in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int \opgroup_id_t;
\opgroup_id_t \textbf{\opgroup_create}(int type);
int \textbf{\opgroup_sync}(\opgroup_id_t g);
int \textbf{\opgroup_add_depend}(
    \opgroup_id_t \after,
    \opgroup_id_t \before);
int \textbf{\opgroup_engage}(\opgroup_id_t g);
int \textbf{\opgroup_disengage}(\opgroup_id_t g);
int \textbf{\opgroup_release}(\opgroup_id_t g);
int \textbf{\opgroup_abandon}(\opgroup_id_t g);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} \Opgroup\ API.}
\end{figure}

%% New \opgroups\ are created using \opgroupCreate. 
%% Ordering constraints
%% are the most fundamental type of \opgroups, but we plan to later
%% support other types; type specification is the purpose of the
%% \texttt{type} argument.
%
\opgroupAddDepend\ makes one \opgroup\ depend on another.
%
Until \opgroupRelease\ is called, \anopgroup{}'s \chdescs\ will not go
to disk.
%
\opgroupSync\ synchronizes \anopgroup\ by committing all its changes,
preserving its dependencies.
%
Each file system operation's \chdescs\ are added to the
\textit{engaged set} of \opgroups. \opgroupEngage\ and
\opgroupDisengage\ add and remove \anopgroup\ from this set.
%
Lastly, \opgroupAbandon\ invalidates \anopgroup\ handle for the
calling process.

The \opgroup\ interface uses a set of engaged \opgroups\ for each
process rather than \anopgroup\ parameter in file system calls to match
common \opgroup\ usage (an application operation composed of multiple
file system operations), and to avoid changing existing file system
calls. Each process is associated with a set of \opgroups\ to support
modular composition.

To allow \opgroup\ interactions among processes, child processes copy
their parent's engaged set and \opgroup\ ID table.
%
This behavior also allows a process to run a helper process whose file
system changes will all be contained within \anopgroup. For example,
suppose a user wants to run in their shell:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+sort < src > sorted && rm src+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}
%
However, the user wants to ensure that \verb+src+ is not removed
before \verb+sorted+ is committed to disk, so that a crash part way
through does not lose both files.
%
Using \opgroups, the user could make \verb+rm+'s updates depend on
\verb+sort+'s.
%
A program \texttt{depend}, that creates \anopgroup\ for each argument,
evaluates the argument as a shell command, and makes the \opgroup\
depend on the previous argument, can do just this:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < src > sorted" "rm src"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

With an application's ability to create dependencies among \opgroups,
cyclic dependencies could arise. The \opgroup\ interface ensures that
cycles (which are not allowed and therefore abort the current operation
before being formed) can only arise during \opgroup\ operations, ensuring
file system operations cannot fail due to cycles. The \opgroup\ interface
limits cycle creation opportunity through the allowed \opgroup\ state
transitions, shown in Figures~\ref{fig:opgroup-transitions-states}
and~\ref{fig:opgroup-transitions-intuition}, which ensure that \befores\
cannot be added when the \opgroup\ contains any \chdescs\ or has any
\afters.

\begin{figure}[htb]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{opgroup_transitions}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:opgroup-transitions-states} \Opgroup\ state
  transitions. Edges represent \opgroup\ operations: \textbf{A}dd
  \textbf{L}eader, \textbf{A}dd \textbf{F}ollower, \textbf{R}elease,
  \textbf{E}ngage, and \textbf{D}isengage. Not drawn: every state
  connects to the end node via abandon.}
\end{figure}

\begin{figure}[htb]
\centering{
\begin{small}
\begin{tabular}{l l}
State requirement & State change\\ \hline
none & released\\
none & abandoned (end)\\
no \afters\ and released & engaged\\
engaged & disengaged\\
no \afters\ and not released & has \befores \\
disengaged & has \afters\
\end{tabular}
\end{small}
}
\caption{\label{fig:opgroup-transitions-intuition} \Opgroup\ state
  transitions --- alternative view of
  Figure~\ref{fig:opgroup-transitions-states}. A fresh \opgroup\ is
  not released, is not abandoned, is disengaged, and has no \befores\
  or \afters.}
\end{figure}

% FIXME: Mention simplicity using opgroups vs fsync?
% FIXME: Note that destruction is not an issue (unless a transaction) and that
% apply/rollback and dependency removal aren't seen as helpful since apps are
% not doing transformations?

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other \befores\ be satisfied (for instance, by
being written to disk). An \LFS\ \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the \after's tail to the \before's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{figure}[htb]
\centering{
\includegraphics[width=0.5\hsize]{fig/figures_6}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs. H and T are the head
and tail of the \opgroup; HK and TK are the head keep and tail keep. The three
\chdescs\ labeled 1 occurred during one file system operation, and the \chdesc\
labeled 2 occurred during a second operation that depended on the first.}
\end{figure}

\subsection{UW IMAP Case Study}
\label{sec:opgroup:uwimap}

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's IMAP mail server to take
advantage of \opgroups, to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, mailbox
selected, and logged out. States define the set of valid commands a
client may issue. For example, clients in the selected state may
retrieve messages from the selected mailbox. In our case study we are
interested in mailbox manipulation; the authenticated and selected
states allow mailbox manipulation. The most relevant IMAP commands
synchronize changes to the server's disk (CHECK), copy a message from
the selected mailbox to another mailbox (COPY), and delete messages
marked for deletion (EXPUNGE).

UW IMAP~\cite{uwimap}, authored by Mark Crispin of the IMAP RFC,
includes an IMAP mail server imapd and mail client library c-client.
We have updated imapd and the mbox mail storage driver to use
\opgroups\ to ensure all disk changes occur in a safe ordering, while
performing a minimal number of disk writes.
%
The original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\opgroups, each command's file system updates are executed under a
distinct \opgroup\ and, through the \opgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) can not lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \opgroupSync to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox; the client's CHECK request will ensure
changes are committed to disk; the \opgroup\ dependencies will ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify two aspects:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code be concerned with
ensuring its changes are committed before any later, dependent
command's changes. Without \opgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \opgroup{}-enabled UW IMAP mail server is
evaluated in \S\ref{sec:evaluation:uwimap}.

\subsection{Subversion Case Study}
\label{sec:opgroup:svn}

TODO: decide on having a case study subsection that introduces UW IMAP
and Subversion or contrast the two studies here or elsewhere.
%
UW IMAP case study (faster, same safety, server) vs
Subversion case study (about same speed, additional safety on non-ext3
ordered, client).

Subversion~\cite{svn} is a version control system designed to be an
improved, more modern replacement for CVS~\cite{cvs}. In this case
study we take interest in Subversion's working copy library, used by
the Subversion client to manipulate a local checkout, and its file
system usage.
%
The working copy library is designed to avoid corruption or loss
should the library's host process exit at any point during a working
copy operation. The working copy library achieves using
application-level write ahead journaling.
%
First, new versions of any updates files are created in a temporary
location. Second, the log file is created in a temporary location;
each log file entry manipulates the new and/or existing files and is
either idempotent or atomic. Third, the journal is moved into its
official location. Prior to this rename no non-temporary files have
been modified and following this rename all actions can be replayed
until the journal's entries are successfully played in full. Fourth,
the journal entries are executed.  And fifth, the journal file is
removed.

Although this part of the working copy library's design protects
against premature application exit, it does not protect against an
operating system or hardware crash. For example, the journal file
rename may go to disk before all the data for a temporary file used in
a journal entry.
%
The working copy library could sync files and directories as necessary
to ensure safe disk write orderings, as UW IMAP and the Subversion
repository library do, but the Subversion developers deemed this
approach too slow to be worthwhile for client use\todo{Cite public
  communication?}.
%
Instead, it achieves the same ordering safety against system crashes
by,
%
one, taking advantage of the \texttt{rename()} system call's on an
Linux ext3 file system in ordered data mode and,
%
two, by taking advantage the linear metadata update ordering
guaranteed by metadata journaling.
%
In ordered journal mode, to write a transaction to disk ext3 first
writes block deallocations\todo{Is this exactly correct?}, then writes
file data in place, and lastly writes other metadata to the journal.
This implies that data writes to a file that is later renamed will be
committed if the rename is committed, allowing atomic file creation by
writing data to a temporary file and then renaming to the file's
desired name.
%
The working copy library is thus able to atomically create files like the
journal and know that the journal file will be created only if its
associated temporary files exist with their data in full.
%
In addition to being an obtuse approach, file renaming does not
ensure such ordering on many other systems, for example NTFS or BSD UFS.
And systems such as BSD UFS do not ensure the strong linear metadata
ordering supported by metadata journaling.
%
\todo{The last two thirds of this paragraph's phrasing is important and
  should be drastically improved. Perhaps explain the concepts elsewhere?}

We updated Subversion to use \opgroups\ to express Subversion's file
consistency protocol\todo{Note that we had to find actual dependencies
  since the working copy assumed linear order?}.
Figure~\ref{fig:svn-order} shows the \opgroups\ created to update a
file with conflicts.
%
Subversion first updates its checkout metadata to note the update
operation, then creates the new files to be installed (e.g. updated
pristine copy, the user's copy with conflicts, and a copy at each of
the involved versions), creates the journal, plays the journal to
install the new files, updates the checkout metadata, and finally
removes the journal to complete the transaction.
%
The updated version of Subversion continues to atomically create live
files (e.g. entries and logs, but a rename depends the temporary
file's data\todo{Note that renames for files used by logs are no
  longer necessary since a log rename depends on its files? We keep
  the renames since not changing this is easy.}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{svn_opgroups}
  \caption{\Opgroups\ to update a file in a Subversion working copy.}
  \label{fig:svn-order}
\end{figure}
