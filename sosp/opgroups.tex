\section{\Opgroups}
\label{sec:opgroup}

\newcommand{\opgroupCreate}{\texttt{pg\_create()}}
\newcommand{\opgroupAddDepend}{\texttt{pg\_depend()}}
\newcommand{\opgroupEngage}{\texttt{pg\_engage()}}
\newcommand{\opgroupDisengage}{\texttt{pg\_disengage()}}
\newcommand{\opgroupRelease}{\texttt{pg\_release()}}
\newcommand{\opgroupSync}{\texttt{pg\_sync()}}
\newcommand{\opgroupAbandon}{\texttt{pg\_close()}}

\Kudos\ \modules\ use \chdescs\ to express internal file system
consistency protocols, such as soft updates and journaling
(\S\ref{sec:using}).
%
Applications also implement consistency protocols; for example, CVS
clients synchronize local files with the server, and IMAP servers
must commit mailbox changes to disk. In this section we discuss the
extension of \chdescs\ from \Kudos\ to user applications to support
custom application-level consistency protocols. We discuss the
\opgroup\ interface and implementation and case studies of \opgroups\
in gzip, the Subversion client, and the UW IMAP server.

\subsection{Interface}
\label{sec:opgroup:interface}

The \opgroup\ interface allows applications to specify orderings among
file system operations.
%
\Anopgroup\ corresponds to the group of \chdescs\ generated by a set
of file system operations; applications can specify ordering
requirements among \opgroups.
%
Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface
functions.

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.22in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int pg_t;
pg_t \textbf{pg_create}(void);
int  \textbf{pg_depend}(pg_t \after, pg_t \before)
int  \textbf{pg_engage}(pg_t pg);
int  \textbf{pg_disengage}(pg_t pg);
int  \textbf{pg_sync}(pg_t pg);
int  \textbf{pg_close}(pg_t pg);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} \Opgroup\ API.}
\end{figure}

The \chdescs\ created during a file system operation are associated
with each of the process's \emph{engaged} \opgroups\ (\opgroupEngage\
and \opgroupDisengage\ add and remove \anopgroup\ from the process's
engaged set).
%
The \opgroup\ api uses an engaged set, instead of an additional system
call paramater with each file system system call, to match typical
application granularity where each operation involves multiple file
system operations and to simplify modular composition.
%
Making \opgroup\ $Q$ depend on \opgroup\ $P$ (\opgroupAddDepend)
ensures \(P \subseteq \PDepset{Q}\).
%
\opgroupSync\ forces an immediate write of \anopgroup\ to disk.

The \opgroup\ interface prevents the creation of non-evictable
\chdescs\ and \chdesc\ cycles by limiting the order of \opgroup\
operations, shown in Figure~\ref{fig:opgroup-transitions-states}.

\begin{figure}[htb]
\vspace{-0.5\baselineskip}
\centering{
\includegraphics[width=\hsize]{opgroup_transitions}
}
\vspace{-0.5\baselineskip}
\caption{\label{fig:opgroup-transitions-states} \Opgroup\ state
  transitions. Edges represent \opgroup\ operations: \textbf{A}dd
  \textbf{L}eader, \textbf{A}dd \textbf{F}ollower,
  \textbf{E}ngage, \textbf{D}isengage, and \textbf{C}lose.
  Not drawn: every state connects to the finish node via close.}
\end{figure}\todo{Add sync to Figure~\ref{fig:opgroup-transitions-states}?}

A process's \opgroups\ and its engaged set are copied across \texttt{fork()},
facilitating \opgroup\ interactions among processes.
%
For example, consider processing and then removing some input:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+sort < in > out && rm in+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}
%
Using \opgroups, the user can ensure that \texttt{in} is not removed
before \texttt{out} is committed to disk, so that a crash part way
through does not lose both files.
%
Given a program \texttt{depend} that, for each argument,
%
creates \anopgroup\ that depends on the previous argument's \opgroup\
%
and runs the argument within its \opgroup,
%
the user can instead run:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+\todo{Is this example worth its space?}
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using opgroups vs fsync?
% FIXME: Note that destruction is not an issue (unless a transaction) and that
% apply/rollback and dependency removal aren't seen as helpful since apps are
% not doing transformations?

\subsection{Implementation}
\label{sec:opgroup:implementation}

% This section would really benefit from knowing what figures we will have.

\Opgroups\ are implemented using an arrangement of \noop\ \chdescs\ which allows
the \opgroup\ to be connected to other \opgroups\ using ordinary \chdesc\
dependencies.  Figure~\ref{fig:opgroup-chdescs} shows this arrangement: a
``head'' \chdesc\ depends upon a ``tail'' \chdesc\ and a ``head keep'' \chdesc,
while the tail \chdesc\ depends on a ``tail keep'' \chdesc. The purpose of the
``keep'' \chdescs\ is to prevent the head and tail \chdescs\ from being
satisfied should all their other \befores\ be satisfied (for instance, by
being written to disk). An \LFS\ \module\ in the \module\ graph is responsible for
connecting all operations performed while \anopgroup\ is \engaged\ to its head
and tail \chdescs, so that an entire \opgroup\ can be made to depend on another
\opgroup\ by adding a dependency from the \after's tail to the \before's
head.

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline -- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\begin{figure}[htb]
\centering{
\includegraphics[width=0.5\hsize]{fig/figures_6}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs. H and T are the head
and tail of the \opgroup; HK and TK are the head keep and tail keep. The three
\chdescs\ labeled 1 occurred during one file system operation, and the \chdesc\
labeled 2 occurred during a second operation that depended on the first.}
\end{figure}

\subsection{Subversion Case Study}
\label{sec:opgroup:svn}

TODO: decide on having a case study subsection that introduces UW IMAP
and Subversion or contrast the two studies here or elsewhere.
%
UW IMAP case study (faster, same safety, server) vs
Subversion case study (about same speed, additional safety on non-ext3
ordered, client).

Subversion~\cite{svn} is a version control system designed to be an
improved, more modern replacement for CVS~\cite{cvs}. In this case
study we take interest in Subversion's working copy library, used by
the Subversion client to manipulate a local checkout, and its file
system usage.
%
The working copy library is designed to avoid corruption or loss
should the library's host process exit at any point during a working
copy operation. The working copy library achieves using
application-level write ahead journaling.
%
First, new versions of any updates files are created in a temporary
location. Second, the log file is created in a temporary location;
each log file entry manipulates the new and/or existing files and is
either idempotent or atomic. Third, the journal is moved into its
official location. Prior to this rename no non-temporary files have
been modified and following this rename all actions can be replayed
until the journal's entries are successfully played in full. Fourth,
the journal entries are executed.  And fifth, the journal file is
removed.

Although this part of the working copy library's design protects
against premature application exit, it does not protect against an
operating system or hardware crash. For example, the journal file
rename may go to disk before all the data for a temporary file used in
a journal entry.
%
The working copy library could sync files and directories as necessary
to ensure safe disk write orderings, as UW IMAP and the Subversion
repository library do, but the Subversion developers deemed this
approach too slow to be worthwhile for client use\todo{Cite public
  communication?}.
%
Instead, it achieves the same ordering safety against system crashes
by,
%
one, taking advantage of the \texttt{rename()} system call's on an
Linux ext3 file system in ordered data mode and,
%
two, by taking advantage the linear metadata update ordering
guaranteed by metadata journaling.
%
In ordered journal mode, to write a transaction to disk ext3 first
writes block deallocations\todo{Is this exactly correct?}, then writes
file data in place, and lastly writes other metadata to the journal.
This implies that data writes to a file that is later renamed will be
committed if the rename is committed, allowing atomic file creation by
writing data to a temporary file and then renaming to the file's
desired name.
%
The working copy library is thus able to atomically create files like the
journal and know that the journal file will be created only if its
associated temporary files exist with their data in full.
%
In addition to being an obtuse approach, file renaming does not
ensure such ordering on many other systems, for example NTFS or BSD UFS.
And systems such as BSD UFS do not ensure the strong linear metadata
ordering supported by metadata journaling.
%
\todo{The last two thirds of this paragraph's phrasing is important and
  should be drastically improved. Perhaps explain the concepts elsewhere?}

We updated Subversion to use \opgroups\ to express Subversion's file
consistency protocol\todo{Note that we had to find actual dependencies
  since the working copy assumed linear order?}.
Figure~\ref{fig:svn-order} shows the \opgroups\ created to update a
file with conflicts.
%
Subversion first updates its checkout metadata to note the update
operation, then creates the new files to be installed (e.g. updated
pristine copy, the user's copy with conflicts, and a copy at each of
the involved versions), creates the journal, plays the journal to
install the new files, updates the checkout metadata, and finally
removes the journal to complete the transaction.
%
The updated version of Subversion continues to atomically create live
files (e.g. entries and logs, but a rename depends the temporary
file's data\todo{Note that renames for files used by logs are no
  longer necessary since a log rename depends on its files? We keep
  the renames since not changing this is easy.}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{svn_opgroups}
  \caption{\Opgroups\ to update a file in a Subversion working copy.}
  \label{fig:svn-order}
\end{figure}

\subsection{UW IMAP Case Study}
\label{sec:opgroup:uwimap}

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's IMAP mail server to take
advantage of \opgroups, to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, mailbox
selected, and logged out. States define the set of valid commands a
client may issue. For example, clients in the selected state may
retrieve messages from the selected mailbox. In our case study we are
interested in mailbox manipulation; the authenticated and selected
states allow mailbox manipulation. The most relevant IMAP commands
synchronize changes to the server's disk (CHECK), copy a message from
the selected mailbox to another mailbox (COPY), and delete messages
marked for deletion (EXPUNGE).

UW IMAP~\cite{uwimap}, authored by Mark Crispin of the IMAP RFC,
includes an IMAP mail server imapd and mail client library c-client.
We have updated imapd and the mbox mail storage driver to use
\opgroups\ to ensure all disk changes occur in a safe ordering, while
performing a minimal number of disk writes.
%
The original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\opgroups, each command's file system updates are executed under a
distinct \opgroup\ and, through the \opgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) can not lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \opgroupSync to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox; the client's CHECK request will ensure
changes are committed to disk; the \opgroup\ dependencies will ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify two aspects:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code be concerned with
ensuring its changes are committed before any later, dependent
command's changes. Without \opgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \opgroup{}-enabled UW IMAP mail server is
evaluated in \S\ref{sec:evaluation:uwimap}.
