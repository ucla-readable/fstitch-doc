\section{\Patchgroups}
\label{sec:patchgroup}

\newcommand{\pgCreate}{\texttt{pg\_create}}
\newcommand{\pgDepend}{\texttt{pg\_depend}}
\newcommand{\pgEngage}{\texttt{pg\_engage}}
\newcommand{\pgDisengage}{\texttt{pg\_disengage}}
\newcommand{\pgRelease}{\texttt{pg\_release}}
\newcommand{\pgSync}{\texttt{pg\_sync}}
\newcommand{\pgClose}{\texttt{pg\_close}}

Robust applications
%% often manipulate valuable data, e.g. a mail server's mail
%% or a version control system's local checkout.
%
ensure their on-disk data remains in a sane state even after a
system crash by requiring their changes be committed in
a specified order.
%
Existing systems can ensure such orders in two ways:
%
applications can tell the file system \emph{how} to implement the
ordering by requiring immediate syncs
(e.g. \texttt{sync}, \texttt{fsync}, or \texttt{sync\_file\_range}),
%
or applications can require particular file system implementation
semantics (e.g. journaling).
%
%
The \patch\ abstraction, in contrast, can let a process specify
\emph{what} ordering is required and leave the storage system to implement
that ordering in the most appropriate way.


This section describes \emph{\patchgroups}, which extend \patches\ to user
space and let applications express dependencies among file system
operations.
%
Compared to forcing block writes in the application, this lets the file
system buffer, combine, and reorder block writes, but is still relatively
independent of the underlying file system.
%
For example, \patchgroups\ even allow an application to specify
dependencies among raw block device writes.

In this section we describe the \patchgroup\ abstraction
%
and apply it to three robust applications.

%%  it usefulness on three and show how it allows gzip, Subversion, and UW IMAP to easily specify
%% their application-level consistency protocols.

\subsection{Interface and Implementation}
\label{sec:patchgroup:interface}

\todo{Mention threads?}
\Patchgroups\ encapsulate sets of file system operations into units among
which dependencies can be applied.
%
%% applications can specify ordering requirements among \patchgroups.
%
The \patchgroup\ interface is as follows:

\begin{scriptsize}
\begin{alltt}
  typedef int pg_t;          pg_t \textbf{pg_create}(void);
  int \textbf{pg_depend}(pg_t after, pg_t before);
  int \textbf{pg_engage}(pg_t pg);    int  \textbf{pg_disengage}(pg_t pg);
  int \textbf{pg_sync}(pg_t pg);      int  \textbf{pg_close}(pg_t pg);
\end{alltt}
\end{scriptsize}

Each process has its own set of \patchgroups.
%
The call \texttt{\pgDepend(q, p)} makes \patchgroup\ \texttt{q} depend on
\patchgroup\ \texttt{p}: all \patches\ associated with \texttt{p} will
be committed prior to those associated with \texttt{q}.
%
The \patches\ associated with a \patchgroup\ are those created while
the \patchgroup\ is engaged.
%
\pgSync\ forces an immediate write of a \patchgroup\ to disk.
%
\pgCreate\ creates a new \patchgroup\ and returns its ID
%
and \pgClose\ disassociates a \patchgroup\ ID from the underlying
\patches\ which implement it.

\begin{figure}[t]
\centering
\includegraphics[width=0.85\hsize]{opgroup_transitions}
\caption{\label{fig:patchgroup-transitions} Valid \patchgroup\
  dependency operation state machine.}
\end{figure}
%
Whereas \Kudos\ \modules\ are presumed to not create cyclic
dependencies, the kernel cannot safely trust user applications to be
so well behaved, so
%
the \patchgroup\ API restricts dependency manipulation so that cycles are
inconstructible.
%
Figure~\ref{fig:patchgroup-transitions} shows when a given
\patchgroup\ dependency operation is valid.
%
For example, \texttt{\pgDepend(q, p)} returns an error if
\texttt{q} has \emph{ever} been engaged; if it succeeds, a subsequent
\texttt{\pgEngage(p)} will return an error.\footnote{These rules are really
just a strictly enforced version of the requirement from \S\ref{sec:patch:nrb}
that all dependencies must be specified up-front.}
%
\todo{Explicitly mention that patchgroups allow specification of precisely
happens-before? They cannot be used to ``hold patches'' in ram.}

\Patchgroups\ and file descriptors are managed similarly---they are copied
across \texttt{fork}, preserved across \texttt{exec}, and closed on
\texttt{exit}.
%
This allows existing, unaware programs to interact with \patchgroups,
in the same way that programs do not have to know about pipes for the
shell to connect them in a pipeline.
%
For example, a \texttt{depend} program could apply \patchgroups\ to
unmodified applications by setting up the \patchgroups\ before calling
\texttt{exec}.  The following command line would ensure that \texttt{in} is
not removed until all changes in the preceding \texttt{sort} have committed
to disk:

\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using patchgroups vs fsync?

\Patchgroup\ support is implemented by an \LFS\ module that lives above a file
system module like ext2.
%
Each \patchgroup\ corresponds to a pair of containing \noop\ \patches,
and inter-\patchgroup\ dependencies to dependencies between these \noop\
\patches.
%
The \LFS\ module ensures that all file system changes are inserted
between engaged \patchgroups' \noop\ \patches.
%
Figure~\ref{fig:patchgroup-patches} shows an example \patch\ arrangement for
two \patchgroups.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\hsize]{fig/figures_5}
\caption{\label{fig:patchgroup-patches} \Patches\ corresponding to two
  \patchgroups, $p$ and $q$.  The $h$ and $t$ \patches\ are created by the 
  \patchgroup\ module; the heavy dependency between $t_p$ and $h_q$ was added
  by \texttt{pg~depend(p, q)}.  Each of $a_i$, $b$, and $c$ corresponds to
  a different file system change.}
\end{figure}

While these simple dependencies are all that is necessary when using soft
updates as the underlying consistency model, some extra work is required in the
journal module to support \patchgroups.
%
When using a journal, writing the commit record atomically commits a
transaction; additional \patchgroup-specified dependencies for the data in each
transaction must be shifted to the commit record itself.
%
These dependencies then collapse into dependencies of the commit record on
itself, or to previous commit records---both dependencies which already exist.
%
Finally, for a metadata journal, blocks which are modified as part of a
\patchgroup\ must also be included in the transaction, making the metadata
journal act like a full journal for those data blocks.

\subsection{Case Studies}
\label{sec:patchgroup:casestudies}

%% \todo{Introduce and contrast gzip, Subversion, and UW IMAP}
%% %
%% UW IMAP case study (faster, same safety, server) vs
%% Subversion case study (about same speed, additional safety on non-ext3
%% ordered, client).

We studied the \patchgroup\ interface by adding \patchgroup\ support to three
applications: the gzip compression utility, the Subversion version control
client, and the UW IMAP mail server daemon.

% discussion potential gains (in addition to actual gains)?

\paragraph{Gzip}
\label{sec:patchgroup:gzip}

Our first test showed that simple consistency requirements were simple to
add.  We updated gzip to use \patchgroups\ that ensure the input file's
removal is not committed before the output file's data is written, so that
a crash does not lose both files. The update adds 10 lines of code to gzip
v1.3.9.
%
\todo{Contrast with SU and journaling?
SU: must sync prior to unlink; slower completion and later changes to
output require additional writes.
Ordered and full journaling: safe with no changes.}

\paragraph{Subversion}
\label{sec:patchgroup:svn}

% describe why pgs are easier/better than journaling

The Subversion version control system's client~\cite{svn} manipulates a
local working copy of a repository.
%% In this case study we take an interest in how the Subversion version
%% control system client~\cite{svn} manipulates a local checkout (a
%% Subversion ``working copy'').
%
The working copy library is designed to avoid data corruption or loss
should the process exit prematurely from a working copy operation.
%
This safety is achieved using application-level write ahead journaling,
where each entry in Subversion's journal is either idempotent or
atomic.
%
Depending on the file system, however, even with this precaution a
working copy operation may not be protected against an operating
system or hardware crash.
%
For example, the journal file is marked as complete by moving it from
its temporary to live location.
%
Should the file system completely commit the file rename before
the file data, and crash before completing the file data commit, then
a subsequent journal replay could corrupt the working copy.

The working copy library could ensure a safe commit ordering by
syncing files as necessary; the Subversion server (repository) library
takes this approach.
%
However, as is common for non-server applications, the Subversion
developers deemed this approach too slow to be worthwhile at the
client~\cite{svntradeoff}.
%
Instead, the working copy library takes advantage of two file system
ordering properties ensured by ordered data and full data journaling, such
as is implemented by ext3.
%
First, all preceding writes to a file's data are committed before the file
is renamed,
%
and second, metadata updates are effectively committed in their system call
order.
%
%% The combination of these properties ensures the creation of file $i$
%% precedes the creation of file $(i+1)$.
%
In addition to being obtuse, file renaming does not behave as required
on many systems; for example, neither NTFS nor BSD UFS with soft
updates provide this property.
%
Additionally, non-journaled systems such as BSD UFS with soft updates
do not provide the metadata ordering property; on such systems the
journal file's installation may precede earlier file installations,
leaving the working copy in an inconsistent state.

We updated the Subversion working copy library to use \patchgroups\ to
express commit ordering requirements
%% \todo{Use consistency protocol phrase here and throughout?} 
without relying on properties of the
underlying file system implementation.
%
The use of the file rename property is replaced in two ways.
%
First, files created in a temporary location and then moved into their
live location (e.g. directory status and journal files) now
make the rename depend on the file data writes.
%
Second, files only referenced by live files (e.g. updated file
copies used by journal file entries) can live with a weaker ordering;
the data for these files need only precede the installation of the
referencing file.
%
The use of linearly ordered metadata updates is also replaced by
\patchgroup\ dependencies.
%
Although the original operations assumed a linear ordering of metadata
updates, the actual order requirements are considerably less strict.
%
For example, the updated file copies used by the journal may be
committed independently of each other.
%
Furthermore, most journal playback operations may commit
independently of each other; only interacting operations, such as a
file read and subsequent rename, need ordering.

Once we understood Subversion v1.4.3's requirements, it took a day to add
the 220 lines of code that enforce safety for conflicted updates (out of
25,000 in the working copy library).

\paragraph{UW IMAP}
\label{sec:patchgroup:uwimap}

We updated the University of Washington's IMAP mail server
(v2004g)~\cite{uwimap} to ensure mail updates are committed to disk
in safe and more efficient orderings.
%
The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store.
%
The most relevant IMAP commands synchronize changes to the server's
disk (CHECK), copy a message from the selected mailbox to another
mailbox (COPY), and delete messages marked for deletion (EXPUNGE).

We updated the imapd and mbox mail storage drivers to use
\patchgroups, ensuring that all disk writes occur in a safe ordering
without enforcing a specific block write order.
%
The original server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it.
%
For example, Figure~\ref{fig:imap}a illustrates moving messages from
one mailbox to another.
%
With \patchgroups, each command's file system updates are executed under a
distinct \patchgroup\ and, through the \patchgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) cannot lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \pgSync\ to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox: the client's CHECK request will ensure
changes are committed to disk, and the \patchgroup\ dependencies ensure
changes are committed in a safe ordering.
%
Figure~\ref{fig:imap}b illustrates using patches to move messages.
%
\todo{Does this figure convey what we want it to?}

\begin{figure}[tb]
\centering
\begin{tabular}{ccc}
\includegraphics[width=0.4\columnwidth]{imap_fsync} & &
\includegraphics[width=0.4\columnwidth]{imap_pg}\\
\textbf{a)} Unmodified, \texttt{fsync} & &
\textbf{b)} \Patchgroups
\end{tabular}
\caption{UW IMAP server, without and with \patchgroups, moving three
messages from mailbox.src to mailbox.dst.}
\label{fig:imap}
\end{figure}

These changes improve UW IMAP by
%
ensuring ensure disk write ordering correctness
%
and by performing disk writes more efficiently.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code
specifically ensure its changes are committed before any later, dependent
command's changes. Without \patchgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \patchgroup{}-enabled UW IMAP mail server is
evaluated in Section~\ref{sec:evaluation:uwimap}.
