\section{\Patchgroups}
\label{sec:patchgroup}

\newcommand{\pgCreate}{\texttt{pg\_create}}
\newcommand{\pgDepend}{\texttt{pg\_depend}}
\newcommand{\pgEngage}{\texttt{pg\_engage}}
\newcommand{\pgDisengage}{\texttt{pg\_disengage}}
\newcommand{\pgRelease}{\texttt{pg\_release}}
\newcommand{\pgSync}{\texttt{pg\_sync}}
\newcommand{\pgClose}{\texttt{pg\_close}}


This section describes \emph{\patchgroups}, a simple API that extends \patches\ to user
space and lets applications express dependencies among file system
operations.
%
Currently,
robust applications
%% often manipulate valuable data, e.g. a mail server's mail
%% or a version control system's local checkout.
%
can ensure their on-disk data remains in a sane state even after a
system crash by enforcing write-before relationships in one of two ways:
%% requiring their changes be committed in
%% a specified order.
%% %
%% Existing systems can ensure such orders in two ways:
%
either forcing an ordering by requiring immediate syncs
(e.g. \texttt{sync}, \texttt{fsync}, or \texttt{sync\_file\_range}),
%
or assuming an ordering by depending on particular file system implementation
semantics (e.g. journaling).
%
The \patch\ abstraction, in contrast, can let a process specify
\emph{what} ordering is required and leave the storage system to implement
that ordering in the most appropriate way.
%
Compared to forcing block writes in the application, this lets the file
system buffer, combine, and reorder block writes, but is still relatively
independent of the underlying file system.
%
For example, \patchgroups\ even allow an application to specify
dependencies among raw block device writes.


In this section we describe the \patchgroup\ abstraction
%
and apply it to three robust applications.

%%  it usefulness on three and show how it allows gzip, Subversion, and UW IMAP to easily specify
%% their application-level consistency protocols.

\subsection{Interface and Implementation}
\label{sec:patchgroup:interface}

\Patchgroups\ encapsulate sets of file system operations into units among
which dependencies can be applied.
%
%% applications can specify ordering requirements among \patchgroups.
%
The \patchgroup\ interface is as follows:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{alltt}
  typedef int pg_t;          pg_t \textbf{pg_create}(void);
  int \textbf{pg_engage}(pg_t pg);    int  \textbf{pg_disengage}(pg_t pg);
  int \textbf{pg_sync}(pg_t pg);      int  \textbf{pg_close}(pg_t pg);
  int \textbf{pg_depend}(pg_t after, pg_t before);
\end{alltt}
\end{scriptsize}
\vspace{-0.5\baselineskip}

Each process has its own set of \patchgroups, which are currently shared
among all threads.
%
The call \texttt{\pgDepend(q, p)} makes \patchgroup\ \texttt{q} depend on
\patchgroup\ \texttt{p}: all \patches\ associated with \texttt{p} will
be committed prior to those associated with \texttt{q}.
%
The \patches\ associated with a \patchgroup\ are those created while
the \patchgroup\ is engaged.
%
\pgSync\ forces an immediate write of a \patchgroup\ to disk.
%
\pgCreate\ creates a new \patchgroup\ and returns its ID
%
and \pgClose\ disassociates a \patchgroup\ ID from the underlying
\patches\ which implement it.

\begin{figure}[t]
\centering
\includegraphics[width=0.85\hsize]{opgroup_transitions}
\caption{\label{fig:patchgroup-transitions} Valid \patchgroup\
  dependency operation state machine.}
\end{figure}
%
Whereas \Kudos\ \modules\ are presumed to not create cyclic
dependencies, the kernel cannot safely trust user applications to be
so well behaved, so
%
the \patchgroup\ API restricts dependency manipulation so that cycles are
inconstructible.
%
Figure~\ref{fig:patchgroup-transitions} shows when a given
\patchgroup\ dependency operation is valid.
%
For example, \texttt{\pgDepend(q, p)} returns an error if
\texttt{q} has \emph{ever} been engaged; if it succeeds, a subsequent
\texttt{\pgEngage(p)} will return an error.\footnote{These rules are really
just a strictly enforced version of the requirement from \S\ref{sec:patch:nrb}
that all dependencies must be specified up-front.}

\Patchgroups\ and file descriptors are managed similarly---they are copied
across \texttt{fork}, preserved across \texttt{exec}, and closed on
\texttt{exit}.
%
This allows existing, unaware programs to interact with \patchgroups,
in the same way that programs do not have to know about pipes for the
shell to connect them in a pipeline.
%
For example, a \texttt{depend} program could apply \patchgroups\ to
unmodified applications by setting up the \patchgroups\ before calling
\texttt{exec}.  The following command line would ensure that \texttt{in} is
not removed until all changes in the preceding \texttt{sort} have committed
to disk:

\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using patchgroups vs fsync?

\Patchgroup\ support is implemented by an \LFS\ module that lives above a file
system module like ext2.
%
Each \patchgroup\ corresponds to a pair of containing \noop\ \patches,
and each inter-\patchgroup\ dependency corresponds to a dependency between
the \noop\ \patches.
%
The \LFS\ module ensures that all file system changes are inserted
between engaged \patchgroups' \noop\ \patches.
%
Figure~\ref{fig:patchgroup-patches} shows an example \patch\ arrangement for
two \patchgroups.

\begin{figure}[t]
\centering
%% \includegraphics[width=0.7\hsize]{fig/figures_5}
%% \caption{\label{fig:patchgroup-patches} \Patches\ corresponding to two
%%   \patchgroups, $p$ and $q$.  The $h$ and $t$ \patches\ are created by the 
%%   \patchgroup\ module; the heavy dependency between $t_p$ and $h_q$ was added
%%   by \texttt{pg~depend(p, q)}.  Each of $a_i$, $b$, and $c$ corresponds to
%%   a different file system change.}
\includegraphics[width=\hsize]{fig/figures_7}
\caption{\label{fig:patchgroup-patches} \Patchgroup\ \patch\ layout.  Empty
patches $h_\textit{pg}$ and $t_\textit{pg}$ bracket file system patches that occur while
\patchgroup\ \textit{pg} is engaged.  \Patchgroup\ dependencies connect one
\patchgroup's $t$ patch to another's $h$.}
\end{figure}

While these simple dependencies are all that is necessary when using soft
updates as the underlying consistency model, some extra work is required in the
journal module to support \patchgroups.
%
When using a journal, writing the commit record atomically commits a
transaction; additional \patchgroup-specified dependencies for the data in each
transaction must be shifted to the commit record itself.
%
These dependencies then collapse into harmless dependencies from the commit
record to itself or to previous commit records.
%
Finally, for a metadata journal, blocks which are modified as part of a
\patchgroup\ must also be included in the transaction, making the metadata
journal act like a full journal for those data blocks.

\subsection{Case Studies}
\label{sec:patchgroup:casestudies}

%% \todo{Introduce and contrast gzip, Subversion, and UW IMAP}
%% %
%% UW IMAP case study (faster, same safety, server) vs
%% Subversion case study (about same speed, additional safety on non-ext3
%% ordered, client).

We studied the \patchgroup\ interface by adding \patchgroup\ support to three
applications: the gzip compression utility, the Subversion version control
client, and the UW IMAP mail server daemon.
%
These applications were chosen for their relatively simple and explicit
consistency requirements; we intended to test how well patchgroups
implement existing application requirements, not to create new mechanisms.
One effect of this choice is that, after some modification, versions of
these applications could attain consistency guarantees similar to those
attained using \patchgroups\ if they are ran on a
fully-journaled file system with a conventional API.\todo{Not correct. Subversion is already correct and only requires ordered journaling.}  Patchgroups, however,
make the required guarantees explicit, can be implemented on other types of
file system, and introduce no additional cost on fully-journaled systems.

% discussion potential gains (in addition to actual gains)?

\paragraph{Gzip}
\label{sec:patchgroup:gzip}

%% Our first test showed that simple consistency requirements were simple to
%% add.  
Our modified gzip uses \patchgroups\ to make the input file's
removal depend on the output file's data being written; thus,
a crash cannot lose both files. The update adds 10 lines of code to gzip
v1.3.9: simple consistency requirements are simple to add.

\paragraph{Subversion}
\label{sec:patchgroup:svn}

% describe why pgs are easier/better than journaling

The Subversion version control system's client~\cite{svn} manipulates a
local working copy of a repository.
%% In this case study we take an interest in how the Subversion version
%% control system client~\cite{svn} manipulates a local checkout (a
%% Subversion ``working copy'').
%
The working copy library is designed to avoid data corruption or loss
should the process exit prematurely from a working copy operation.
%
This safety is achieved using application-level write ahead journaling,
where each entry in Subversion's journal is either idempotent or
atomic.
%
Depending on the file system, however, even with this precaution a
working copy operation may not be protected against a crash.
%
For example, the journal file is marked as complete by moving it from
its temporary to live location.
%
Should the file system completely commit the file rename before
the file data, and crash before completing the file data commit, then
a subsequent journal replay could corrupt the working copy.

The working copy library could ensure a safe commit ordering by
syncing files as necessary. The Subversion server (repository) library
takes this approach, but
%
the Subversion
developers deemed this approach too slow to be worthwhile at the
client~\cite{svntradeoff}.
%
Instead, the working copy library assumes that
%
first, all preceding writes to a file's data are committed before the file
is renamed;
%
and second, metadata updates are effectively committed in their system call
order.
%
%% The combination of these properties ensures the creation of file $i$
%% precedes the creation of file $(i+1)$.
%
In addition to being obtuse, file renaming does not behave as required on
many systems; for example, neither NTFS with journaling nor BSD UFS with
soft updates provide the required properties.  The Subversion developers
essentially specialized their consistency mechanism for one file system,
ext3 in either ``ordered'' or full journaling mode.
%
%% Additionally, non-journaled systems such as BSD UFS with soft updates
%% do not provide the metadata ordering property.  On such systems the
%% journal file's installation may precede earlier file installations,
%% leaving the working copy in an inconsistent state.

We updated the Subversion working copy library to use \patchgroups\ to
express commit ordering requirements
%% \todo{Use consistency protocol phrase here and throughout?} 
without relying on properties of the
underlying file system implementation.
%
The use of the file rename property is replaced in two ways.
%
First, files created in a temporary location and then moved into their
live location (e.g. directory status and journal files) now
make the rename depend on the file data writes.
%
Second, files only referenced by live files (e.g. updated file
copies used by journal file entries) can live with a weaker ordering;
the data for these files need only precede the installation of the
referencing file.
%
The use of linearly ordered metadata updates is also replaced by
\patchgroup\ dependencies.
%
Although the original operations assumed a linear ordering of metadata
updates, the actual order requirements are considerably less strict.
%
For example, the updated file copies used by the journal may be
committed independently of each other.
%
Furthermore, most journal playback operations may commit
independently of each other; only interacting operations, such as a
file read and subsequent rename, need ordering.

Once we understood Subversion v1.4.3's requirements, it took a day to add
the 220 lines of code that enforce safety for conflicted updates (out of
25,000 in the working copy library).

\paragraph{UW IMAP}
\label{sec:patchgroup:uwimap}

We updated the University of Washington's IMAP mail server
(v2004g)~\cite{uwimap} to ensure mail updates are committed to disk
in safe and more efficient orderings.
%
The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store.
%
The most relevant IMAP commands synchronize changes to the server's
disk (CHECK), copy a message from the selected mailbox to another
mailbox (COPY), and delete messages marked for deletion (EXPUNGE).

We updated the imapd and mbox mail storage drivers to use
\patchgroups, ensuring that all disk writes occur in a safe ordering
without enforcing a specific block write order.
%
The original server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it.
%
For example, Figure~\ref{fig:imap}a illustrates moving messages from
one mailbox to another.
%
With \patchgroups, each command's file system updates are executed under a
distinct \patchgroup\ and, through the \patchgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) cannot lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \pgSync\ to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox: the client's CHECK request will ensure
changes are committed to disk, and the \patchgroup\ dependencies ensure
changes are committed in a safe ordering.
%
Figure~\ref{fig:imap}b illustrates using patches to move messages.

\begin{figure}[tb]
\centering
\begin{tabular}{ccc}
\includegraphics[width=0.4\columnwidth]{imap_fsync} & &
\includegraphics[width=0.4\columnwidth]{imap_pg}\\
\textbf{a)} Unmodified, \texttt{fsync} & &
\textbf{b)} \Patchgroups
\end{tabular}
\caption{UW IMAP server, without and with \patchgroups, moving three
messages from mailbox.src to mailbox.dst.}
\label{fig:imap}
\end{figure}

These changes improve UW IMAP by
%
ensuring disk write ordering correctness
%
and by performing disk writes more efficiently.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code
specifically ensure its changes are committed before any later, dependent
command's changes. Without \patchgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \patchgroup{}-enabled UW IMAP mail server is
evaluated in Section~\ref{sec:evaluation:uwimap}.
