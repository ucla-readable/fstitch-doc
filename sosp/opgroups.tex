\section{\Patchgroups}
\label{sec:patchgroup}

\newcommand{\pgCreate}{\texttt{pg\_create}}
\newcommand{\pgDepend}{\texttt{pg\_depend}}
\newcommand{\pgEngage}{\texttt{pg\_engage}}
\newcommand{\pgDisengage}{\texttt{pg\_disengage}}
\newcommand{\pgRelease}{\texttt{pg\_release}}
\newcommand{\pgSync}{\texttt{pg\_sync}}
\newcommand{\pgClose}{\texttt{pg\_close}}

Robust applications
%% often manipulate valuable data, e.g. a mail server's mail
%% or a version control system's local checkout.
%
ensure their on-disk data remains in a sane state even after a
system crash by requiring their changes be committed in
a specified order.
%
Existing systems can ensure such orders in two ways:
%
applications can tell the file system \emph{how} to implement the
ordering by requiring immediate syncs
(e.g. \texttt{sync}, \texttt{fsync}, or \texttt{sync\_file\_range}),
%
or applications can require particular file system implementation
semantics (e.g. journaling).
%
%
The \patch\ abstraction, in contrast, can let a process specify
\emph{what} ordering is required and leave the storage system to implement
that ordering in the most appropriate way.


This section describes \emph{\patchgroups}, which extend \patches\ to user
space and let applications express dependencies among file system
operations.
%
Compared to a dictated order, this lets the file system optimize commit
orderings, but is still relatively independent of the underlying file
system.
%
For example, \patchgroups\ even allow an application to specify
dependencies among raw block device writes.

In this section we describe the \patchgroup\ abstraction
%
and apply it to three robust applications.

%%  it usefulness on three and show how it allows gzip, Subversion, and UW IMAP to easily specify
%% their application-level consistency protocols.

\subsection{Interface and Implementation}
\label{sec:patchgroup:interface}

\todo{Mention threads?}
\Patchgroups\ encapsulate sets of file system operations into units among
which dependencies can be applied.
%
%% applications can specify ordering requirements among \patchgroups.
%
The \patchgroup\ interface is as follows:

\begin{scriptsize}
\begin{alltt}
  typedef int pg_t;          pg_t \textbf{pg_create}(void);
  int \textbf{pg_depend}(pg_t after, pg_t before);
  int \textbf{pg_engage}(pg_t pg);    int  \textbf{pg_disengage}(pg_t pg);
  int \textbf{pg_sync}(pg_t pg);      int  \textbf{pg_close}(pg_t pg);
\end{alltt}
\end{scriptsize}

Each process has its own set of \patchgroups.
%
The call \texttt{\pgDepend(q, p)} makes \patchgroup\ \texttt{q} depend on
\patchgroup\ \texttt{p}: all \patches\ associated with \texttt{p} will
be committed prior to those associated with \texttt{q}.
%
The \patches\ associated with a \patchgroup\ are those created while
the \patchgroup\ is engaged.
%
\pgSync\ forces an immediate write of a \patchgroup\ to disk.
%
\pgCreate\ creates a new \patchgroup\ and returns its ID
%
and \pgClose\ disassociates a \patchgroup\ ID from the underlying
\patches\ which implement it.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\hsize]{opgroup_transitions}
\caption{\label{fig:patchgroup-transitions} Valid \patchgroup\
  dependency operation state machine.}
\end{figure}
%
Whereas \Kudos\ \modules\ are presumed to not create cyclic
dependencies, the kernel cannot safely trust user applications to be
so well behaved, so
%
the \patchgroup\ API restricts dependency manipulation so that cycles are
inconstructible.
%
Figure~\ref{fig:patchgroup-transitions} shows when a given
\patchgroup\ dependency operation is valid.
%
For example, \texttt{\pgDepend(q, p)} returns an error if
\texttt{q} has \emph{ever} been engaged; if it succeeds, a subsequent
\texttt{\pgEngage(p)} will return an error.\footnote{These rules are really
just a strictly enforced version of the requirement from \S~\ref{sec:patch:nrb}
that all dependencies must be specified up-front.}
%
\todo{Explicitly mention that patchgroups allow specification of precisely
happens-before? They cannot be used to ``hold patches'' in ram.}

\Patchgroups\ and file descriptors are managed similarly---they are copied
across \texttt{fork()}, preserved across \texttt{exec()}, and closed on
\texttt{exit()}.
%
This allows existing, unaware programs to interact with \patchgroups\,
in the same way that programs do not have to know about pipes for the
shell to connect them in a pipeline.
%
For example, a \texttt{depend} program could apply \patchgroups\ to
unmodified applications by setting up the \patchgroups\ before calling
\texttt{exec}.  The following command line would ensure that \texttt{in} is
not removed until all changes in the preceding \texttt{sort} have committed
to disk:

\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using patchgroups vs fsync?

\Patchgroup\ support is implemented by an \LFS\ module that lives above a file
system module like ext2.
%
Each \patchgroup\ corresponds to a pair of containing \noop\ \patches,
and inter-\patchgroup\ dependencies to dependencies inbetween these \noop\
\patches.
%
The \LFS\ module ensures that all file system changes are inserted
between engaged \patchgroups's \noop\ \patches.
%
Figure~\ref{fig:patchgroup-patches} shows an example \patch\ arrangement for
two \patchgroups.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\hsize]{fig/figures_5}
\caption{\label{fig:patchgroup-patches} \Patches\ corresponding to two
  \patchgroups, $p$ and $q$.  The $h$ and $t$ \patches\ are created by the 
  \patchgroup\ module; the heavy dependency between $t_p$ and $h_q$ was added
  by \texttt{pg~depend(p, q)}.  Each of $a_i$, $b$, and $c$ corresponds to
  a different file system change.}
\end{figure}

\subsection{Case Studies}
\label{sec:patchgroup:casestudies}

%% \todo{Introduce and contrast gzip, Subversion, and UW IMAP}
%% %
%% UW IMAP case study (faster, same safety, server) vs
%% Subversion case study (about same speed, additional safety on non-ext3
%% ordered, client).

We tested the \patchgroup\ interface by adding \patchgroup\ support to three
applications: the gzip compression utility, the Subversion version control
system, and the uw-imapd IMAP mail server daemon.

% discussion potential gains (in addition to actual gains)?

\paragraph{Gzip}
\label{sec:patchgroup:gzip}

Our first test showed that simple consistency requirements were trivial to
add.  We updated gzip to use \patchgroups\ that ensure the input file's
removal is not committed before the output file's data is written, so that
a crash does not lose both files. The update adds 10 lines of code to gzip.

% TODO: note fsync's deficiencies: rm of .gz makes write of .gz unnecessary,
% later changes to .gz rewrite the changed blocks, gzip completion takes
% longer. The normal reasons to delay writing a block.

\paragraph{Subversion}
\label{sec:patchgroup:svn}

% describe why pgs are easier/better than journaling

The Subversion version control system's client~\cite{svn} manipulates a
local \emph{working copy} of a possibly-remote source repository.
%% In this case study we take an interest in how the Subversion version
%% control system client~\cite{svn} manipulates a local checkout (a
%% Subversion ``working copy'').
%
The working copy library is designed to avoid data corruption or loss
should the process exit prematurely from a working copy operation.
%
This safety is achieved using application-level write ahead journaling,
where each entry in Subversion's journal is either idempotent or
atomic.
%
Even with this precaution, however, a working copy operation may not be
protected against an operating system or hardware crash.
%
For example, the journal file is committed when it is moved from a
temporary to its official location, but the file system might commit this
rename to stable storage \emph{before} completely writing the journal
file's data.
%
A system crash in between the complete commit of these two operations
and the subsequent journal replay could corrupt the working copy.

The working copy library could ensure a safe commit ordering by
syncing files as necessary; the Subversion server (repository) library
takes this approach.
%
However, as is common for non-server applications, the Subversion
developers deemed this approach too slow to be worthwhile at the
client~\cite{svntradeoff}.
%
Instead, the working copy library takes advantage of two file system
ordering properties ensured by ordered data and full data journaling, such
as is implemented by ext3.
%
First, all preceding writes to a file's data are committed before the file
is renamed,
%
and second, metadata updates are committed in their system call order.
%
%% The combination of these properties ensures the creation of file $i$
%% precedes the creation of file $(i+1)$.
%
In addition to being obtuse, file renaming does not behave
as required on many systems other than ext3 in ordered or full data
mode; for example, neither NTFS nor BSD UFS with soft updates provide
this property.
%
And non-journaled systems, such as BSD UFS with soft updates, do not
provide the metadata ordering property. On these systems, the journal
file's installation may precede earlier file installations, leaving the
working copy in an inconsistent state.

We updated the Subversion working copy library to use \patchgroups\ to
express commit ordering requirements
%% \todo{Use consistency protocol phrase here and throughout?} 
without relying on properties of the
underlying file system implementation.
%
For example, Figure~\ref{fig:svn-order} shows the \patchgroups\ created to update a
file with conflicts.
%
The use of the file rename property is replaced in two ways.
%
First, files created in a temporary location and then moved into their
official location (e.g. directory status and journal files) now
make the rename depend on the file data writes.
%
Second, files only referenced by official files (e.g. updated file
copies used by journal file entries) can live with a weaker ordering;
the data for these files need only precede the installation of the
referencing file.
%
The use of linearly ordered metadata updates is also replaced by
\patchgroup\ dependencies.
%
Although the original operations assumed a linear ordering of metadata
updates, the actual order requirements are considerably less strict.
%
For example, the updated file copies used by the journal may be
committed independently of each other.
%
Furthermore, most journal playback operations may commit
independently of each other; only interacting operations, such as a
file read and subsequent rename, need ordering.

Once we understood Subversion's requirements, it took a day to add
the 220 lines of code that enforce safety for conflicted updates (out of
25000 in the working copy library).

\begin{figure}[t]
  \centering
  \includegraphics[width=.8\columnwidth]{svn_opgroups}
  \caption{\Patchgroups\ to update a file in a Subversion working copy.}
  \label{fig:svn-order}
\end{figure}

\paragraph{UW IMAP}
\label{sec:patchgroup:uwimap}

Finally, we updated the University of Washington's IMAP mail server~\cite{uwimap} to
ensure mail updates are committed to disk
in safe and efficient orderings.
%
The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store.
%
The most relevant IMAP commands synchronize changes to the server's
disk (CHECK), copy a message from the selected mailbox to another
mailbox (COPY), and delete messages marked for deletion (EXPUNGE).

The imapd and mbox mail storage
drivers were updated to use \patchgroups, ensuring that all disk changes occur in a safe
ordering without enforcing any specific order.
%
The original server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\patchgroups, each command's file system updates are executed under a
distinct \patchgroup\ and, through the \patchgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) cannot lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \pgSync\ to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox: the client's CHECK request will ensure
changes are committed to disk, and the \patchgroup\ dependencies ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify it in two ways:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code
ensure its changes are committed before any later, dependent
command's changes. Without \patchgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \patchgroup{}-enabled UW IMAP mail server is
evaluated in Section~\ref{sec:evaluation:uwimap}.
