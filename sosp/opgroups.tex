\section{\Opgroups}
\label{sec:opgroup}

\newcommand{\pgCreate}{\texttt{pg\_create()}}
\newcommand{\pgDepend}{\texttt{pg\_depend()}}
\newcommand{\pgEngage}{\texttt{pg\_engage()}}
\newcommand{\pgDisengage}{\texttt{pg\_disengage()}}
\newcommand{\pgRelease}{\texttt{pg\_release()}}
\newcommand{\pgSync}{\texttt{pg\_sync()}}
\newcommand{\pgClose}{\texttt{pg\_close()}}

Applications often manipulate valuable data, e.g. a mail server's mail
or a version control system's local checkout.
%
To ensure their on-disk data remains in a sane state even after a
system crash, such applications require their changes be committed in
an application-defined order.
%
Existing systems provide two interfaces to ensure such orders.
%
Applications may dictate \emph{how} the file system must implement the
ordering and/or they may require particular file system implementation
semantics.
%
However, these techniques dramatically limit performance or limit
safety to only a particular file system, respectively.

We extend the \chdesc\ abstraction to user-space, as a \opgroup,
%
to enable applications to \emph{express} dependencies among file system
operations.
%
Compared to a dictated order, dependency specification allows the file
system to optimize commit orderings;
%
and compared to required file system semantics, \opgroup\ dependencies
are independent of the underlying file system.
%
For example, \opgroups\ even allow an application to specify
dependencies among raw block device writes.

In this section we describe the \opgroup\ abstraction
%
and show how it allows gzip, Subversion, and UW IMAP to easily specify
their application-level consistency protocols.

\subsection{Interface}
\label{sec:opgroup:interface}

A \emph{\opgroup} corresponds to the changes (\chdescs) made by a set of
file system operations;
%
applications can specify ordering requirements among \opgroups.
%
Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface.

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.22in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int pg_t;
pg_t \textbf{pg_create}(void);
int  \textbf{pg_depend}(pg_t pg1, pg_t pg2);
int  \textbf{pg_engage}(pg_t pg);
int  \textbf{pg_disengage}(pg_t pg);
int  \textbf{pg_sync}(pg_t pg);
int  \textbf{pg_close}(pg_t pg);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} \Opgroup\ API.}
\end{figure}

The \chdescs\ created during a file system operation are associated
with each of the process's \emph{engaged} \opgroups\ (\pgEngage\ and
\pgDisengage\ add to and remove from the process's engaged set).
%
Making \opgroup\ $P$ depend on \opgroup\ $Q$ (\pgDepend)
ensures \(\indirdepends{P}{Q}\).
%
\pgSync\ forces an immediate write of \anopgroup\ to disk.

Whereas \Kudos\ \modules\ are presumed to not create cyclic
dependencies, the kernel cannot safely trust user applications to be
so well behaved.
%
The \opgroup\ API restricts dependency manipulation so that cycles are
inconstructable, while preserving the interface's utility.

A process's \opgroups\ and its engaged set are copied across \texttt{fork()},
facilitating \opgroup\ interactions among processes.
%
For example, consider processing and then removing some input:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+sort < in > out && rm in+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}
%
Using \opgroups, the user can ensure that \texttt{in} is not removed
before \texttt{out} is committed to disk, so that a crash part way
through does not lose both files.
%
Using \texttt{depend}, a program that, for each argument,
%
creates \anopgroup\ that depends on the previous argument's \opgroup\
%
and runs the argument within its \opgroup,
%
the user can instead run:
%
\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+\todo{Is this example worth its space?}
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using opgroups vs fsync?

\subsection{Implementation}
\label{sec:opgroup:implementation}

An \opgroup\ brackets its \chdescs\ so that the entire group can
depend on another \opgroup.

\Opgroups\ are implemented in an \LFS\ module that imposes \opgroup\
dependencies using additional \chdesc\ dependencies among \LFS\
operations.
%
Figure~\ref{fig:opgroup-chdescs} shows \anopgroup's \chdesc\ arrangement.
%
The ``head'' \chdesc\ depends on the \opgroup's \chdescs, the ``tail''
\chdesc, and the ``head keep'' \chdesc.
%
The \opgroup's \chdescs\ all depend on the ``tail'' \chdesc, which in
turn depends on the ``tail keep'' \chdesc.
%
The ``keep'' \chdescs\ prevent the head and tail \chdescs\ from being
prematurely satisfied should all their other \befores\ be satisfied
(for instance, by being written to disk).
%
Using this \chdesc\ arrangement, \anopgroup\ dependency \depends{Q}{P}
is implemented as \depends{\mbox{tail}_Q}{\mbox{head}_P}

\begin{figure}[htb]
\centering{
\includegraphics[width=0.5\hsize]{fig/figures_5}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs. H and T are the head
and tail of the \opgroup; HK and TK are the head keep and tail keep. The three
\chdescs\ labeled 1 occurred during one file system operation, and the \chdesc\
labeled 2 occurred during a second operation that depended on the first.}
\end{figure}

\Opgroups\ are created and managed almost exactly like file descriptors. Handles
to them are copied across \texttt{fork()}, preserved across \texttt{exec()}, and
closed upon \texttt{exit()}. Whether \anopgroup\ is \engaged\ or not is a
property local to the process, like the ``close-on-exec'' flag of file
descriptors. These properties allow existing programs to use \opgroups\ without
knowing it, in the same way that they don't have to know anything about pipes
for the shell to connect them in a pipeline --- the parent process creates and
\engages\ the \opgroups\ before calling \texttt{exec()}, and then the process
does its file system operations without knowing or needing to know that they are
being hooked up to \anopgroup.

\subsection{Case Studies}
\label{sec:opgroup:casestudies}

TODO: introduce and contrast gzip, Subversion, and UW IMAP?
%
UW IMAP case study (faster, same safety, server) vs
Subversion case study (about same speed, additional safety on non-ext3
ordered, client).

\subsubsection{Gzip}
\label{sec:opgroup:gzip}

Gzip~\cite{gzip} is a standard file compressor.
%
Gzip's typical operation is to compress a source file into an output file,
and then remove the source file.
%
We updated gzip to use \opgroups\ to ensure that the source file's
removal is not committed before the output file's data, so that a
crash does not lose both files. The update adds 10 lines of code to
gzip.

\subsubsection{Subversion}
\label{sec:opgroup:svn}

Subversion~\cite{svn} is a version control system.
%
In this case study we take an interest in how the Subversion client
manipulates a local checkout (a Subversion ``working copy'').
%
The working copy library is designed to avoid data corruption or loss
should the process exit prematurely during a working copy operation.
%
This safety is achieved using application-level write ahead
journaling.
%
For example, to retrieve a file update, the working copy library
performs the following operations:
%
\begin{description}
\item[Create Status] Create the a status file (in a temporary location)
  stating the working copy is updating
\item[Install Status] Move the status file into its official location
\item[Create Journal Data] Create files used by journal entries (in a
  temporary, temporary location)
\item[Install Journal Data] Move journal data files into a temporary
  location
\item[Create Journal] Create the journal file (in a temporary location)
\item[Install Journal] Move the journal to its official location
\item[Play Journal] Play the journal entries
\item[Create Status] Create a new status file (in a temporary location)
  with the updated working copy metadata
\item[Install Status] Move the status file into its official location
\item[Remove Journal] Remove the journal file
\end{description}
%
Each log file entry is either idempotent or atomic.
%
Prior to \textbf{Install Journal}, only temporary files are modified.
After \textbf{Install Journal}, all entries can be replayed until the
journal is successfully played in full.

Even with this precaution, a working copy operation is not protected
against an operating system or hardware crash.
%
For example, \textbf{Install Journal}'s changes could be committed
prior to the commit of all of \textbf{Create Journal Data}'s changes.
%
A system crash in-between the complete commit of these two operations
and the subsequent journal replay would corrupt the working copy.

The working copy library could ensure a safe commit ordering by
syncing files as necessary, as the Subversion repository library does.
%
However, the Subversion developers deemed this approach too slow to be
worthwhile for client use~\cite{svntradeoff}; a common trade-off
decision among non-server applications.

Instead, the working copy library takes advantage of two file system
ordering properties ensured by ordered data and full data journaling
to ensure a safe commit ordering:
\begin{description}
\item[Rename] A file rename is committed only after all preceding file
  data writes
\item[Metadata] Metadata updates are committed in their system call order
\end{description}
%
The \textbf{Rename} property supports the atomic creation of a file
with all of its data, by creating a temporary file with its data
(\textbf{Create X}) and then renaming to the desired name
(\textbf{Install X}).
%
The combination of the \textbf{Metadata} and \textbf{Rename}
properties ensures the commit of the $n^{\mbox{\small{th}}}$ atomic
create precedes the \((n+1)^{\mbox{\small{st}}}\) atomic create,
ensuring \textbf{Install Journal Data} precedes \textbf{Install
  Journal}.
%
In addition to being an obtuse approach, file renaming does not have
the \textbf{Rename} property on many systems other than Ext3 in
ordered or full data mode; for example, neither NTFS nor BSD UFS with
soft updates provide this property.
%
And non-journaled systems, such as BSD UFS with soft updates, do not
provide the \textbf{Metadata} property.

We updated the Subversion working copy library to use \opgroups\ to
express commit ordering requirements\todo{Use consistency protocol
  phrase here and throughout?} without relying on properties of the
underlying file system implementation.
%
Figure~\ref{fig:svn-order} shows the \opgroups\ created to update a
file with conflicts.

The use of atomic file creation is replaced in two ways.
%
Live files (e.g. the status and journal files) now create
\depends{\textbf{Install X}}{\textbf{Create X}}.
%
Journal data files no longer require atomic creation; instead, they
are created in the \textbf{Create Journal Data} \opgroup\ and the
\depends{\textbf{Install Journal}}{\textbf{Create Journal Data}}
dependency is added.

The use of the \textbf{Metadata} property is replaced by \opgroup\
dependencies.
%
Although the original operations assumed the \textbf{Metadata}
property, the actual order requirements are considerably less strict.
%
For example, journal data files and their data may be committed in any
order.
%
Or, most journal play operations may commit in any order; however, a
rename operation must depend on preceding reads of its source file to
make any future replay safe.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{svn_opgroups}
  \caption{\Opgroups\ to update a file in a Subversion working copy.}
  \label{fig:svn-order}
\end{figure}

\subsubsection{UW IMAP}
\label{sec:opgroup:uwimap}

To assess the utility of \opgroups\ in a real world application we
updated the University of Washington's IMAP mail server to take
advantage of \opgroups, to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store. An IMAP client
is in one of four states: not authenticated, authenticated, mailbox
selected, and logged out. States define the set of valid commands a
client may issue. For example, clients in the selected state may
retrieve messages from the selected mailbox. In our case study we are
interested in mailbox manipulation; the authenticated and selected
states allow mailbox manipulation. The most relevant IMAP commands
synchronize changes to the server's disk (CHECK), copy a message from
the selected mailbox to another mailbox (COPY), and delete messages
marked for deletion (EXPUNGE).

UW IMAP~\cite{uwimap}, authored by Mark Crispin of the IMAP RFC,
includes an IMAP mail server imapd and mail client library c-client.
We have updated imapd and the mbox mail storage driver to use
\opgroups\ to ensure all disk changes occur in a safe ordering, while
performing a minimal number of disk writes.
%
The original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\opgroups, each command's file system updates are executed under a
distinct \opgroup\ and, through the \opgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) can not lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \pgSync\ to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox; the client's CHECK request will ensure
changes are committed to disk; the \opgroup\ dependencies will ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify two aspects:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code be concerned with
ensuring its changes are committed before any later, dependent
command's changes. Without \opgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \opgroup{}-enabled UW IMAP mail server is
evaluated in Section~\ref{sec:evaluation:uwimap}.
