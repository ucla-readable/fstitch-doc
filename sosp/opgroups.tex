\section{\Opgroups}
\label{sec:opgroup}

\newcommand{\pgCreate}{\texttt{pg\_create()}}
\newcommand{\pgDepend}{\texttt{pg\_depend()}}
\newcommand{\pgEngage}{\texttt{pg\_engage()}}
\newcommand{\pgDisengage}{\texttt{pg\_disengage()}}
\newcommand{\pgRelease}{\texttt{pg\_release()}}
\newcommand{\pgSync}{\texttt{pg\_sync()}}
\newcommand{\pgClose}{\texttt{pg\_close()}}

Robust applications
%% often manipulate valuable data, e.g. a mail server's mail
%% or a version control system's local checkout.
%
ensure their on-disk data remains in a sane state even after a
system crash by requiring their changes be committed in
a specified order.
%
Existing systems provide two ways to ensure such orders:
%
applications may dictate \emph{how} the file system must implement the
ordering, or they may require particular file system implementation
semantics.
%
However, these techniques dramatically limit performance or limit
safety to only a particular file system, respectively.

We extend the \chdesc\ abstraction to user-space, as a \opgroup,
%
to enable applications to \emph{express} dependencies among file system
operations.
%
Compared to a dictated order, dependency specification allows the file
system to optimize commit orderings;
%
and compared to required file system semantics, \opgroup\ dependencies
are independent of the underlying file system.
%
For example, \opgroups\ even allow an application to specify
dependencies among raw block device writes.

In this section we describe the \opgroup\ abstraction
%
and show how it allows gzip, Subversion, and UW IMAP to easily specify
their application-level consistency protocols.

\subsection{Interface}
\label{sec:opgroup:interface}

A \emph{\opgroup} corresponds to the changes (\chdescs) made by a set of
file system operations;
%
applications can specify ordering requirements among \opgroups.
%
Figure~\ref{fig:opgroup-interface} shows the \opgroup\ interface.

\begin{figure}[htb]
\vskip-14pt
\begin{tabular}{@{\hskip0.22in}p{2in}@{}}
\begin{scriptsize}
\begin{alltt}
typedef int pg_t;
pg_t \textbf{pg_create}(void);
int  \textbf{pg_depend}(pg_t pg1, pg_t pg2);
int  \textbf{pg_engage}(pg_t pg);
int  \textbf{pg_disengage}(pg_t pg);
int  \textbf{pg_sync}(pg_t pg);
int  \textbf{pg_close}(pg_t pg);
\end{alltt}
\end{scriptsize}
\end{tabular}
\vspace{-10pt}
\caption{\label{fig:opgroup-interface} \Opgroup\ API.}
\end{figure}

The \chdescs\ created during a file system operation are associated
with each of the process's \emph{engaged} \opgroups\ (\pgEngage\ and
\pgDisengage\ add to and remove from the process's engaged set).
%
Making \opgroup\ $P$ depend on \opgroup\ $Q$ (\pgDepend)
ensures \(\indirdepends{P}{Q}\).
%
\pgSync\ forces an immediate write of \anopgroup\ to disk.

Whereas \Kudos\ \modules\ are presumed to not create cyclic
dependencies, the kernel cannot safely trust user applications to be
so well behaved.
%
The \opgroup\ API restricts dependency manipulation so that cycles are
inconstructible, while preserving the interface's utility.

\Opgroups\ and file descriptors are managed similarly; e.g. they are copied
across \texttt{fork()} and preserved across \texttt{exec()}.
%
This allows existing programs to interact with \opgroups\ without
knowing it, in the same way that programs do not have to know about
pipes for the shell to connect them in a pipeline.
%
For example, a \texttt{depend} program could apply \patchgroups\ to
unmodified applications by setting up the \patchgroups\ before calling
\texttt{exec}.  The following command line would ensure that \texttt{in} is
not removed until all changes in the preceding \texttt{sort} have committed
to disk:

\vspace{-0.5\baselineskip}
\begin{center}
\begin{small}
\verb+depend "sort < in > out" "rm in"+
\end{small}
\end{center}
\vspace{-0.5\baselineskip}

% FIXME: Mention simplicity using opgroups vs fsync?

\subsection{Implementation}
\label{sec:opgroup:implementation}

\Anopgroup\ is implemented by surrounding its \patches\ by a bracket of
empty \patches; \opgroup\ dependencies are represented as dependencies
among these bracket empty \patches.
%
These dependencies are created by the \opgroup\ \module\ as file
system operations are performed.

Figure~\ref{fig:opgroup-chdescs} shows \anopgroup's \chdesc\ arrangement.
%
The head \chdesc\ depends on the \opgroup's \chdescs\ and the tail
\chdesc.
%
The \opgroup's \chdescs\ all depend on the tail \chdesc.
%
The \opgroup\ dependency \depends{P}{Q} is implemented as
\depends{\mbox{tail}_P}{\mbox{head}_Q}

\begin{figure}[htb]
\centering{
\includegraphics[width=0.3\hsize]{fig/figures_5}
}
\caption{\label{fig:opgroup-chdescs} \Opgroup\ \chdescs. H and T are the head
  and tail of the \opgroup.
  %
  The three \chdescs\ labeled 1 occurred during one file system
  operation,
  %
  and the \chdesc\ labeled 2 occurred during a second operation that
  depended on the first.}
\end{figure}

\subsection{Case Studies}
\label{sec:opgroup:casestudies}

%% \todo{Introduce and contrast gzip, Subversion, and UW IMAP}
%% %
%% UW IMAP case study (faster, same safety, server) vs
%% Subversion case study (about same speed, additional safety on non-ext3
%% ordered, client).

We tested the \opgroup\ interface by adding \opgroup\ support to three
applications: the gzip compression utility, the Subversion version control
system, and the uw-imapd IMAP mail server daemon.

\paragraph{Gzip}
\label{sec:opgroup:gzip}

Gzip's typical operation is to compress a source file into an output file,
and then remove the source file~\cite{gzip}.
%
We updated gzip to use \opgroups\ to ensure that the source's removal
is not committed before the output file's data, so that a crash does
not lose both files. The update adds 10 lines of code to gzip.

\paragraph{Subversion}
\label{sec:opgroup:svn}

In this case study we take an interest in how the Subversion version
control system client~\cite{svn} manipulates a local checkout (a
Subversion ``working copy'').
%
The working copy library is designed to avoid data corruption or loss
should the process exit prematurely from a working copy operation.
%
This safety is achieved using application-level write ahead
journaling, where each entry is either idempotent or atomic\todo{Explain
temporary files used by the journal?}.

Even with this precaution, a working copy operation may not be
protected against an operating system or hardware crash.
%
For example, the journal file move from its temporary to official
location (which indicates the journal may played) could be committed
prior to the commit of the journal file's data.
%
A system crash in-between the complete commit of these two operations
and the subsequent journal replay could corrupt the working copy.

The working copy library could ensure a safe commit ordering by
syncing files as necessary; the Subversion server (repository) library
takes this approach.
%
However, as is common for non-server applications, the Subversion
developers deemed this approach too slow to be worthwhile for client
use~\cite{svntradeoff}.
%
Instead, the working copy library takes advantage of two file system
ordering properties ensured by ordered data and full data journaling
to ensure a safe commit ordering.
%
First, a file's rename commit proceeds the file's data commits;
%
and second, metadata updates are committed in their system call order.
%
The combination of these properties ensures the creation of file
$i^{\mbox{\small{th}}}$ precedes the creation of file
$(i+1)^{\mbox{\small{st}}}$.

In addition to being an obtuse approach, file renaming does not behave
as required on many systems other than Ext3 in ordered or full data
mode; for example, neither NTFS nor BSD UFS with soft updates provide
this property.
%
And non-journaled systems, such as BSD UFS with soft updates, do not
provide the metadata ordering property. On these systems, the journal
file's installation may precede earlier file installations, leaving the
working copy in an inconsistent state.

We updated the Subversion working copy library to use \opgroups\ to
express commit ordering requirements\todo{Use consistency protocol
  phrase here and throughout?} without relying on properties of the
underlying file system implementation.
%
Figure~\ref{fig:svn-order} shows the \opgroups\ created to update a
file with conflicts.

The use of the file rename property is replaced in two ways.
%
First, files created in a temporary location and then moved into their
official location (e.g. the directory status and journal files) now
make the rename depend on the file data writes.
%
Second, files only referenced by official files (e.g. updated file
copies used by journal file entries) only require a weaker ordering.
The data for these files need only precede the installation of the
referencing file.

The use of linearly ordered metadata updates is also replaced by
\opgroup\ dependencies.
%
Although the original operations assumed a linear ordering of metadata
updates, the actual order requirements are considerably less strict.
%
For example, the updated file copies used by the journal may be
committed independently of each other.
%
A second example, most journal playback operations may commit
independently of each other; only interacting operations, such as a
file read and subsequent rename, need ordering.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{svn_opgroups}
  \caption{\Opgroups\ to update a file in a Subversion working copy.}
  \label{fig:svn-order}
\end{figure}

\paragraph{UW IMAP}
\label{sec:opgroup:uwimap}

We updated the University of Washington's IMAP mail server to take
advantage of \opgroups, to ensure mail updates are committed to disk
in safe and efficient orderings.

The Internet Message Access Protocol (IMAP)~\cite{rfc3501} provides
remote access to a mail server's email message store.
%
The most relevant IMAP commands synchronize changes to the server's
disk (CHECK), copy a message from the selected mailbox to another
mailbox (COPY), and delete messages marked for deletion (EXPUNGE).

We have updated the UW IMAP~\cite{uwimap} imapd and mbox mail storage
driver to use \opgroups\ to ensure all disk changes occur in a safe
ordering, while performing a minimal number of disk writes.
%
The original IMAP server conservatively preserved command ordering by
syncing the mailbox file after each CHECK on it or COPY into it. With
\opgroups, each command's file system updates are executed under a
distinct \opgroup\ and, through the \opgroup, made to depend on the
previous command's updates. This is necessary, for example, so that
moving a message to another folder (accomplished by copying to the
destination file and then removing from the source file) can not lose
the copied message should the server crash part way through the disk
updates.
%
The updated CHECK command uses \pgSync\ to sync all preceding disk
updates. This enhancement to CHECK removes the requirement that COPY
sync its destination mailbox; the client's CHECK request will ensure
changes are committed to disk; the \opgroup\ dependencies will ensure
changes are committed in a safe ordering.

These changes to UW IMAP simplify two aspects:
%
ensuring change ordering correctness
%
and making efficient usage of disk updates.
%
As each command's changes now depend on the preceding command's
changes, it is no longer required that all code be concerned with
ensuring its changes are committed before any later, dependent
command's changes. Without \opgroups, modules like the mbox driver
forced a conservative disk sync protocol because ensuring safety more
efficiently required additional state information, adding further
complexity. The Dovecot IMAP server's source code notes this exact
difficulty~\cite[maildir-save.c]{dovecot}:

\vspace{-0.5\baselineskip}
\begin{scriptsize}
\begin{verbatim}
/* FIXME: when saving multiple messages, we could get
   better performance if we left the fd open and
   fsync()ed it later */
\end{verbatim}
\end{scriptsize}
\vspace{-0.5\baselineskip}

The performance of the \opgroup{}-enabled UW IMAP mail server is
evaluated in Section~\ref{sec:evaluation:uwimap}.
