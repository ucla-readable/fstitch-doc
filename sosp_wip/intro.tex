% -*- mode: latex; tex-main-file: "abstract.tex" -*-

\section*{Introduction}
\label{sec:intro}

For robustness, stability, and reboot speed, file system implementations
must ensure that the file system's stored image is kept either consistent
or easy to return to consistency.
%
Advanced consistency mechanisms such as soft updates~\cite{ganger00soft}
and journalling make this possible; unfortunately,
%
consistency mechanisms are generally tied to a particular filesystem, and
can neither be ported nor adapted without significant engineering
effort.
%
Furthermore, interfaces like \verb+fsync()+ give user code only coarse control
over consistency.
%
Applications with both performance and custom consistency requirements get
little help from conventional file systems, which either impose high overhead
(data journalling) or don't guarantee data consistency (soft updates, for
example, provides metadata consistency).



We propose a new file system implementation architecture called
\emph{KudOS}.
%
KudOS \emph{change descriptor} structures represent any and all changes to
stable storage.
%
File system implementations generate change descriptors when blocks are
written and send them to block devices for eventual commit.
%
Each change descriptor stores the old state of the block and its
\emph{dependencies}: other change descriptors that must be committed before
it is safe to commit this change.
%
Explicit dependencies let KudOS modules preserve necessary file system
invariants, without understanding the file system itself; the old state
lets KudOS roll back changes when necessary to break cyclic dependencies.
%
Change descriptors can implement many ways of achieving
consistency, including soft updates and journalling.
%
%
%
KudOS is entirely decomposed into fine-grained modules which generate,
consume, forward, and manipulate change descriptors.
%
A particular innovation of KudOS's module design is the separation of the
low-level specification of a filesystem's on-disk layout from higher-level
filesystem-independent code, which operates only abstractly on disk
structures.

We have implemented a mostly-complete, functional prototype of the KFS
architecture.  Even this prototype greatly increases the
flexibility of standard consistency features, allowing our journalling
module to automatically add journalling to any file system. 
%
%% They also support
%% the implementation of many other possible definitions of filesystem
%% consistency, which in the future we hope will allow for userspace
%% specification. 
%
Besides eventually supporting user-defined dependency structures, the
current module system already allows interesting new interactions, such as
correct consistency on RAID over loopback devices.
